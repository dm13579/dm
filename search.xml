<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL事务系统解析</title>
      <link href="/mysql-shi-wu-xi-tong-jie-xi/"/>
      <url>/mysql-shi-wu-xi-tong-jie-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近啃MySQL相关的知识，了解到事务以及事务隔离机制，想要深入了解下事务是如何实现的下面是此次主要探讨的几点方向。这里先推荐几篇文章</p><p><a href="http://mysql.taobao.org/monthly/2017/12">数据库内核月报 － 2017 / 12</a></p><p><a href="http://mysql.taobao.org/monthly/2017/10">数据库内核月报 － 2017 / 10</a></p><p><a href="http://mysql.taobao.org/monthly/2015/04">数据库内核月报 － 2015 / 04</a></p><ol><li>事务及其ACID特性</li><li>并发事务带来的问题</li><li>事务隔离机制以及解决并发事务问题</li><li>事务隔离机制如何实现（MVCC多版本并发控制机制）</li></ol><h2 id="事务及其ACID特性"><a href="#事务及其ACID特性" class="headerlink" title="事务及其ACID特性"></a>事务及其ACID特性</h2><p>事务一般具有4个特性，这4个特性一般简称ACID特性</p><ul><li>A（原子性）：事务要么全部成功，要么全部失败</li><li>C（一致性）：不管什么时候，数据都是一致的，不会读到中间状态的数据</li><li>I（隔离性）：多个事务之间相互不影响</li><li>D（持久性）：在事务执行过程中，不管怎么样数据都不能丢，MySQL是使用了redo log实现的。</li></ul><h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p>并发事务带来了更新丢失，脏读，不可重读，幻读4种问题</p><ul><li>更新丢失：当多个事务同时执行一行数据时，第一个事务已经对行做了修改但第二个事务不知道就把第一个事务更新的数据给修改了，出现了更新丢失的情况。<strong>当前事务的更新覆盖了其他事务的更新</strong>。</li><li>脏读：第一个事务已经做了写操作，但此时并没有提交事务，然后第二个事务读取到了这条数据，也就是第二条数据读取到了脏数据，这就是所谓的脏读。<strong>当前事务读取了其他事务的已经修改但未提交的数据</strong>。</li><li>不可重读：一个事务开始查询了某个语句，第二次执行同样的语句发现查询的东西不一样了。<strong>当前事务在不同时刻执行同样的查询语句，查询出的结果不一样</strong></li><li>幻读：一个事务按相同的查询条件查询读取已经检索过的数据，却发现其他事务插入了满足条件的数据。<strong>当前事务读取到了其他事务插入的数据</strong></li></ul><h2 id="事务隔离机制"><a href="#事务隔离机制" class="headerlink" title="事务隔离机制"></a>事务隔离机制</h2><p>事务隔离机制有4种，读未提交，读已提交，可重读，串行化</p><ul><li>RU(Read uncommitted)：读未提交</li><li>RC(Read committed)：读已提交</li><li>RR(Repeatable read)：重复读</li><li>SERIALIZABLE(Serializable)：串行化</li></ul><h3 id="隔离级别对并发事务的解决"><a href="#隔离级别对并发事务的解决" class="headerlink" title="隔离级别对并发事务的解决"></a>隔离级别对并发事务的解决</h3><table><thead><tr><th align="center"></th><th align="center">脏读</th><th align="center">不可重读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读未提交</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">读已提交</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">重复读</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">串行化</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><p>读已提交，重复读是通过MVCC机制解决的并发问题。串行化是通过对数据库加锁控制其他事务对数据的操作解决并发问题。<strong>事务隔离级别越高对并发的问题越小，但相应的付出的代价也会越大</strong>；串行化肯定是并发影响最小的，当你访问某个数据时串行化直接来个行锁或表锁，其他的数据只能阻塞在后面等这边的数据处理完成后才可以进行访问。串行化对数据库性能影响太大所以<strong>MySQL综合考虑默认使用的是重复读隔离级别</strong>。</p><h2 id="MVCC多版本并发控制机制"><a href="#MVCC多版本并发控制机制" class="headerlink" title="MVCC多版本并发控制机制"></a>MVCC多版本并发控制机制</h2><p>MVCC（Multi-Version Concurrency Control）：多版本并发控制机制，对一行数据的读写操作不通过加锁来保证隔离性，提高性能。MVCC不是MySQL所特有的在Oracle,PostgreSQL都有关于MVCC的实现，实现可能是不一样的。还有MVCC只在读已提交和重复度2个隔离级别下才干活。读未提交只读最新的数据（不管你事务提不提交）它不需要任何锁，串行化直接搞把锁，所以也不需要MVCC来控制。</p><p>在介绍MVCC机制前先介绍2个概念，undo log和read view</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log是日志版本链，当我们对记录做了变更操作就会产生一条undo记录，undo记录主要在每条数据后面加2个隐藏字段DATA_TRX_ID，DATA_ROLL_PTR其实应该是3个，如果表没有主键还会生成一个DB_ROW_ID。<a href="http://www.searchdoc.cn/rdbms/mysql/dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.com.coder114.cn.html">InnoDB多版本控制</a></p><ul><li>DATA_TRX_ID：事务编号，6字节，记录更新这条行记录的事务编号</li><li>DATA_ROLL_PTR：回滚指针，7字节，记录</li><li>DB_ROW_ID：主键编号，6字节，没有主键会自动生成</li></ul><p>事务id的生成是在对innodb进行了写操作而生成的。在InnoDB看来所有的事务在启动时候都是只读状态是只读事务此时不会生成事务编号。<a href="http://mysql.taobao.org/monthly/2017/12">数据库内核月报 － 2017 / 12</a></p><p>undo log记录过程：首先表里有一个数据，伴随着隐藏字段DATA_TRX_ID，DATA_ROLL_PTR，然后有一个事务100对其进行了修改，这时候我们会把原先的数据copy一份到undo log中去，然后把修改后的数据也放进undo log,但这条数据的DATA_TRX_ID = 100，DATA_ROLL_PTR指向原来的数据。如果这时候又来了一个事务200，此时事务100还没提交，事务200又进行了一次更新会把新数据写进undo log并且DATA_TRX_ID = 200，DATA_ROLL_PTR指向事务100的那条数据。</p><p><img src="https://github.com/dm13579/dm13579.github.com/blob/master/images/image-20200903001101627.png" alt="image-20200903001101627"></p><p>最后在undo log中的日志版本链就是</p><p><img src="..%5Cimages%5Cimage-20200903001035075.png" alt="image-20200903001035075"></p><h3 id="read-view（快照）"><a href="#read-view（快照）" class="headerlink" title="read view（快照）"></a>read view（快照）</h3><p>read view在MVCC里面主要做的就是可见性判断，read view 的生成时机就是RR,RC两种隔离级别的主要区别</p><ul><li>RR隔离级别，只要是开启事务后的第一次select查询操作便会生成一次read view,后面便不再维护read view了</li><li>RC隔离级别，开启事务后，只要进行了查询语句便会生成一次read view</li></ul><h3 id="read-view创建过程"><a href="#read-view创建过程" class="headerlink" title="read view创建过程"></a>read view创建过程</h3><ol><li>首先看当前所有未提交的事务，存储在数组中<strong>trx_ids</strong></li><li>选取未提交事务的最小的事务编号为<strong>up_limit_id</strong>,</li><li>选取已提交事务的最大的事务编号加1为<strong>low_limit_id</strong></li></ol><p>1）trx_id&lt;up_limit_id；小于最小未提交事务肯定是已提交事务，可见<br>2）trx_id&gt;low_limit_id；大于最大已提交事务肯定是后面创建的事务，不可见<br>3）up_limit_id&lt;=trx_id&lt;=low_limit_id；分2种情况</p><ul><li>trx_id在trx_ids中说明是未提交事务，不可见</li><li>trx_id不在trx_ids中说明是已提交事务，可见</li></ul><p>MVCC如何利用日志版本链来进行查询的？</p><p>根据图第二次查询结果还是hello,但此时undo log日志版本链最新的是hello2，这里主要走的过程是，看undolog日志版本链从最新往下看，最新是事务1，发现事务1在已提交事务和未提交事务区间内而且是在trx_ids中，说明是不可见的，所以继续undolog日志版本链往下看。发现是事务3，发现事务3在已提交事务&amp;未提交事务区间而且不再trx_id中所以是可见的。</p><p>​    <img src="..%5Cimages%5Cimage-20200903014442461.png" alt="image-20200903014442461"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
