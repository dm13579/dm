<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Netty线程模型初探和Netty的常见问题</title>
      <link href="/netty-xian-cheng-mo-xing-chu-tan-he-netty-de-chang-jian-wen-ti/"/>
      <url>/netty-xian-cheng-mo-xing-chu-tan-he-netty-de-chang-jian-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Netty是现在比较流行的NIO框架。它的健壮性、可扩展性、性能方面都得到了很多项目的验证。</p><p>要想了解Netty，首先得了解IO模型。Java支持三种IO模型分别是BIO,NIO,AIO。</p><ul><li>BIO：同步阻塞模型，连接一个请求就会有一个线程，假设有个客户端连接进来了，一直不做读写操作，这个连接就会一直占用，会大量的浪费资源，，如果连接的客户端巨多，就会导致线程数暴增，可能服务器都撑不住。使用场景，连接数比较小且不会有连接数暴增</li><li>NIO：同步非阻塞模型，主要实现的是一个线程可以处理多个连接，它的实现逻辑是把所有打过来的请求都会丢到一个selector（多路复用器）上面去，多路复用器在去轮询，根据请求类型进行读、写、连接处理。多路复用器底层就是调用的操作系统的select，poll，epoll方法实现。使用场景：连接数多但连接较短。</li><li>AIO：异步非阻塞模型，发起请求后会回调服务端程序去执行对应的请求，相当于一个钩子程序，NIO的升级版。使用场景：连接数多，且连接耗时较长</li></ul><h2 id="认识Netty"><a href="#认识Netty" class="headerlink" title="认识Netty"></a>认识Netty</h2><p>Netty说白了就是对NIO的一层封装，改造了原来的IO模型提升性能，为了让你代码写起来更方便，增强扩展性。</p><p>Netty在游戏领域，开源中间件（Dubbo,RocketMQ）,大数据领域(Hadoop)，通信行业等方向都有不少的应用。</p><p>Netty优点</p><ul><li>使用简单</li><li>功能强大，内置了很多编解码功能，对主流协议的支持</li><li>定制能力强，可以通过ChannelHandler进行定制化开发</li><li>性能高</li><li>经历了多种行业的锤炼，证明了它的稳定性</li></ul><h2 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h2><p>Netty线程模型跟Reactor模式相一致。而Reacror模式又分为三种。主要核心逻辑可以参照Doug Lea大佬的<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable IO in Java</a></p><ul><li><p>单线程模型</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/20200907215427.png" alt="单线程模型"></p><p>从图可以看出Reactor内部通过selector进行监控，如果收到的是一个连接请求就通过dispatch分发任务给acceptor去处理并生成一个handler去处理之后的读写请求。因为处理连接和读写请求都在一个线程里面去执行，所以如果handler被阻塞了,会导致其他的线程同样不能执行，性能受到影响。</p></li><li><p>多线程模型</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/20200907220454.png" alt="多线程模型"></p><p>从图看出，Reactor收到一个连接请求就分发给acceptor,然后acceptor创建一个Handler处理后续事件Handler不处理业务操作，只负责响应度和写，业务操作扔到线程池里面去操作。这里的性能瓶颈是单Reactor，当有大量的客户端进行连接，可能会有处理不过来的情况。</p></li><li><p>主从多线程模型</p></li></ul><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200907221055477.png" alt="主从多线程模型"></p><p>这里使用了多个Reactor,mainReactor处理进来的连接请求，交给acceptor处理，然后acceptor将新的连接分配给一个子线程，子线程subReactor将分配过来的连接加入连接队列并通过自己的selector进行监听，并创建一个Handler处理后续事件。</p><p>对于Netty而言上诉几种模型都可以实现。主要看NioEventLoopGroup线程个数的分配。</p><p>单线程模型</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 只申请一个工作线程</span>NioEventLoopGroup group <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bootstrap<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>group<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServerHandlerInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>多线程模型</p><pre class=" language-java"><code class="language-java">NioEventLoopGroup eventGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bootstrap<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>eventGroup<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServerHandlerInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>主从多线程模型(最常用)</p><pre class=" language-java"><code class="language-java">NioEventLoopGroup bossGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>NioEventLoopGroup workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bootstrap<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>bossGroup<span class="token punctuation">,</span>workerGroup<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServerHandlerInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Netty的线程模型是对于上诉的Reactor模式进行了一定的升级，但核心思想没有变。</p><p><a href="https://www.processon.com/view/link/5ee107f7f346fb1ae5592b33">Netty线程模型图</a></p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/clipboard.png" alt="Netty线程模型架构"></p><h2 id="Netty相关组件"><a href="#Netty相关组件" class="headerlink" title="Netty相关组件"></a>Netty相关组件</h2><p>Netty的一个服务端通用代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    EventLoopGroup bossGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    EventLoopGroup workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bootstrap<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>bossGroup<span class="token punctuation">,</span> workerGroup<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token operator">&lt;</span>SocketChannel<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span>SocketChannel ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                    ChannelPipeline pipeline <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"decoder"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"encoder"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ChannelFuture channelFuture <span class="token operator">=</span> bootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">9000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channelFuture<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        bossGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        workerGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>Selector：通过Selector监听多个连接的channel事件，通过selector轮训所有注册的channel,</li><li>NioEventLoopGroup：相当于一个线程池，内部维护类一组线程（NioEventLoop），每个线程处理多个Channel上的事件。</li><li>NioEventLoop：里面有线程和任务队列，有run方法处理不同的事件</li><li>ServerBootstrap：串联Netty所有组件，是Netty的启动类。</li><li>ChannelHandler：ChannelHandler处理I/O事件，并将其转发到pipeline中的下一个处理程序<ul><li>ChannelInboundHandler：处理入站IO事件</li><li>ChannelOutboundHandler：处理出站IO事件</li></ul></li><li>ChannelHandlerContext：关联ChannelHandler</li><li>ChannelPipline：一个由ChannelHandlerContext构成的过滤器链，它是一个双向链表,他会维护一个head和tail,入站则是head-&gt;tail,出站是tail到head,<strong>注意：入站和出站在这里是相对的，read是入站事件，write是出站事件，服务端写数据到客户端，服务端是出站事件，客户端是入站事件</strong></li></ul><h2 id="Netty常见问题"><a href="#Netty常见问题" class="headerlink" title="Netty常见问题"></a>Netty常见问题</h2><h3 id="编解码问题"><a href="#编解码问题" class="headerlink" title="编解码问题"></a>编解码问题</h3><pre class=" language-java"><code class="language-java"> ChannelPipeline pipeline <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"decoder"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 解码器</span> pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"encoder"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 编码器</span> pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>首先服务器之间的通讯只能是字节，然后我们要把消息发送到客户端，首先要对发送内容进行编码，客户端要对收到内容进行解码.上诉代码就是一个编解码的pipeline.通过分析StringEncoder编码器应该继承的是ChannelOutboundHandlerAdapter或者实现了ChannelOutboundHandler满足出站事件。StringDecoder解码器应该继承的是ChannelInboundHandlerAdapter或者实现了ChannelInboundHandler满足入站事件。看一下继承关系图，发现分析正确</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/20200907231616.png" alt="StringDecoder继承关系图"></p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/20200907231755.png" alt="StringEncoder继承关系图"></p><p>Netty还有其他的编解码器，比如ObjectEncoder和ObjectDecoder</p><h3 id="粘包拆包问题"><a href="#粘包拆包问题" class="headerlink" title="粘包拆包问题"></a>粘包拆包问题</h3><p>由于TCP是面向流的，所以是无消息保护边界的。发送端有时为了更有效地将数据包发送给对方，有时会把多个数据包合并为一个发送就是粘包问题，把一个数据包拆分成多个就是拆包问题。这样带来的问题就是虽然你是提高了效率，但是接收端这边就无法分清哪个数据包是哪个了。</p><p>解决方案：</p><ol><li>对发送内容进行边界控制，就是在你所发送的内容开始与结束加上标志符。但这样不好用，因为每次开发你都的加上边界符，不易于其他人对代码的理解。</li><li>在你所发送的内容上加上发送内容的长度，通过长度判断数据的开始与结束。</li></ol><h3 id="Netty零拷贝"><a href="#Netty零拷贝" class="headerlink" title="Netty零拷贝"></a>Netty零拷贝</h3><p>在零拷贝之前必须了解直接内存与堆内存的区别；堆内存顾名思义就是放在JVM堆里面的内存,直接内存是排除掉堆内存的其他内存相当于物理内存，gc不参与到其中，这部分内存JVM管不着；</p><p>申请直接内存：java申请直接内存会调用本地native方法，在物理内存上申请一块空间，然后自己JVM堆内存上也分配一块叫DirectByteBuffer的空间，DirectByteBuffer里面会存申请的物理内存的内存地址的开始位置，和数据长度，通过定位和长度就能确定数据了。</p><p>内存回收：JVM gc 管不了他们那么怎么将这部分内存进行回收呢？在申请直接内存的时候会给引用对象绑定一个Cleaner机制，就是只要引用对象一被GC,那么就会触发Cleaner机制把内存回收。</p><p>直接内存与堆内存对比：读写上直接内存更快；申请空间上堆内存更快。</p><p>下面可以介绍零拷贝了</p><p>我们客户端发一条数据到服务端，服务端需要在IO读写层面需要做哪些操作呢？</p><p>假设没有零拷贝，发生的情况就是客户端发一条数据到服务端，服务端将这条数据放到socket缓冲区然后拷贝到直接内存（数据不能直接给堆内存），然后直接内存把数据拷贝到JVM堆内存，然后JVM对数据进行修改后在将数据拷贝到直接内存（数据不能直接给socket缓冲区）,然后直接内存把数据拷贝到socket缓冲区。大家数一下中间发生了几次拷贝。共4次拷贝，</p><p>以刚刚的例子来说零拷贝技术就是客户端发一条数据到服务端，服务端将这条数据socket缓冲区然后拷贝到直接内存，然后堆内存会有一个DirectByteBuffer映射到这一块直接内存，然后JVM对数据进行修改将数据直接改到直接内存，然后直接内存拷贝给socket缓冲区总共发生2次拷贝，零拷贝就是减少数据之间的拷贝。</p><h4 id="直接内存优缺点"><a href="#直接内存优缺点" class="headerlink" title="直接内存优缺点"></a>直接内存优缺点</h4><p>优点：</p><pre><code>        * 不占用堆内存        * 内存读写快</code></pre><p>缺点</p><ul><li>申请空间慢</li><li>有物理内存被撑爆的可能性，这就跟JVM元空间内存机制是一样的，元空间也是直接内存，然后元空间必须设置最大值一个道理。在这里我们可以和元空间的处理类似，加上一个配置参数-XX：MaxDirectMemorySize控制直接内存的大小</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> IO模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap1.7和1.8对比与源码解析</title>
      <link href="/concurrenthashmap/"/>
      <url>/concurrenthashmap/</url>
      
        <content type="html"><![CDATA[<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h2 id="基本参数介绍"><a href="#基本参数介绍" class="headerlink" title="基本参数介绍"></a>基本参数介绍</h2><h2 id="jdk1-7和jdk1-8对比"><a href="#jdk1-7和jdk1-8对比" class="headerlink" title="jdk1.7和jdk1.8对比"></a>jdk1.7和jdk1.8对比</h2><h3 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><h3 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p>​       </p><h2 id="HashMap-jdk1-7源码解析"><a href="#HashMap-jdk1-7源码解析" class="headerlink" title="HashMap jdk1.7源码解析"></a>HashMap jdk1.7源码解析</h2><h2 id="HashMap-jdk1-8源码解析"><a href="#HashMap-jdk1-8源码解析" class="headerlink" title="HashMap jdk1.8源码解析"></a>HashMap jdk1.8源码解析</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 集合 </tag>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap1.7和1.8对比与源码解析</title>
      <link href="/hashmap/"/>
      <url>/hashmap/</url>
      
        <content type="html"><![CDATA[<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p><strong>put过程</strong>：它会hash传入的key值，将hash的值&amp;上map长度减一（这里用的是&amp;而不是取模运算，应该是考虑到性能问题，这里是length-1是应为这样可以取到0到map.length-1的值）插入到对应的数组下标上面去。这时产生了一个问题就是2个key值hash到一个位置怎么办？这就是Hash碰撞，产生了Hash碰撞在当前数组位置产生一个链表，如果链表过长查询效率可能会减低，在jdk1.8上面达到了一定的程度会链表转红黑树增强查询效率。</p><p><strong>get过程</strong>：hash传入的key值，将hash的值&amp;上map长度减一在数组里面去找找到对应的数组位置如果不是传入的key值就顺着链表或红黑树继续往里面找，所以他的时间复杂度是O(1)。</p><p><strong>扩容</strong>：当数据达到map总长度的加载因子倍数就会开始扩容</p><h2 id="基本参数介绍"><a href="#基本参数介绍" class="headerlink" title="基本参数介绍"></a>基本参数介绍</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 数组默认大小，默认为16，必须设值为2的n次幂，如果设值不是2的n次幂它会往大于你的值的最近的2次幂</span><span class="token comment" spellcheck="true">// 比如你设map长度为9它会修改map长度为2的4次，也就是16</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 加载因子，数组长度大于容量的0.75就会扩容，为什么是9.75？基于空间与时间的考虑，如果太满了可能会有很多的hash碰撞，hash碰撞越多，链表就会越长，查询效率就会太低，加载因子如果太小了就会导致扩容频繁，通过牛顿二项式推导得出，0.693是最为合适的值，java选择了0.75</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span></code></pre><h2 id="jdk1-7和jdk1-8对比"><a href="#jdk1-7和jdk1-8对比" class="headerlink" title="jdk1.7和jdk1.8对比"></a>jdk1.7和jdk1.8对比</h2><h3 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><p>数据结构：数组+链表</p><p>扩容：1.7的扩容会先把当前数组长度乘2生成一个新数组，然后对原来的Map里面的值进行reHash.重新落入到新数组中。</p><p>链表插入方式：尾插法</p><h3 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p>数据结构：数组+链表+红黑树</p><p>扩容：1.8的扩容有个高低位的概念，它将原来的key Hash过后&amp;map长度,这时候会生成2种值要么是0，要么是数组长度，这时候是0的我们算作低位，数组长度的算作高位，这时候我们有2个链表一个低位链表一个高位链表，低位链表还是在原来的位置，高位链表移到原来位置加上数组长度的位置。</p><p>链表插入方式：尾插法</p><p>链表转红黑树判定：链表长度<strong>大于8,也就是第9个元素</strong>，还有一个条件是容量大于64</p><p>​    为什么要把阈值设为8呢？</p><p>​    下面是HashMap源码里面的注释。大致意思就是数组中链表长度达到相应的数字概率是多少（这里是通过泊松分布计算得出），前提是随机hash码和加载因子是0.75.可以看出来到8的时候概率是很低了。从这一方面可以看出HashMap正常情况下转红黑树的几率是极其小的。也可以侧面的反映出HashMap在1.7到1.8性能上的提升其实并不大，数据量极大的情况下是有提升的。</p><pre class=" language-java"><code class="language-java"><span class="token operator">*</span> Because TreeNodes are about twice the size of regular nodes<span class="token punctuation">,</span> we<span class="token operator">*</span> use them only when bins contain enough nodes to warrant use<span class="token operator">*</span> <span class="token punctuation">(</span>see TREEIFY_THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">.</span> And when they become too <span class="token function">small</span> <span class="token punctuation">(</span>due to<span class="token operator">*</span> removal or resizing<span class="token punctuation">)</span> they are converted back to plain bins<span class="token punctuation">.</span>  In<span class="token operator">*</span> usages with well<span class="token operator">-</span>distributed user hashCodes<span class="token punctuation">,</span> tree bins are<span class="token operator">*</span> rarely used<span class="token punctuation">.</span>  Ideally<span class="token punctuation">,</span> under random hashCodes<span class="token punctuation">,</span> the frequency of<span class="token operator">*</span> nodes in bins follows a Poisson distribution<span class="token operator">*</span> <span class="token punctuation">(</span>http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>en<span class="token punctuation">.</span>wikipedia<span class="token punctuation">.</span>org<span class="token operator">/</span>wiki<span class="token operator">/</span>Poisson_distribution<span class="token punctuation">)</span> with a<span class="token operator">*</span> parameter of about <span class="token number">0.5</span> on average <span class="token keyword">for</span> the <span class="token keyword">default</span> resizing<span class="token operator">*</span> threshold of <span class="token number">0.75</span><span class="token punctuation">,</span> although with a large variance because of<span class="token operator">*</span> resizing granularity<span class="token punctuation">.</span> Ignoring variance<span class="token punctuation">,</span> the expected<span class="token operator">*</span> occurrences of list size k <span class="token function">are</span> <span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span> The first values are<span class="token operator">:</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">0</span><span class="token operator">:</span>    <span class="token number">0.60653066</span><span class="token operator">*</span> <span class="token number">1</span><span class="token operator">:</span>    <span class="token number">0.30326533</span><span class="token operator">*</span> <span class="token number">2</span><span class="token operator">:</span>    <span class="token number">0.07581633</span><span class="token operator">*</span> <span class="token number">3</span><span class="token operator">:</span>    <span class="token number">0.01263606</span><span class="token operator">*</span> <span class="token number">4</span><span class="token operator">:</span>    <span class="token number">0.00157952</span><span class="token operator">*</span> <span class="token number">5</span><span class="token operator">:</span>    <span class="token number">0.00015795</span><span class="token operator">*</span> <span class="token number">6</span><span class="token operator">:</span>    <span class="token number">0.00001316</span><span class="token operator">*</span> <span class="token number">7</span><span class="token operator">:</span>    <span class="token number">0.00000094</span><span class="token operator">*</span> <span class="token number">8</span><span class="token operator">:</span>    <span class="token number">0.00000006</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 链表转红黑树阈值</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 红黑树转链表阈值</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 链表转红黑树，map最小容量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span></code></pre><h2 id="HashMap-jdk1-7源码解析"><a href="#HashMap-jdk1-7源码解析" class="headerlink" title="HashMap jdk1.7源码解析"></a>HashMap jdk1.7源码解析</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 第一次开始put值的时候，hash表是空的</span>    <span class="token comment" spellcheck="true">// threshold是传进来的长度</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这里证明了HashMap的key可以为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 空就往第一个数组位置里面插</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里判断传进来的key是不是已经写过了，写过了就把value修改掉</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 下文有介绍modeCount存在的意义。这里不影响put主体流程，所以暂时可以不关心</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// put进去</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inflateTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> toSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Find a power of 2 >= toSize</span>    <span class="token comment" spellcheck="true">// 这里就是空间修正代码，找到当前传的值，大于值且是2的指数次幂</span>    <span class="token keyword">int</span> capacity <span class="token operator">=</span> <span class="token function">roundUpToPowerOf2</span><span class="token punctuation">(</span>toSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里是扩容指标</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>capacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里判断是判断是否需要扩容</span>    <span class="token comment" spellcheck="true">// 判断条件是map长度大于扩容阈值，而且当前数组下标必须放了值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 扩容大小 -> map长度的2倍 </span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里就是keu为null的时候会往数组第一个位置放</span>        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// indexFor就是&amp;数组长度-1</span>        bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 元素放进去了</span>    <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ========================================扩容方法===============================</span><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 容错不管它</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>        threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// new 一个新的hash表</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 核心方法</span>    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把新的table,扩容阈值重新写入</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 新的数组容量</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历原来的table表</span>    <span class="token comment" spellcheck="true">// 这里使用双重循环是因为我们的hashmap数据结构是数组加链表，第一重遍历数组第二重遍历链表找到元素开始reHash</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// next为当前链表的下一个元素，为了后面的循环</span>            <span class="token comment" spellcheck="true">// 1</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// rehash当前节点</span>                e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>               <span class="token comment" spellcheck="true">// 用扩容后的hashmap长度计算出当前节点应该落到哪个节点上面去。</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 当前节点与别的节点指针断开指向新的节点位置</span>            <span class="token comment" spellcheck="true">// 2</span>            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 把值赋给新的节点位置，从这可以看出它是使用的是头插法</span>            <span class="token comment" spellcheck="true">// 3</span>            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 为了新一轮的遍历</span>            e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="HashMap并发场景下的死锁问题"><a href="#HashMap并发场景下的死锁问题" class="headerlink" title="HashMap并发场景下的死锁问题"></a>HashMap并发场景下的死锁问题</h3><p>（吐槽：在并发场景使用HashMap，想什么呢，HashMap本身是线程不安全的还敢在并发下用？）。</p><p>我们想一下现在有2个线程thread1,thread2,这2个线程都在进行扩容，都走到了transfer方法的2重循环内，这完全是可能的吧，因为它全程没有锁，因为它是线程不安全的。现在thread1走到了transfer代码段1（上面源码解析标注）的位置，已经把next节点定下来了时间片轮转到thread2了。thread2执行到代码段3，这时候thread1在继续往下走，最后会发现2个节点会出现循环链表。说不清，画个图来说吧。</p><p>​    <img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/20200909112458.png" alt="原hashMap"></p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/20200909115304.png"></p><h3 id="HashMap多线程丢数据情况分析"><a href="#HashMap多线程丢数据情况分析" class="headerlink" title="HashMap多线程丢数据情况分析"></a>HashMap多线程丢数据情况分析</h3><p>代码定位到addEntry()-&gt;createEntry()方法中</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果有多个线程同时拿的e,e应该是当前table[i]链表的第一个元素，然后你这时候拿到多个元素就会出现元素覆盖的请况，thread1头插法排到了第一个元素，而thread2拿到的e是第二个元素，用头插法，一插好家伙，吧我thread1插入的数据给顶掉了，最后thread1写的数据就丢失了，在jdk1.8这种情况也在发生，因为他是线程不安全的。<strong>注意，多线程不要用HashMap，请用ConcurrentHashMap</strong>            </p><h2 id="HashMap-jdk1-8源码解析"><a href="#HashMap-jdk1-8源码解析" class="headerlink" title="HashMap jdk1.8源码解析"></a>HashMap jdk1.8源码解析</h2><p>hashMap jdk1.8跟1.7大体逻辑是差不多的，我们就看下改动比较大的几个点</p><h3 id="树化"><a href="#树化" class="headerlink" title="树化"></a>树化</h3><p>上面说了jdk1.8的HashMap有了红黑树的数据结构，那么他怎么才会变为红黑树呢？TREEIFY_THRESHOLD = 8</p><p>下面这段是put中的关键代码从这段代码可以看出，binCount&gt;=7,所以循环肯定是8次也就是这个时候链表长度是8了。但在这个时候它先执行的是p.next = newNode(hash, key, value, null);然后在判断链表长度，所以链表长度是9的时候它才会满足树化的第一个条件走treeifyBin；不信可以测试一下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>​    树化还有一个条件就是hashmap容量大于64，这个条件就在上面的treeifyBin方法内，第一个判断就是如果容量没有达到MIN_TREEIFY_CAPACITY=64就先走扩容策略，不走树化，反之直接树化（在else逻辑内）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hd <span class="token operator">=</span> null<span class="token punctuation">,</span> tl <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> <span class="token function">replacementTreeNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> null<span class="token punctuation">)</span>                hd <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">;</span>                tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            tl <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hd<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>            hd<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h3><p>上面说到了它的扩容策略和jdk1.7是有了极大的区别，现在我们来看一下源码是怎么实现的。源码太长就不细看了，主要逻辑就是它里面分了2组链表</p><p>Node&lt;K,V&gt; loHead = null, loTail = null;<br>Node&lt;K,V&gt; hiHead = null, hiTail = null;</p><p>这2组就是高位链表和低位链表，怎么往这2个链表里面放呢？if ((e.hash &amp; oldCap) == 0) 满足这个条件就是低位链表，简单来说就是&amp;上老的容量算出来只有可能为0或hashmap的长度，为0算低位，不为0算高位。newTab[j] = loHead; newTab[j + oldCap] = hiHead;这2段代码就表明了它们应该落得位置。</p><p>（1.8的HashMap源码太复杂了，全是位运算和判断逻辑看的心累，对于1.8的源码就不详细写了。）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>                 oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// zero initial threshold signifies using defaults</span>        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// preserve order</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="modCount字段是干嘛的"><a href="#modCount字段是干嘛的" class="headerlink" title="modCount字段是干嘛的"></a>modCount字段是干嘛的</h2><p>在很多集合类都有modCount的身影，那么它到底是干嘛的呢？我们发现它存在的地方都是对集合进行了修改操作比如增加元素，删除元素。而且看过ConcurrentHashMap源码发现没有这个参数了，那么很明显它可能跟线程安全有关。还记得我们在hashMap遍历的时候如果对其进行元素的操作会发生ConcurrentModificationException异常。其实他就跟modCount有关，在迭代过程中，它会判断 modCount 跟 expectedModCount 是否相等，不等说明有其他线程在修改元素，就抛出了异常。这是<strong>Fail-Fast 机制</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程介绍与线程池底层实现原理</title>
      <link href="/duo-xian-cheng-jie-shao-yu-xian-cheng-chi-di-ceng-shi-xian-yuan-li/"/>
      <url>/duo-xian-cheng-jie-shao-yu-xian-cheng-chi-di-ceng-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="Java线程跟操作系统的关系"><a href="#Java线程跟操作系统的关系" class="headerlink" title="Java线程跟操作系统的关系"></a>Java线程跟操作系统的关系</h2><p>CPU一般有4个安全等级ring0,ring1,ring2,ring3,操作系统的内部程序指令一般运行在ring0级别，而我们的应用程序会运行在ring3上面，比如JVM进程。为什么说JVM线程的创建是一个比较重的操作。下面是一个线程创建的过程：</p><ol><li>ring3级别切换到ring0去创建线程</li><li>从ring0切回ring3,然后线程去执行程序</li><li>执行完毕就会销毁线程，这时候又会切换到ring0去销毁线程</li></ol><p>正因为线程创建销毁很重，所以才有了线程池，让一个线程多干点活，不让它活一干完就死了。这一点后面再说。</p><p>操作系统在内存上面分为用户空间，和内核空间</p><ul><li>用户空间放的是我们应用程序执行的代码</li><li>内核空间放的是内核代码</li></ul><p>因为操作系统这样的划分，所以我们有2种线程模型，KLT(内核线程模型)，ULT(用户线程模型)</p><p>内核线程模型是由内核去创建线程，用户线程模型是由用户去创建的线程。JVM就是一种内核线程模型所以便会有大量的用户态内核态之间的切换，用户线程模型就不会有这样的问题。</p><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>假设现在有2个线程thread1,thread2</p><ol><li>CPU会给这2个线程分配一个时间周期，这里假设为50ns</li><li>thread1执行了50ns就要切换回thread2执行，此时thread1的执行状态保存到TSS(程序任务状态段)上面去，方便下次找到我执行的时刻。</li></ol><p>正因为线程的时间片轮转机制所以给人的感知就是多个线程在同时执行，也就是并发。</p><p>那么现在有个问题就是多线程运行程序一定比单线程快吗？</p><p>其实不一定，多线程运行程序必然会存在着大量的线程上下文切换还有线程的创建和销毁，这些操作也是会耗时间的，而单线程不会有这样过的问题，所以是有可能多线程没有单线程要快的。</p><h3 id="如何减少线程的上下文切换"><a href="#如何减少线程的上下文切换" class="headerlink" title="如何减少线程的上下文切换"></a>如何减少线程的上下文切换</h3><ul><li>无锁并发编程：线程竞争锁的时候是会引起上下文切换的，用多线程处理数据可以分段处理，将数据拆分处理比如thread1处理0到100，thread2处理101到200，减少线程间资源的竞争</li><li>CAS算法：用CAS来对数据进行更新不需要加锁，Doug lea的AQS框架大量的运用到了这种算法。</li><li>尽量不要创建不必要的线程，用多少创建多少。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么要线程池"><a href="#为什么要线程池" class="headerlink" title="为什么要线程池"></a>为什么要线程池</h3><p>线程随用即用不好吗，为什么还要引入一个线程池的概念。首先线程资源很珍贵，不能让你想用我就new Thread()就行了，这样不仅浪费了了CPU的资源还可能拖慢运行程序。打个比方，我执行100个任务，每个任务执行时间是1ns,而我线程创建和销毁时间大概是5ns,那么我对线程的操作比执行任务的时间还长，这样降低了整个系统的运行效率。那么如何让我们创建的线程放在那不动（不会销毁），来一个活，我就接一个。这样不是会减少大量的线程创建和销毁吗。这种运用线程的方法就是线程池。简单来说就是对线程的重用。</p><h3 id="线程池的参数配置"><a href="#线程池的参数配置" class="headerlink" title="线程池的参数配置"></a>线程池的参数配置</h3><p>关于线程池的使用不介绍了，主要谈谈线程池的参数配置。先看下创建一个线程池对象的静态方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span>                              BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">&gt;</span> workQueue<span class="token punctuation">,</span>                              ThreadFactory threadFactory<span class="token punctuation">,</span>                              RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>在一个简单的例子中介绍这7个参数</p><p>首先来一个任务，我们会判断已经创建的线程数是否小于等于 corePoolSize（核心线程数），如果小于就会创建一个线程（线程会带着任务），如果大于就会往workQueue（阻塞队列）里面去放，如果阻塞队列里面也放满了，如果此时线程数（核心线程数+非核心线程数）小于maximumPoolSize（线程总数）就会去创建一个非核心线程，大于就会走handler（拒绝策略）</p><p><strong>注意：核心线程只有创建的时候是直接拿到的任务，后续的任务全部都是去阻塞队列里面去拿的。</strong></p><p>拒绝策略分为4种当然你也可以实现RejectedExecutionHandler接口去重写rejectedExecution拒绝策略</p><p>默认4种，比较重要的就是CallerRunsPolicy，DiscardOldestPolicy：</p><ul><li>AbortPolicy: 抛异常</li><li>CallerRunsPolicy：主线程自己去执行任务</li><li>DiscardOldestPolicy：从阻塞队列里面踢掉最先进的那个元素，然后自己入队</li><li>DiscardPolicy：不作任何处理</li></ul><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span></code></pre><ul><li>RUNNING：线程池在RUNNING状态，可以接受新任务，和处理所有任务，线程刚创建就是RUNNING状态</li><li>SHUTDOWN：不接受新任务，但处理已经有的任务，<strong>shutdown方法</strong>将RUNNING-&gt;SHUTDOWN</li><li>STOP：不接受新任务，不处理已有任务，并且中断正在执行的任务，<strong>shutdownNow方法</strong>切换到STOP状态</li><li>TIDYING：所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态，而且还会执行<strong>terminated方法</strong>钩子函数，执行逻辑可以自己实现。阻塞队列为空并且线程池中执行的任务也为空时会转变为TIDYING</li><li>TERMINATED：线程池彻底终止。线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</li></ul><h3 id="excute方法源码分析"><a href="#excute方法源码分析" class="headerlink" title="excute方法源码分析"></a>excute方法源码分析</h3><p>这里有个重要参数ctl，ctl存储的是线程状态位和活跃线程数，他是一个ArtomicInteger,利用了int类型32位的特性，就32位中的前3位用来存储线程的状态后28位存储活跃线程数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ctl这里存储的是线程池状态位和活跃线程数</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从ctl里面取得活跃线程数看活跃是否小于核心线程池数量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 小于核心线程池数量就创建一个核心线程，注意这里传的值是true,标识了核心线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 活跃状态就往阻塞队列里面放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里为什么又要拿一次状态，主要就是防止入队前后线程池状态的变化</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 再次检查线程池状态是否运行状态，不是就移除刚刚放进来的任务，并且走拒绝策略</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里为什么要判有效线程数为什么是0，主要是创建线程池时核心线程数量可以为0</span>        <span class="token comment" spellcheck="true">// 如果核心线程数是0，那么执行到这里队列中有1个任务，但没有一个可以干活的线程，这时候要创建</span>        <span class="token comment" spellcheck="true">// 一个线程去干活了，为什么是false，因为你设置的核心线程数为0这里只能创建一个非核心线程</span>        <span class="token comment" spellcheck="true">// 为什么是null,是因为这时候任务在队列里面了，我不能创建线程的时候在带着任务，只能让线程去</span>        <span class="token comment" spellcheck="true">// 队列里面去取了。</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 到这一步说明了干活线程大于核心线程池数，而且阻塞队列也满了，此时会创建一个非核心线程</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 创建非核心线程失败了，就直接走拒绝策略</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="addWorker方法源码分析"><a href="#addWorker方法源码分析" class="headerlink" title="addWorker方法源码分析"></a>addWorker方法源码分析</h3><p>addWorder方法主要工作是创建一个新的线程</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * firstTask：是线程创建时的第一个任务 * core： true就是与corePoolSize比较，false就是与maximumPoolSize比较 **/</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    retry<span class="token operator">:</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 拿运行状态</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Check if queue empty only if necessary.</span>        <span class="token comment" spellcheck="true">// 运行状态大于shutdown状态就不接活了，</span>        <span class="token comment" spellcheck="true">// 如果状态是shutdown，虽然不接活，但也要处理之前遗留的队列里面的任务，</span>        <span class="token comment" spellcheck="true">// 但前提你不能给我任务firstTask</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>               firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>               <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// wc&gt;=CAPACITY:工作不能大于等于所设的最大值就是int位的低29位</span>            <span class="token comment" spellcheck="true">// private static final int COUNT_BITS = Integer.SIZE - 3;</span>            <span class="token comment" spellcheck="true">// private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span>            <span class="token comment" spellcheck="true">//  wc &gt;= (core ? corePoolSize : maximumPoolSize)就是按core传值判断是否不和规范</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">&gt;=</span> CAPACITY <span class="token operator">||</span>                wc <span class="token operator">&gt;=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// CAS增加workcount,成功则跳出第一个循环，失败继续自旋</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 重新拿一下状态看状态是否修改，修改了就去第一个循环重新判断</span>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Re-read ctl</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建worker对象</span>        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// worker对象里面都有一个线程</span>        <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Recheck while holding lock.</span>                <span class="token comment" spellcheck="true">// Back out on ThreadFactory failure or if</span>                <span class="token comment" spellcheck="true">// shut down before lock acquired.</span>                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 这里主要是判断的是线程可不可以运行</span>                <span class="token comment" spellcheck="true">// 2个条件满足其一</span>                <span class="token comment" spellcheck="true">// 1: 运行状态</span>                <span class="token comment" spellcheck="true">// 2: shutdown状态，但新任务为空，可以执行wordQueue里面的任务</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                    <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// workers是一个HashSet</span>                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 记录出现过的线程最大数量</span>                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> largestPoolSize<span class="token punctuation">)</span>                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 启动 worker里面的线程，这时候应该去看Worker对象里面的run方法</span>                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>            <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="Worker对象的run方法"><a href="#Worker对象的run方法" class="headerlink" title="Worker对象的run方法"></a>Worker对象的run方法</h3><p>Worker是一个ThreadPoolExecutor内部类，此时才是真正干活的线程</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 他这里继承了AQS和实现了Runable</span><span class="token comment" spellcheck="true">// 实现Runable是为了让自己成为一个线程</span><span class="token comment" spellcheck="true">// 继承AQS是为了实现独占锁，在addWorker里面会用到，为什么不用ReentrantLock呢？</span><span class="token comment" spellcheck="true">// TODO</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>        <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>        <span class="token keyword">implements</span> <span class="token class-name">Runnable</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6138294804551838833L<span class="token punctuation">;</span>        <span class="token keyword">final</span> Thread thread<span class="token punctuation">;</span>        Runnable firstTask<span class="token punctuation">;</span>        <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>        <span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 初始化把state设值为-1，是为了使还没执行任务的线程不会被中断，执行任务时会把它设为0</span>            <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>            <span class="token comment" spellcheck="true">// 这里吧firstTask保存，并带到线程去</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 调用外部类runWorker方法</span>            <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Lock methods</span>        <span class="token comment" spellcheck="true">//</span>        <span class="token comment" spellcheck="true">// The value 0 represents the unlocked state.</span>        <span class="token comment" spellcheck="true">// The value 1 represents the locked state.</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 尝试CAS更新state状态值为1失败，返回false，从这一点可以看出Worker是想做一把不可重入的锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">interruptIfStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Thread t<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> thread<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化的时候state是-1，这里调用unlock是吧它置为0，可以中断</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果task为空，则通过getTask来获取任务</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 执行任务，如果任务发生了异常，会往外抛执行processWorkerExit方法，</span>                    <span class="token comment" spellcheck="true">// 从这个方法可以看出线程池不会因为某个任务发生异常就不执行了，发生异常线程池会创建一个没有任务的线程</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// timeOut：上次从队列拿任务时是否超时</span>    <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Did the last poll() time out?</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 线程池不在runing看线程池是否在stop或者阻塞队列是否为空</span>        <span class="token comment" spellcheck="true">// 如果是true。那线程池是不能执行新任务</span>        <span class="token comment" spellcheck="true">// 就应该吧之前放进来的任务去掉，也就是要把wordcount-1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Are workers subject to culling?</span>        <span class="token comment" spellcheck="true">// 判断是否需要进行超时控制</span>        <span class="token comment" spellcheck="true">// allowCoreThreadTimeOut默认false,这一点可以看得出来核心线程数不会进行超时控制</span>        <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">&gt;</span> corePoolSize<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里做的事情主要是如果有超时控制且确实超时了，而且阻塞队列是空的</span>        <span class="token comment" spellcheck="true">// 也就说明我们工作线程太多了，这时候就应该要减少工作线程，减一失败则重试</span>        <span class="token comment" spellcheck="true">// 但这里有timed控制也说明了它不会减核心线程</span>        <span class="token comment" spellcheck="true">// 线程如何销毁呢？</span>        <span class="token comment" spellcheck="true">// 这里CAS成功则返回null,返回null则表示runWorker 的while循环要跳出去了，也就是线程结束了，JVM回收即可。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">&gt;</span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果有超时控制就用阻塞队列的poll方法可以控制时间，</span>            <span class="token comment" spellcheck="true">// workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)表示在keepAliveTime时间下如果取不出来值会阻塞，超过时间就返回null</span>            Runnable r <span class="token operator">=</span> timed <span class="token operator">?</span>                workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span>            workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> r<span class="token punctuation">;</span>            timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span>            timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="processWorkerExit方法"><a href="#processWorkerExit方法" class="headerlink" title="processWorkerExit方法"></a>processWorkerExit方法</h3><p>processWorkerExit方法在于runWorker的finally代码块里面的，执行任务发生异常或正常结束任务会走的方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">,</span> <span class="token keyword">boolean</span> completedAbruptly<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// completedAbruptly这个参数在runWorker里面传入的，</span>    <span class="token comment" spellcheck="true">// true说明发生了异常,我们要将workcount减一；所以走了decrementWorkerCount方法</span>    <span class="token comment" spellcheck="true">// false说明正常结束任务，怎么结束？getTask方法为null.说明我们已经将wordcount已经减一了。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>completedAbruptly<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// If abrupt, then workerCount wasn't adjusted</span>        <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 统计完成的任务数</span>        completedTaskCount <span class="token operator">+=</span> w<span class="token punctuation">.</span>completedTasks<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从workers中移除，说明从线程池移除了一个工作线程</span>        workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据线程池状态判断是否要终止线程池</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果当前线程池状态是RUNNING,或SHUTDOWN状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果不是异常终止</span>        <span class="token comment" spellcheck="true">// allowCoreThreadTimeOut = true 而且阻塞队列为空时，一个线程不留</span>        <span class="token comment" spellcheck="true">// allowCoreThreadTimeOut = true 而且阻塞队列不为空时，就保留最少一个线程</span>        <span class="token comment" spellcheck="true">// allowCoreThreadTimeOut = false 就保留最少线程小于核心线程数</span>        <span class="token comment" spellcheck="true">// min值有0,1，corePoolSize三种</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>completedAbruptly<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> corePoolSize<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> min<span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// replacement not needed</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果是异常终止的会 addWorker(null, false)加一个null任务的线程</span>        <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="延迟类线程池"><a href="#延迟类线程池" class="headerlink" title="延迟类线程池"></a>延迟类线程池</h2><p>线程池家族里面有一类特殊的线程池，叫做延迟类线程池ScheduledThreadPoolExecutor，先看一下它的继承关系</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/20200907114109.png"></p><p>很明显它继承了ThreadPoolExcutor,所以他也是一个线程池，只是在线程池上对他进行了增强，在看一下它的构造方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                                       ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                                       RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                                       ThreadFactory threadFactory<span class="token punctuation">,</span>                                       RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> threadFactory<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>从中可以看出它不需要很多的参数，在线程池中的大部分参数它不要设置，比如最大线程数和超时时间和超时时间单位，在延迟类线程池中只需要传入一个核心线程数就可以创建一个延迟线程池了。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>它和线程池的处理不一样，来了一个任务它不会直接创建工作线程，而是直接丢到队列里面去。线程去队列里面去拿任务执行。</p><p>他这里的队列有点特别，它是DelayQueue，它会根据时间排序。因为他要保证延迟线程池里面不同的线程所延迟时间不同，他需要根据延迟时间吧他们排好序，先执行的应该在最前面。</p><p>下面先介绍下ThreadPoolExcutor的三种提交任务的方式.</p><ol><li><p>schedule方法，延迟执行，scheduler第二个参数和第三个参数规定了延迟时间。</p><pre class=" language-java"><code class="language-java">ScheduledThreadPoolExecutor scheduledThreadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>scheduledThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>scheduleWithFixedDelay方法，延迟执行，周期执行，等待之前的任务执行完成才开始计算周期时间。第一个参数：任务，第二个参数：初始化延时时间，第三个参数是周期时间，第四个参数时间单位</p><p>下面这段代码执行会是执行完第一个任务睡5秒，5秒睡完才开始计算时间计算到周期时间才会执行第二个任务</p><pre class=" language-java"><code class="language-java">scheduledThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是scheduleWithFixedDelay调度1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>scheduledThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是scheduleWithFixedDelay调度2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>scheduleAtFixedRate方法，延迟执行，周期执行，不等待前一个任务执行完，就开始计算周期时间；第一个参数：任务，第二个参数：初始化延时时间，第三个参数是周期时间，第四个参数时间单位</p><p>下面这段代码就是先执行第一个任务，任务已执行不管你执行完没完我就计算周期时间</p><pre class=" language-java"><code class="language-java">scheduledThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是scheduleAtFixedRate调度1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>scheduledThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是scheduleAtFixedRate调度2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><p>下面看下源码是怎么实现的这几种提交方式</p><h3 id="对比三种提交方式"><a href="#对比三种提交方式" class="headerlink" title="对比三种提交方式"></a>对比三种提交方式</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 提交方式</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> ScheduledFuture<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> <span class="token function">schedule</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> callable<span class="token punctuation">,</span>                                           <span class="token keyword">long</span> delay<span class="token punctuation">,</span>                                           TimeUnit unit<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>callable <span class="token operator">==</span> null <span class="token operator">||</span> unit <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里decorateTask点进去一看就发现是一个空方法，不管它只是一个封装任务而已</span>    <span class="token comment" spellcheck="true">// triggerTime算出初始化执行时间now()+initDeley &lt; 0 ? 0 : initDelay</span>    RunnableScheduledFuture<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> t <span class="token operator">=</span> <span class="token function">decorateTask</span><span class="token punctuation">(</span>callable<span class="token punctuation">,</span>                                                <span class="token keyword">new</span> <span class="token class-name">ScheduledFutureTask</span><span class="token operator">&lt;</span>V<span class="token operator">&gt;</span><span class="token punctuation">(</span>callable<span class="token punctuation">,</span>                                                                           <span class="token function">triggerTime</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里是提交任务的方法</span>    <span class="token function">delayedExecute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// scheduleAtFixedRate提交方法</span><span class="token keyword">public</span> ScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> <span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">,</span>                                                  <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span>                                                  <span class="token keyword">long</span> period<span class="token punctuation">,</span>                                                  TimeUnit unit<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null <span class="token operator">||</span> unit <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>period <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 封装任务</span>    ScheduledFutureTask<span class="token operator">&lt;</span>Void<span class="token operator">&gt;</span> sft <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">ScheduledFutureTask</span><span class="token operator">&lt;</span>Void<span class="token operator">&gt;</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span>                                      null<span class="token punctuation">,</span>                                      <span class="token function">triggerTime</span><span class="token punctuation">(</span>initialDelay<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">,</span>                                      unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>period<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RunnableScheduledFuture<span class="token operator">&lt;</span>Void<span class="token operator">&gt;</span> t <span class="token operator">=</span> <span class="token function">decorateTask</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> sft<span class="token punctuation">)</span><span class="token punctuation">;</span>    sft<span class="token punctuation">.</span>outerTask <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里是提交任务的方法</span>    <span class="token function">delayedExecute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// scheduleWithFixedDelay提交方法</span><span class="token keyword">public</span> ScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> <span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">,</span>                                                     <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span>                                                     <span class="token keyword">long</span> delay<span class="token punctuation">,</span>                                                     TimeUnit unit<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null <span class="token operator">||</span> unit <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 封装任务</span>    ScheduledFutureTask<span class="token operator">&lt;</span>Void<span class="token operator">&gt;</span> sft <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">ScheduledFutureTask</span><span class="token operator">&lt;</span>Void<span class="token operator">&gt;</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span>                                      null<span class="token punctuation">,</span>                                      <span class="token function">triggerTime</span><span class="token punctuation">(</span>initialDelay<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">,</span>                                      unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span><span class="token operator">-</span>delay<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RunnableScheduledFuture<span class="token operator">&lt;</span>Void<span class="token operator">&gt;</span> t <span class="token operator">=</span> <span class="token function">decorateTask</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> sft<span class="token punctuation">)</span><span class="token punctuation">;</span>    sft<span class="token punctuation">.</span>outerTask <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里是提交任务的方法</span>    <span class="token function">delayedExecute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>我们对比一下scheduleAtFixedRate和scheduleWithFixedDelay这2个方法基本没什么区别。仔细对比发现他们之间除了参数名字不一致以外，还有一个很关键的区别在封装ScheduledFutureTask任务时，scheduleAtFixedRate传的是unit.toNanos(period)，而scheduleWithFixedDelay传的是unit.toNanos(-delay)，一个是正数一个是负数，其余就没区别了。这里的具体原因在后面修改周期时间那里会有介绍。</p><h3 id="delayedExecute方法"><a href="#delayedExecute方法" class="headerlink" title="delayedExecute方法"></a>delayedExecute方法</h3><p>delayedExecute是提交任务的方法，任务封装成ScheduledFutureTask，就要把这个任务放进任务队列里面去了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">delayedExecute</span><span class="token punctuation">(</span>RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> task<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断是否是shutdown状态，是的话不在处理新任务走拒绝策略</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 是运行状态将任务放进队列里面去</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// task.isPeriodic()从构造方法可以看出周期任务period != 0,延迟任务是=0</span>        <span class="token comment" spellcheck="true">// isPeriodic方法只是通过period != 0 是true否则是false</span>        <span class="token comment" spellcheck="true">// canRunInCurrentRunState 获取了当前是周期任务还是延迟任务。</span>        <span class="token comment" spellcheck="true">// 分析出continueExistingPeriodicTasksAfterShutdown是周期任务</span>        <span class="token comment" spellcheck="true">// 分析出executeExistingDelayedTasksAfterShutdown是延迟任务</span>        <span class="token comment" spellcheck="true">// 判断线程池的状态，和当前任务是否能运行。如果不能继续执行，将任务移出队列并取消任务。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span><span class="token function">canRunInCurrentRunState</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">isPeriodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>            task<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment" spellcheck="true">// 这里就是增加线程去处理任务，从这也可以看出它和线程池的区别，</span>            <span class="token comment" spellcheck="true">// 刚创建任务的时候不会创建把线程和任务绑定</span>            <span class="token function">ensurePrestart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ensurePrestart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取当前活跃线程数</span>    <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果活跃线程数小于核心线程数就创建线程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span>        <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取当前活跃线程数是0而且也不小于核心线程数，说明你此时设定的核心线程数是0，小于0会报错</span>    <span class="token comment" spellcheck="true">// 主要就是为了兼容线程池可以创建核心线程数为0</span>    <span class="token comment" spellcheck="true">// 这里是为了避免有任务但没线程执行的尴尬</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="SchduledFutureTask的run方法"><a href="#SchduledFutureTask的run方法" class="headerlink" title="SchduledFutureTask的run方法"></a>SchduledFutureTask的run方法</h3><p>真正执行任务的方法</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// task.isPeriodic()从构造方法可以看出周期任务period != 0,延迟任务是=0</span>     <span class="token comment" spellcheck="true">// isPeriodic方法只是通过period != 0 是true否则是false</span>     <span class="token comment" spellcheck="true">// true代表是周期任务 false代表是延迟任务</span>     <span class="token keyword">boolean</span> periodic <span class="token operator">=</span> <span class="token function">isPeriodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 判断是否可以运行，不可以cancel掉任务</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">canRunInCurrentRunState</span><span class="token punctuation">(</span>periodic<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 延迟任务</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>periodic<span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">// 直接调用一次</span>         ScheduledFutureTask<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 此时它一定是周期任务runAndReset运行不返回结果</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ScheduledFutureTask<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">runAndReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 设值下一次执行时间</span>         <span class="token function">setNextRunTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 重新入队</span>         <span class="token function">reExecutePeriodic</span><span class="token punctuation">(</span>outerTask<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setNextRunTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> p <span class="token operator">=</span> period<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 此时就是前面2种周期任务提交方式的区别所导致的，还记得前面如果是</span>    <span class="token comment" spellcheck="true">// scheduleAtFixedRate提交方式period是正数；scheduleWithFixedDelay提交方式period是负数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 执行线程时间加周期时间</span>        time <span class="token operator">+=</span> p<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment" spellcheck="true">// 现在时间加周期时间</span>        time <span class="token operator">=</span> <span class="token function">triggerTime</span><span class="token punctuation">(</span><span class="token operator">-</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h3><p>DelayedWorkQueue是优先级队列，ScheduledThreadPoolExecutor它所使用的队列就是DelayedWorkQueue。之所以使用DelayedWorkQueue，是因为定时任务执行，总要取出最近要执行的任务，所以一定要取队列中最靠前的任务。</p><p>他是一个堆结构，底层是数组；它不能保证所有的元素一定是顺序的，但能保证你从堆顶拿到的元素一定是所有里面最大或最小的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务系统解析</title>
      <link href="/mysql-shi-wu-xi-tong-jie-xi/"/>
      <url>/mysql-shi-wu-xi-tong-jie-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近啃MySQL相关的知识，了解到事务以及事务隔离机制，想要深入了解下事务是如何实现的下面是此次主要探讨的几点方向。这里先推荐几篇文章</p><p><a href="http://mysql.taobao.org/monthly/2017/12">数据库内核月报 － 2017 / 12</a></p><p><a href="http://mysql.taobao.org/monthly/2017/10">数据库内核月报 － 2017 / 10</a></p><p><a href="http://mysql.taobao.org/monthly/2015/04">数据库内核月报 － 2015 / 04</a></p><ol><li>事务及其ACID特性</li><li>并发事务带来的问题</li><li>事务隔离机制以及解决并发事务问题</li><li>事务隔离机制如何实现（MVCC多版本并发控制机制）</li></ol><h2 id="事务及其ACID特性"><a href="#事务及其ACID特性" class="headerlink" title="事务及其ACID特性"></a>事务及其ACID特性</h2><p>事务一般具有4个特性，这4个特性一般简称ACID特性</p><ul><li>A（原子性）：事务要么全部成功，要么全部失败</li><li>C（一致性）：不管什么时候，数据都是一致的，不会读到中间状态的数据</li><li>I（隔离性）：多个事务之间相互不影响</li><li>D（持久性）：在事务执行过程中，不管怎么样数据都不能丢，MySQL是使用了redo log实现的。</li></ul><h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p>并发事务带来了更新丢失，脏读，不可重读，幻读4种问题</p><ul><li>更新丢失：当多个事务同时执行一行数据时，第一个事务已经对行做了修改但第二个事务不知道就把第一个事务更新的数据给修改了，出现了更新丢失的情况。<strong>当前事务的更新覆盖了其他事务的更新</strong>。</li><li>脏读：第一个事务已经做了写操作，但此时并没有提交事务，然后第二个事务读取到了这条数据，也就是第二条数据读取到了脏数据，这就是所谓的脏读。<strong>当前事务读取了其他事务的已经修改但未提交的数据</strong>。</li><li>不可重读：一个事务开始查询了某个语句，第二次执行同样的语句发现查询的东西不一样了。<strong>当前事务在不同时刻执行同样的查询语句，查询出的结果不一样</strong></li><li>幻读：一个事务按相同的查询条件查询读取已经检索过的数据，却发现其他事务插入了满足条件的数据。<strong>当前事务读取到了其他事务插入的数据</strong></li></ul><h2 id="事务隔离机制"><a href="#事务隔离机制" class="headerlink" title="事务隔离机制"></a>事务隔离机制</h2><p>事务隔离机制有4种，读未提交，读已提交，可重读，串行化</p><ul><li>RU(Read uncommitted)：读未提交</li><li>RC(Read committed)：读已提交</li><li>RR(Repeatable read)：重复读</li><li>SERIALIZABLE(Serializable)：串行化</li></ul><h3 id="隔离级别对并发事务的解决"><a href="#隔离级别对并发事务的解决" class="headerlink" title="隔离级别对并发事务的解决"></a>隔离级别对并发事务的解决</h3><table><thead><tr><th align="center"></th><th align="center">脏读</th><th align="center">不可重读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读未提交</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">读已提交</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">重复读</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">串行化</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><p>读已提交，重复读是通过MVCC机制解决的并发问题。串行化是通过对数据库加锁控制其他事务对数据的操作解决并发问题。<strong>事务隔离级别越高对并发的问题越小，但相应的付出的代价也会越大</strong>；串行化肯定是并发影响最小的，当你访问某个数据时串行化直接来个行锁或表锁，其他的数据只能阻塞在后面等这边的数据处理完成后才可以进行访问。串行化对数据库性能影响太大所以<strong>MySQL综合考虑默认使用的是重复读隔离级别</strong>。</p><h2 id="MVCC多版本并发控制机制"><a href="#MVCC多版本并发控制机制" class="headerlink" title="MVCC多版本并发控制机制"></a>MVCC多版本并发控制机制</h2><p>MVCC（Multi-Version Concurrency Control）：多版本并发控制机制，对一行数据的读写操作不通过加锁来保证隔离性，提高性能。MVCC不是MySQL所特有的在Oracle,PostgreSQL都有关于MVCC的实现，实现可能是不一样的。还有MVCC只在读已提交和重复度2个隔离级别下才干活。读未提交只读最新的数据（不管你事务提不提交）它不需要任何锁，串行化直接搞把锁，所以也不需要MVCC来控制。</p><p>在介绍MVCC机制前先介绍2个概念，undo log和read view</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log是日志版本链，当我们对记录做了变更操作就会产生一条undo记录，undo记录主要在每条数据后面加2个隐藏字段DATA_TRX_ID，DATA_ROLL_PTR其实应该是3个，如果表没有主键还会生成一个DB_ROW_ID。<a href="http://www.searchdoc.cn/rdbms/mysql/dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.com.coder114.cn.html">InnoDB多版本控制</a></p><ul><li>DATA_TRX_ID：事务编号，6字节，记录更新这条行记录的事务编号</li><li>DATA_ROLL_PTR：回滚指针，7字节，记录</li><li>DB_ROW_ID：主键编号，6字节，没有主键会自动生成</li></ul><p>事务id的生成是在对innodb进行了写操作而生成的。在InnoDB看来所有的事务在启动时候都是只读状态是只读事务此时不会生成事务编号。<a href="http://mysql.taobao.org/monthly/2017/12">数据库内核月报 － 2017 / 12</a></p><p>undo log记录过程：首先表里有一个数据，伴随着隐藏字段DATA_TRX_ID，DATA_ROLL_PTR，然后有一个事务100对其进行了修改，这时候我们会把原先的数据copy一份到undo log中去，然后把修改后的数据也放进undo log,但这条数据的DATA_TRX_ID = 100，DATA_ROLL_PTR指向原来的数据。如果这时候又来了一个事务200，此时事务100还没提交，事务200又进行了一次更新会把新数据写进undo log并且DATA_TRX_ID = 200，DATA_ROLL_PTR指向事务100的那条数据。</p><p><img src="https://i.loli.net/2020/09/03/k1JtNnVGyXmRc2I.png" alt="日志版本链生成过程"></p><p>最后在undo log中的日志版本链就是</p><p><img src="https://i.loli.net/2020/09/03/rExVXKv4Gp5olIH.png" alt="日志版本链"></p><h3 id="read-view（快照）"><a href="#read-view（快照）" class="headerlink" title="read view（快照）"></a>read view（快照）</h3><p>read view在MVCC里面主要做的就是可见性判断，read view 的生成时机就是RR,RC两种隔离级别的主要区别</p><ul><li>RR隔离级别，只要是开启事务后的第一次select查询操作便会生成一次read view,后面便不再维护read view了</li><li>RC隔离级别，开启事务后，只要进行了查询语句便会生成一次read view</li></ul><h3 id="read-view创建过程"><a href="#read-view创建过程" class="headerlink" title="read view创建过程"></a>read view创建过程</h3><ol><li>首先看当前所有未提交的事务，存储在数组中<strong>trx_ids</strong></li><li>选取未提交事务的最小的事务编号为<strong>up_limit_id</strong>,</li><li>选取已提交事务的最大的事务编号加1为<strong>low_limit_id</strong></li></ol><p>1）trx_id&lt;up_limit_id；小于最小未提交事务肯定是已提交事务，可见<br>2）trx_id&gt;low_limit_id；大于最大已提交事务肯定是后面创建的事务，不可见<br>3）up_limit_id&lt;=trx_id&lt;=low_limit_id；分2种情况</p><ul><li>trx_id在trx_ids中说明是未提交事务，不可见</li><li>trx_id不在trx_ids中说明是已提交事务，可见</li></ul><p>MVCC如何利用日志版本链来进行查询的？</p><p>根据图第二次查询结果还是hello,但此时undo log日志版本链最新的是hello2，这里主要走的过程是，看undolog日志版本链从最新往下看，最新是事务1，发现事务1在已提交事务和未提交事务区间内而且是在trx_ids中，说明是不可见的，所以继续undolog日志版本链往下看。发现是事务3，发现事务3在已提交事务&amp;未提交事务区间而且不再trx_id中所以是可见的。</p><p>​    <img src="https://i.loli.net/2020/09/03/YuX6dImOpJKa4zW.png" alt="MVCC"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
