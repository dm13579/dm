<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis生产实践与性能优化</title>
      <link href="2021/02/05/redis-sheng-chan-shi-jian-yu-xing-neng-you-hua/"/>
      <url>2021/02/05/redis-sheng-chan-shi-jian-yu-xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指访问一个不存在的key（这个key不在缓存层），穿透了缓存层直接打到了DB，如果访问量大的话是有把DB打崩的可能性。</p><p>解决方案：</p><ol><li><p>缓存空对象，即使访问的是一个不存在的对象，我们也可以吧访问的key值缓存，value直接设个字符串便可，再次访问的时候判断一下就行了</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> String <span class="token function">cachePenetrate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> String id<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 查下缓存有没有数据,有直接返回</span>     String cache <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 没有缓存</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 从DB拿</span>         String value <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>         value <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 拿完数据缓存,DB没有数据缓存空串</span>         stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 设置一个过期时间</span>         stringRedisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> value<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> cache<span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre></li><li><p>布隆过滤器</p><p>对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，可以用布隆过滤器先做一次过滤，对于不存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。当布隆过滤器说<strong>某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。</strong></p><p>添加：</p><p>向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。</p><p>查询：</p><p>向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位置是否都为 1，只要有一个位为 0，那么说明布隆过滤器中这个key 不存在。如果都是 1，这并不能说明这个 key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。</p><p>场景：</p><p>这种方法适用于数据命中不高、 数据相对固定、 实时性低（通常是数据集较大） 的应用场景， 代码维护较为复杂， 但是<strong>缓存空间占用很少</strong>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>redisson<span class="token punctuation">.</span>Redisson<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>redisson<span class="token punctuation">.</span>api<span class="token punctuation">.</span>RBloomFilter<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>InitializingBean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BloomFilter</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> Redisson redisson<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        RBloomFilter<span class="token operator">&lt;</span>String<span class="token operator">></span> bloomFilter <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getBloomFilter</span><span class="token punctuation">(</span><span class="token string">"idList"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化布隆过滤器：预计元素为100000000L,误差率为3%</span>        bloomFilter<span class="token punctuation">.</span><span class="token function">tryInit</span><span class="token punctuation">(</span>100000000L<span class="token punctuation">,</span><span class="token number">0.03</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            bloomFilter<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> String <span class="token function">cachePenetrate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> String id<span class="token punctuation">)</span> <span class="token punctuation">{</span>     RBloomFilter<span class="token operator">&lt;</span>String<span class="token operator">></span> bloomFilter <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getBloomFilter</span><span class="token punctuation">(</span><span class="token string">"idList"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">boolean</span> exists <span class="token operator">=</span> bloomFilter<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>exists<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 查下缓存有没有数据,有直接返回</span>     String cache <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 没有缓存</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 从DB拿</span>         String value <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//            value = db.get(id);</span>         <span class="token comment" spellcheck="true">// 拿完数据缓存,DB没有数据缓存空串</span>         stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 设置一个过期时间(60到120)</span>         stringRedisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">60</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> value<span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> cache<span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre></li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>大批量缓存同一时间失效，请求全部打到DB层，可能会造成数据库瞬间压力过大甚至挂掉，对于这种情况我们在批量增加缓存时最好将这一批数据的缓存过期时间设置为一个时间段内的不同时间。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">cachePenetrate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> String id<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 查下缓存有没有数据,有直接返回</span>     String cache <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 没有缓存</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 从DB拿</span>         String value <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>         value <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 拿完数据缓存,DB没有数据缓存空串</span>         stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 设置一个过期时间(60到120)</span>         stringRedisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span>  <span class="token operator">+</span> <span class="token number">60</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> value<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> cache<span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指缓存层扛不住压力崩溃了，流量直接打到了后端数据层。存储层也会级联宕机。</p><ol><li>保证缓存层服务高可用，用哨兵架构或集群架构。</li><li>做限流熔断。Sentinel或Hystrix。</li></ol><h2 id="热点数据"><a href="#热点数据" class="headerlink" title="热点数据"></a>热点数据</h2><p>有时候会有一些热点数据，原本不在缓存的，突然间大批量数据打过来，还没来得及建立缓存，流量就打到了DB,瞬间DB宕机。</p><p>我们可以利用互斥锁来解决，此方法只允许一个线程重建缓存， 其他线程等待重建缓存的线程执行完， 重新从缓存获取数据即可。</p><h2 id="缓存与数据库双写不一致"><a href="#缓存与数据库双写不一致" class="headerlink" title="缓存与数据库双写不一致"></a>缓存与数据库双写不一致</h2><p>不管你是读库更新缓存，读库删除缓存在高并发下都会存在数据不一致问题</p><ol><li>延时双删：读库删除缓存后过一段时间在删一次，防止别的线程更新掉了缓存。<strong>不建议，为了解决一个偶发事件拖慢了整个系统</strong></li><li>canal：利用canal监听MySQL的binLog通过MQ解决。</li><li>加读写锁：保证顺序，串行化执行。</li></ol><p>如果能容忍短暂的数据不一致，可以加过期时间解决。</p><h2 id="客户端连接池"><a href="#客户端连接池" class="headerlink" title="客户端连接池"></a>客户端连接池</h2><h3 id="客户端建议"><a href="#客户端建议" class="headerlink" title="客户端建议"></a>客户端建议</h3><ol><li><p>Redis使用上应避免多个应用使用同一个Redis，大规模互联网产品建议一个服务对应一个Redis，提高性能和存储。</p></li><li><p><strong>Redis多库不建议使用,集群默认不支持多库</strong></p></li><li><p>Redis客户端建议使用带有连接池的客户端。</p></li></ol><p>池化思想：所有的池化思想主要基于2方面，其一方便统一管理，其二不随便创建和销毁连接，连接的创建和销毁都会消耗资源，我使用完连接，丢回池中，后面再拿出来。</p><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th>参数</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>maxTotal</td><td>8</td><td>连接池最大连接数</td></tr><tr><td>maxIdle</td><td>8</td><td>空闲最大连接数</td></tr><tr><td>minIdle</td><td>0</td><td>空闲最小连接数</td></tr><tr><td>blockWhenExhausted</td><td>true</td><td>连接池用尽时是否需要等待，为true配合maxWaitMillis（不建议使用默认值）</td></tr><tr><td>maxWaitMillis</td><td>-1(不超时)</td><td>连接池用尽后调用者最大等待时间</td></tr><tr><td>testOnBorrow</td><td>false</td><td>连接池使用连接时做一次有效性校验（ping一下通不通）无效连接会被移除，连接多不建议开启</td></tr><tr><td>testOnReturn</td><td>false</td><td>客户端归还连接时做一次有效性校验（ping一下通不通）无效连接会被移除，连接多不建议开启</td></tr><tr><td>jmxEnabled</td><td>true</td><td>是否开启jmx监控，可用于监控</td></tr></tbody></table><h3 id="连接池预热"><a href="#连接池预热" class="headerlink" title="连接池预热"></a>连接池预热</h3><p>有时我们服务启动时需要处理大量的Redis请求，为了提高性能可以先连接池预热，将连接池中的连接提升到maxIdle数量</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Jedis<span class="token operator">></span> minIdleJedisList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Jedis<span class="token operator">></span><span class="token punctuation">(</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">getMinIdle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> jedisPoolConfig<span class="token punctuation">.</span><span class="token function">getMinIdle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Jedis jedis <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        jedis <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        minIdleJedisList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>jedis<span class="token punctuation">)</span><span class="token punctuation">;</span>        jedis<span class="token punctuation">.</span><span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 注意，这里不能马上close将连接还回连接池，否则最后连接池里只会建立1个连接</span>        <span class="token comment" spellcheck="true">// jedis.close();</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 统一将预热的连接还回连接池</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> jedisPoolConfig<span class="token punctuation">.</span><span class="token function">getMinIdle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Jedis jedis <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        jedis <span class="token operator">=</span> minIdleJedisList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将连接归还回连接池</span>        jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Redis清除策略"><a href="#Redis清除策略" class="headerlink" title="Redis清除策略"></a>Redis清除策略</h2><h3 id="被动删除"><a href="#被动删除" class="headerlink" title="被动删除"></a>被动删除</h3><p>Redis是惰性删除的，key过期了Redis是不会主动删除的（需看策略），是在key被查询一次的时候判断一下有没有过期，过期直接删除。</p><h3 id="主动删除"><a href="#主动删除" class="headerlink" title="主动删除"></a>主动删除</h3><p>由于惰性删除策略无法保证冷数据被及时删掉，所以redis需要清理掉，主要以下2种策略</p><ol><li>定期清理：Redis会定期主动淘汰一批<strong>已过期</strong>的key</li><li>当前已用内存超过maxmemory限定时（配合maxmemory-policy配置）</li></ol><p>8种数据淘汰策略</p><ul><li>volatile-ttl：筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除</li><li>volatile-random：筛选时，会针对设置了过期时间的键值对，随机删除</li><li>volatile-lru：筛选时，会针对设置了过期时间的键值对，会使用 LRU 算法筛选设置了过期时间的键值对删除</li><li>volatile-lfu：筛选时，会针对设置了过期时间的键值对，会使用 LFU 算法筛选设置了过期时间的键值对删除</li><li>allkeys-random：从所有键值对中随机选择删除（不管设没设过期时间）</li><li>allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除（不管设没设过期时间）</li><li>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除（不管设没设过期时间）</li><li>noeviction：默认，不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作</li></ul><p>淘汰算法</p><ul><li><strong>LRU 算法</strong>（Least Recently Used，最近最少使用）：淘汰很久没被访问过的数据，以<strong>最近一次访问时间</strong>作为参考</li><li><strong>LFU 算法</strong>（Least Frequently Used，最不经常使用）：淘汰最近一段时间被访问次数最少的数据，以<strong>次数</strong>作为参考。</li></ul><p><strong>推荐使用volatile-lru。如果不设置最大内存，当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)，会让 Redis 的性能急剧下降。</strong></p><h2 id="Redis使用建议"><a href="#Redis使用建议" class="headerlink" title="Redis使用建议"></a>Redis使用建议</h2><ol><li><p>避免使用大key，阻塞Redis</p></li><li><p>禁用耗时操作，阻塞Redis</p><p>hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。</p><p>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理</p></li><li><p>使用批量操作降低网络开销，比如管道操作等等，但不建议一次传输太大的数据</p></li><li><p>Redis事务功能尽量不使用，可以使用lua脚本解决原子性问题</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 生产实践 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis核心原理与Redis6新特性</title>
      <link href="2021/02/01/redis-he-xin-yuan-li/"/>
      <url>2021/02/01/redis-he-xin-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis持久化共有3种模式RDB、AOF和Redis4.0之后出来的混合持久化。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB持久化是Redis的默认选择。RDB模式中Redis将持久化文件存储在dump.rdb（配置）<strong>二进制文件</strong>中。可以对Redis进行设置，在N秒内数据集至少有M次改动，自动保存一次数据集（配置save）;关闭RDB模式只需将所有save策略注释掉即可。</p><p>还可以手动执行命令生成RDB快照，进入Redis客户端执行命令save或bgsave可以生成dump.rdb文件；每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件</p><h4 id="bgsave-Copy-On-Write"><a href="#bgsave-Copy-On-Write" class="headerlink" title="bgsave(Copy-On-Write)"></a>bgsave(Copy-On-Write)</h4><p>默认生成方式bgsave；bgsave运用了写时复制技术(Copy-On-Write)，简单来说redis在生成快照文件的时候Redis还能做写入操作。具体实现是，主线程会fork一个bgsave的子进程，bgsave子进程会读取主线程中的内存数据并把他们写入快照文件中，这时候如果Redis发生了写数据，这时候修改的数据会被写成一个副本，然后bgsave会把副本数据写入快照文件，如果发生的是读数据，就不用管。</p><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>save就是直接对Redis进行阻塞，不允许任何写数据请求，然后生成快照</p><table><thead><tr><th></th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>是否阻塞redis其它命令</td><td>阻塞</td><td>非阻塞</td></tr><tr><td>IO</td><td>同步</td><td>异步</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fork子进程，消耗内存</td></tr></tbody></table><h4 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h4><pre class=" language-shell"><code class="language-shell">## RDB 文件dbfilename "dump.rdb"## 持久化目录dir "/data/redis"## &nbsp;60&nbsp;秒内有至少有&nbsp;10000&nbsp;个键被改动 执行一次bgsavesave 60 10000</code></pre><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210127151428.png"></p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>RDB模式从机制也可以看出丢数据的可能性极大。如果Redis停机就会导致没有写到快照文件的数据丢失。后面Redis增加了一种AOF持久化方案。它存储的是每一条指令而不是二进制文件；存储文件是appendonly.aof;</p><h4 id="aof文件存储结构"><a href="#aof文件存储结构" class="headerlink" title="aof文件存储结构"></a>aof文件存储结构</h4><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210127151458.png"></p><p>这是一种resp协议格式数据，星号后面的数字代表命令有多少个参数，$号后面的数字代表这个参数有几个字符</p><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>AOF文件里可能有太多没用指令，所以AOF会定期根据内存的最新数据生成aof文件比如set a 1;set a 2;set a 3;会重写成set a 3</p><p>AOF还可以手动重写，进入redis客户端执行命令<strong>bgrewriteaof</strong>重写AOF</p><p><strong>AOF重写redis会fork出一个子进程去做(与bgsave命令类似)，不会对redis正常命令处理有太多影响</strong></p><h4 id="相关配置-1"><a href="#相关配置-1" class="headerlink" title="相关配置"></a>相关配置</h4><pre class=" language-shell"><code class="language-shell">## aof文件名称appendfilename "appendonly.aof"## 持久化目录dir "/data/redis"## 开启aof持久化appendonly yes## 每次有新命令追加到 AOF 文件时就执行一次&nbsp;fsync&nbsp;，非常慢，也非常安全appendfsync always## 每秒fsync一次，足够快，并且在故障时只会丢失 1 秒钟的数据appendfsync everysec## 从不fsync，将数据交给操作系统来处理。更快，也更不安全的选择appendfsync no## AOF重写相关配置## aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大auto-aof-rewrite-min-size 64mb## aof文件自上一次重写后文件大小增长了100%则再次触发重写auto-aof-rewrite-percentage 100 </code></pre><p>RDB,AOF对比</p><table><thead><tr><th></th><th><strong>RDB</strong></th><th><strong>AOF</strong></th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>容易丢数据</td><td>策略决定</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr></tbody></table><p>生产环境可以都启用，redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof一般来说数据更全一点。</p><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>混合持久化是Redsis4.0之后引入的。生产环境我们一般会利用AOF来恢复数据，即使RDB恢复数据更快但它不安全，会丢失数据。但AOF有一个致命的缺点就是恢复速度慢。混合持久化就是解决这个问题。</p><p>混合持久化是AOF的升级版，让AOF有了RDB的优点；</p><p>在执行AOF重写时，不在是将Resp协议简单的转化了，而是将这一刻之前的内存数据转化为RDB二进制文件，并且将RDB快照内容和<strong>增量的</strong>AOF修改内存数据的命令存在一起都写入新的AOF文件，新的文件一开始不叫appendonly.aof；等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换.</p><p>于是aof文件不仅仅是存储的Resp协议，而是Resp和二进制文件。</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210127163459.png"></p><h4 id="相关配置-2"><a href="#相关配置-2" class="headerlink" title="相关配置"></a>相关配置</h4><p>开启混合持久化必须先启动AOF</p><pre class=" language-shell"><code class="language-shell">## 开启混合持久化aof-use-rdb-preamble yes   </code></pre><h3 id="Redis数据备份策略"><a href="#Redis数据备份策略" class="headerlink" title="Redis数据备份策略"></a>Redis数据备份策略</h3><ol><li>写crontab定时调度脚本，每小时都copy一份rdb或aof的备份到一个目录中去，仅仅保留最近48小时的备份</li><li>每天都保留一份当日的数据备份到一个目录中去，可以保留最近1个月的备份</li><li>每次copy备份的时候，都把太旧的备份给删了</li><li>每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏</li></ol><h3 id="Redis数据恢复"><a href="#Redis数据恢复" class="headerlink" title="Redis数据恢复"></a>Redis数据恢复</h3><p>将之前备份的rdb或aof文件copy到当前redis配置下的.dir目录，数据自动恢复</p><h2 id="Redis高性能"><a href="#Redis高性能" class="headerlink" title="Redis高性能"></a>Redis高性能</h2><p>大家都知道Redis是单线程的，但单线程为什么Redis性能这么高？</p><p>首先Redis单线程只是从网络IO和读写操作是单线程的。但Redis的持久化，AOF重写，集群数据同步这些都是另外的线程操作的。</p><p>Redis性能高主要有以下几个原因</p><ol><li>所有数据都是在内存操作的，内存运算速度不必多说。</li><li>单线程避免了线程上下文切换，其实多线程并不一定比单线程块，线程太多了上下文切换太频繁性能可能还比不上单线程</li></ol><h3 id="Redis的IO多路复用"><a href="#Redis的IO多路复用" class="headerlink" title="Redis的IO多路复用"></a>Redis的IO多路复用</h3><p>Redis怎么处理大量客户端的连接？</p><p>当大量的客户端连接连接Redis,Redis利用epoll实现多路复用，将连接信息放入队列，然后取队列中的连接，分发给不同的处理器。大概原理类似于NIO</p><p><strong>注意：Redis是单线程就需要避免耗时操作，和存储大key，避免阻塞线程，像类似于一般keys这种命令要禁止使用</strong></p><p><strong>线上生产QPS一般比较高，执行耗时操作会阻塞住redis,大量连接请求Redis会Hang住，导致线上CPU剧增，导致服务器宕机，服务器宕机Redis不能请求导致请求打到DB,最后数据库宕机</strong></p><p>如果真要用keys 可以改成scan</p><p>禁用命令(重定义命令)</p><p>redis.conf</p><pre class=" language-shell"><code class="language-shell">rename-command KEYS ""</code></pre><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>Redis主从架构一般只是用于备份数据，做的更多的就是通过程序实现读写分离（Redis自身不支持，需实现）；Redis的主从架构不支持高可用，也就是主节点宕机从节点不会顶上去，一般生产不会单纯的使用主从架构，要么哨兵或集群架构</p><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><ol><li>当一个slave节点启动时会向master节点发送一个psync命令</li><li>master收到命令就开始持久化数据生产dumb.rdb文件（这里不管他是否开启或关闭rdb持久化）</li><li>持久化过程中，redis会继续接受请求，这些修改的数据缓存在内存</li><li>持久化完毕后会将rdb数据发给slave,slave收到数据会持久化数据，然后加载到内存，然后master将之前缓存的数据发给slave</li><li>后面master与slave建立长连接同步数据，保持数据一致</li></ol><h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3><p>master与slave会在网络断开重连后进行部分复制</p><ol><li>master会在其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据</li><li>master和它所有的slave都维护了复制的数据下标offset和master进程id</li><li>网络连接断开后，slave会请求master继续进行未完成的复制，从所记录的数据下标开始。如果master进程id变化了，或者从节点数据下标offset太旧，已经不在master的缓存队列里了，那么将会进行一次全量数据的复制</li></ol><h3 id="主从复制风暴"><a href="#主从复制风暴" class="headerlink" title="主从复制风暴"></a>主从复制风暴</h3><p>主节点有多个slave节点，都同时发送psync命令给master导致主节点压力过大这就是主从复制风暴。</p><h2 id="Redis哨兵高可用架构"><a href="#Redis哨兵高可用架构" class="headerlink" title="Redis哨兵高可用架构"></a>Redis哨兵高可用架构</h2><p>哨兵架构其实就是对Redis主从的一次升级，redis主从架构有个缺陷就是不是高可用，哨兵架构可以解决这种问题</p><p>sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。</p><p>哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过sentinel代理访问redis的主节点，当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息)</p><h3 id="哨兵leader选举流程"><a href="#哨兵leader选举流程" class="headerlink" title="哨兵leader选举流程"></a>哨兵leader选举流程</h3><p>// TODO</p><h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><ol><li>哨兵集群会重新选举出新的redis主节点</li><li>客户端只需连接哨兵便可访问主从，主从的变化对客户端是不可见的</li></ol><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>哨兵架构虽然一定程度解决了Redis的可用性，但还是有一定的<strong>访问瞬断</strong>问题，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发，且单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210127183049.png"></p><h2 id="Redis高可用集群架构"><a href="#Redis高可用集群架构" class="headerlink" title="Redis高可用集群架构"></a>Redis高可用集群架构</h2><p>Redis3.0以后引入了集群功能，Redis高可用集群是由多个主从小集群组合而成是去中心的，可水平扩展，主要功能可以进行数据分片，主从小集群选举等功能。</p><h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>Redis集群将数据划分为16384个slots槽位。每个节点负责一部分槽位，槽位存储于每个节点中。客户端连接Redis集群时会将槽位分配情况缓存在客户端，方便客户端定位到目标节点。</p><p>槽位分配情况有时会和客户端缓存不一致，这时候就需要槽位校验调整。当客户端发到错误的数据节点的时候，服务端会向客户端发送一个跳转指令并带着正确的节点地址，客户端转向正确的目标节点发送数据命令并更新本地槽位缓存。</p><p>槽位定位算法：<strong>HASH_SLOT = CRC16(key) mod 16384</strong></p><h3 id="Redis集群节点间的通信机制"><a href="#Redis集群节点间的通信机制" class="headerlink" title="Redis集群节点间的通信机制"></a>Redis集群节点间的通信机制</h3><p>Redis集群节点间通过gossip协议进行通信。</p><p>gossip协议进行通信是断断续续的，所以所有元数据的更新不是及时的，缺点是所有节点跟新会有一定的延迟，优点是降低了节点压力。</p><ul><li>meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信</li><li>ping：每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据(类似自己感知到的集群节点增加和移除，hash slot信息等)</li><li>pong: 对ping和meet消息的返回，包含自己的状态和其他信息，也可以用于信息广播和更新</li><li>fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了</li></ul><h3 id="Redis集群选举原理"><a href="#Redis集群选举原理" class="headerlink" title="Redis集群选举原理"></a>Redis集群选举原理</h3><p>redis配置文件有一个这样的配置<strong>cluster-node-timeout</strong>，这个配置表示当某个节点timeout时间失联表示这个节点宕了，需要进行主从切换，<strong>注这个timeout不宜配置太小，否则会频繁进行主从切换</strong></p><p>选举过程：</p><ol><li>slave发现自己的master节点挂了，会发起选举，由于master的slave不仅只有一个slave此时就会开始选举</li><li>slave将自己的当前选举周期加1，并广播消息</li><li>其他小集群的master节点收到消息，会返回第一个发起请求的节点ack,注意这里在一个选举周期内只会发送一次ack</li><li>slave统计自己收到的ack是否超过整个redis大集群master个数的一半，超过一半选举为master</li><li>slave广播消息给其他所有节点我已经是master，你们不要选举了</li></ol><p>这里有个问题如果每个slave节点收到的ack个数是一样的，怎么办？</p><p>这时候slave会将自己的选举周期加1再来一次选举。Redis为了避免这个情况在slave发送请求给其他master的时候有个延时机制并不是立刻发送的，</p><p>延时时间*<em>DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms*</em></p><p>其中SLAVE_RANK表示此slave已经从master复制数据的总量的rank，rank越小数据越新延迟时间越短，选举为master几率更高。</p><h3 id="Redis集群对批量操作命令的支持"><a href="#Redis集群对批量操作命令的支持" class="headerlink" title="Redis集群对批量操作命令的支持"></a>Redis集群对批量操作命令的支持</h3><p>原来的单机节点所有的key都落在一个节点上批量命令没有问题，但现在是集群我们对于批量命令一些key不知道落在哪个节点上，就会出现问题，所以对于类似mset，mget这样的多个key的原生批量操作命令，redis集群只支持所有key落在同一slot的情况</p><p>如果有多个key一定要用mset命令在redis集群上操作，则可以在key的前面加上{XX}，这样参数数据分片hash计算的只会是大括号里的值，这样能确保不同的key能落到同一slot里去</p><p>示例如下：</p><pre class=" language-shell"><code class="language-shell">mset {user}:1:name dm {user}:1:age 18                 </code></pre><p>假设name和age计算的hash slot值不一样，但是这条命令在集群下执行，redis只会用大括号里的 user1 做hash slot计算，所以算出来的slot值肯定相同，最后都能落在同一slot。</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h4 id="Redis如何解决脑裂问题"><a href="#Redis如何解决脑裂问题" class="headerlink" title="Redis如何解决脑裂问题"></a>Redis如何解决脑裂问题</h4><p>在任何的主从架构不可避免的都会遇到脑裂问题。</p><p>Redis没有解决脑裂问题的，所以一定程度上是有脑裂导致的丢失数据的情况。</p><p>原因分析</p><p>现redis大集群小其中一个小集群（1主2从）主节点由于分区原因（网络抖动）导致slave认为master挂了（其实没挂），slave开始选举，成功选举了一个新master.现在这个小集群有2个master,数据也会写到这2个master中，当网络分区恢复原来的master变为slave，原来master写入的数据就丢失了。</p><p>解决方案</p><p>redis有个配置<strong>min-replicas-to-write 1</strong></p><p>配置表示写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如集群总共三个节点可以配置1，加上leader就是2，超过了半数</p><p>这样原来的问题就不会发生了，因为网络分区的原来的master节点不会再写入数据了。<strong>不过不建议这么用，因为redis本身最好用的就是高性能，现在这样性能必然不会太高，而且数据丢失对于缓存而言不算什么大不了再从DB去拿呗</strong></p><h4 id="集群是否完整才能对外提供服务"><a href="#集群是否完整才能对外提供服务" class="headerlink" title="集群是否完整才能对外提供服务"></a>集群是否完整才能对外提供服务</h4><p>这个问题主要看Redis配置</p><p>redis有个配置cluster-require-full-coverage为no时，表示当负责一个插槽的主库下线且没有相应的从库进行故障恢复时，集群仍然可用，如果为yes则集群不可用。</p><h4 id="Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数？"><a href="#Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数？" class="headerlink" title="Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数？"></a>Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数？</h4><p>因为新master的选举需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，当其中一个挂了，是达不到选举新master的条件的。</p><p>奇数个master节点可以在满足选举该条件的基础上节省一个节点，比如三个master节点和四个master节点的集群相比，大家如果都挂了一个master节点都能选举新master节点，如果都挂了两个master节点都没法选举新master节点了，所以奇数的master节点更多的是<strong>从节省机器资源角度出发</strong>说的</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis单机、主从、哨兵、高可用集群搭建和集群扩缩容</title>
      <link href="2021/01/29/redis-dan-ji-zhu-cong-shao-bing-gao-ke-yong-ji-qun-da-jian/"/>
      <url>2021/01/29/redis-dan-ji-zhu-cong-shao-bing-gao-ke-yong-ji-qun-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis单机搭建"><a href="#Redis单机搭建" class="headerlink" title="Redis单机搭建"></a>Redis单机搭建</h2><h3 id="Redis下载"><a href="#Redis下载" class="headerlink" title="Redis下载"></a>Redis下载</h3><p>这里使用的是redis5.0.3</p><p>Redis下载有多种方式，可以选择官网也可以选择镜像</p><ul><li>官网地址：<a href="https://redis.io/download">https://redis.io/download</a></li></ul><pre class=" language-shell"><code class="language-shell">## 下载wget http://download.redis.io/releases/redis-5.0.3.tar.gz## 解压tar -zxvf redis-5.0.3.tar.gz  -C /## 软链接ln -s /redis-5.0.3/ /redis</code></pre><h3 id="gcc编译"><a href="#gcc编译" class="headerlink" title="gcc编译"></a>gcc编译</h3><pre class=" language-shell"><code class="language-shell">## 安装gccyum install gcc## 进入到解压好的redis目录下，进行编译与安装cd /redismake</code></pre><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><pre class=" language-shell"><code class="language-shell">## 创建持久化目录mkdir /data/redis## 修改配置文件vim redis.conf</code></pre><p>配置文件</p><pre class=" language-shell"><code class="language-shell">#后台启动daemonize yes #关闭保护模式，开启的话，只有本机才可以访问redisprotected-mode no # 需要注释掉bind（bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可）#bind 127.0.0.1#修改持久化文件目录dir /data/redis/</code></pre><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre class=" language-shell"><code class="language-shell">## 启动src/redis-server redis.conf## 验证服务ps -ef | grep redis## 进入客户端src/redis-cli</code></pre><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><pre class=" language-shell"><code class="language-shell">## 退出客户端quit## 退出redis服务src/redis-cli shutdown</code></pre><h2 id="Redis-主从架构搭建"><a href="#Redis-主从架构搭建" class="headerlink" title="Redis 主从架构搭建"></a>Redis 主从架构搭建</h2><p>这里准备2台机器</p><p>主节点：192.168.186.131:6379</p><p>从节点：192.168.186.132:6379</p><p>主从节点搭建都和单机搭建基本一致，只需修改从节点配置即可</p><p>从节点所需修改配置</p><pre class=" language-shell"><code class="language-shell">## 配置主从复制# 从主节点的redis实例复制数据，主节点ip:端口replicaof 192.168.186.131:6379  replica-read-only yes  # 配置从节点只读</code></pre><p>主节点启动，从节点启动</p><p>验证</p><p>主节点写入一个key value;从节点能够同步数据就可以了</p><p>如果数据不能同步可能是防火墙问题关闭即可</p><h2 id="Redis-哨兵架构搭建"><a href="#Redis-哨兵架构搭建" class="headerlink" title="Redis 哨兵架构搭建"></a>Redis 哨兵架构搭建</h2><p>在主从架构中主节点挂了，从节点是不会顶上来的，从节点只是做了读写分离和数据备份</p><p>哨兵架构可以监测主节点变化情况和选举主节点的功能</p><p>客户端只需要连接哨兵便能访问redis,redis的主节点变化不会影响到客户端</p><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>这里搭建2个哨兵,1个主从redis</p><p>redis主节点：192.168.186.131:6379</p><p>redis从节点：192.168.186.132::6379</p><p>redis主从，上诉搭建方式</p><p>snetinel节点：</p><p>192.168.186.131:26379；192.168.186.132:26379</p><h3 id="修改配置-1"><a href="#修改配置-1" class="headerlink" title="修改配置"></a>修改配置</h3><pre class=" language-shell"><code class="language-shell">vim sentinel.conf</code></pre><p>配置文件</p><pre class=" language-shell"><code class="language-shell">daemonize yes## mymaster客户端连接时才有用，可随意修改，ip:port 是主节点ip:port,最后一个数字2表示2台sentinel认为主节点不可访问才是不可返回sentinel monitor mymaster 192.168.0.60 6379 2</code></pre><h3 id="启动sentinel"><a href="#启动sentinel" class="headerlink" title="启动sentinel"></a>启动sentinel</h3><pre class=" language-shell"><code class="language-shell">src/redis-sentinel sentinel.conf</code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><pre class=" language-shell"><code class="language-shell">src/redis-cli -p 26379info</code></pre><p>sentinel集群都启动完毕后，会将哨兵集群的元数据信息写入所有sentinel的配置文件里去</p><pre class=" language-shell"><code class="language-shell">#代表redis主节点的从节点信息sentinel known-replica mymaster 192.168.186.132 6379 #代表感知到的其它哨兵节点sentinel known-sentinel mymaster 192.168.186.131 26379 84bbfc7608019b020884e1cf045460916942e0f9</code></pre><p>当redis主节点如果挂了，哨兵集群会重新选举出新的redis主节点，同时会修改所有sentinel节点配置文件的集群元数据信息</p><pre class=" language-shell"><code class="language-shell">#代表redis主节点的从节点信息sentinel known-replica mymaster 192.168.186.131 6379 #代表感知到的其它哨兵节点sentinel known-sentinel mymaster 192.168.186.131 26379 84bbfc7608019b020884e1cf045460916942e0f9</code></pre><p>同时还会修改sentinel文件里之前配置的mymaster对应的主节点</p><pre class=" language-shell"><code class="language-shell">sentinel monitor mymaster 192.168.186.132 6379 2</code></pre><h2 id="Redis-集群架构搭建"><a href="#Redis-集群架构搭建" class="headerlink" title="Redis 集群架构搭建"></a>Redis 集群架构搭建</h2><p>redis的集群是由redis分配主从和槽位（当然也可以命令手动指定主从），这里我们只需要正常启动6个配置好的redis实例就可以了</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>三台机器，ip分别为192.168.186.131；192.168.186.132；192.168.186.133</p><p>每台机器搭建2个redis 服务，端口6001,6002,6003,6004,6005,6006</p><pre class=" language-shell"><code class="language-shell"># 每台机器首先创建一个redis-cluster文件夹方便管理mkdir /redis/redis-clustercd /redis/redis-cluster# 然后在别创建2个文件夾放不同端口文件mkdir 6001 6004# 把之前的redis.conf配置文件copy到6001cp /redis/redis.conf /redis/redis-cluster/6001</code></pre><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><pre class=" language-shell"><code class="language-shell">## 后台启动daemonize yes## 端口（分别对每个机器的端口号进行设置）port 6001## 把pid进程号写入pidfile配置的文件pidfile /var/run/redis_6001.pid  ## 指定数据文件存放位置，必须要指定不同的目录位置，不然会丢失数据dir /redis/redis-cluster/6001/## 启动集群模式cluster-enabled yes## 集群节点信息文件，这里600x最好和port对应上cluster-config-file nodes-6001.conf（集群节点信息文件，这里800x最好和port对应上）cluster-node-timeout 15000## 需要注释掉bind（bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可）# bind 127.0.0.1## 关闭保护模式protected-mode  no</code></pre><p>把修改后的配置文件,copy到6004,修改有端口号的配置项</p><p>批量替换命令</p><pre class=" language-shell"><code class="language-shell">:%s/源字符串/目的字符串/g </code></pre><p> 另外两台机器也需要做上面几步操作，第二台机器用6002和6005，第三台机器用6003和6006               </p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动6个redis实例，然后检查是否启动成功，这时候集群还未创建</p><pre class=" language-shell"><code class="language-shell">## 启动服务/redis/src/redis-server /redis/redis-cluster/600X/redis.conf## 检查6个redis实例是否都启动ps -ef | grep redis</code></pre><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>执行这条命令需要确认三台机器之间的redis实例要能相互访问，可以先简单把所有机器防火墙关掉，如果不关闭防火墙则需要打开redis服务端口和集群节点gossip通信端口16379(默认是在redis端口号上加1W)   </p><p>防火墙</p><pre class=" language-shell"><code class="language-shell">## 临时关闭防火墙systemctl stop firewalld ## 禁止开机启动systemctl disable firewalld </code></pre><p>集群创建</p><pre class=" language-shell"><code class="language-shell">## --cluster-replicas 1表示每个主节点需要1个从节点/redis/src/redis-cli --cluster create --cluster-replicas 1 192.168.186.131:6001 192.168.186.132:6002 192.168.186.133:6003 192.168.186.131:6004 192.168.186.132:6005 192.168.186.133:6006</code></pre><p><img src="!%5B%5D(https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210126141320.png"></p><h3 id="集群检查"><a href="#集群检查" class="headerlink" title="集群检查"></a>集群检查</h3><p>连接任意一个redis客户端</p><pre class=" language-shell"><code class="language-shell">##  -a访问服务端密码,-c表示集群模式,-h指定ip地址,-p端口号/redis/src/redis-cli -c -h 192.168.186.132 -p 6002## 查看集群信息cluster info## 查看节点列表cluster nodes</code></pre><p><img src="!%5B%5D(https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/image-20210126142004221.png" alt="image-20210126142004221"></p><p>从cluster nodes可以看出集群关系</p><p>1（主）-6（从）    槽位：0-5460</p><p>2（主）-4（从）    槽位：5461-10922</p><p>3（主）-5（从）    槽位：10923-16383</p><p>关闭集群需要逐个关闭，<strong>集群一旦构建好后，停机后只需每个节点重新启动便可，不需要在执行集群创建命令</strong></p><pre class=" language-shell"><code class="language-shell">/redis/src/redis-cli -c -h 192.168.186.132 -p 6002 shutdown</code></pre><h2 id="Redis集群水平扩缩容"><a href="#Redis集群水平扩缩容" class="headerlink" title="Redis集群水平扩缩容"></a>Redis集群水平扩缩容</h2><p>下面看下集群命令</p><pre class=" language-shell"><code class="language-shell">src/redis-cli --cluster help</code></pre><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210129135650.png"></p><ul><li>create：创建一个集群环境host1:port1 … hostN:portN</li><li>call：可以执行redis命令</li><li>add-node：将一个节点添加到集群里，第一个参数为新节点的ip:port，第二个参数为集群中任意一个已经存在的节点的ip:port </li><li>del-node：移除一个节点</li><li>reshard：重新分片</li><li>check：检查集群状态 </li></ul><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>在刚刚搭好的集群上面进行水平扩容，增加一个小集群6007（主）和6008（从）；</p><p>首先需要启动2个redis实例</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210129135348.png"></p><p>2个新节点启动并没有加入到集群，cluster nodes 发现只有6个节点</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210129135920.png"></p><p><strong>现在开始加入主节点</strong></p><pre class=" language-shell"><code class="language-shell">src/redis-cli --cluster add-node 192.168.186.132:6007 192.168.186.132:6001</code></pre><p>现在看下集群状态，多了一个master(刚加入的节点都直接是master)</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210129140758.png"></p><p>这时候加入的master不可以使用因为它没有槽位，需要rehash分配槽位</p><p><strong>分配槽位</strong></p><pre class=" language-shell"><code class="language-shell">src/redis-cli --cluster reshard 192.168.186.132:6002</code></pre><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210129141329.png"></p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/image-20210129141404905.png" alt="image-20210129141404905"></p><p>这时候再看一下集群信息</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210129141459.png"></p><p><strong>加入从节点</strong></p><pre class=" language-shell"><code class="language-shell">src/redis-cli --cluster add-node 192.168.186.132:6008 192.168.186.132:6002</code></pre><p>刚加入在集群里面是master,现在我们要进入6008的客户端</p><pre class=" language-shell"><code class="language-shell">src/redis-cli -c -h 192.168.186.132 -p 6008</code></pre><pre class=" language-shell"><code class="language-shell">## 分配主节点 后面这字符串就是6007的唯一标识cluster replicate 7e4da930cbbcccbb8656dbb5e1f5bead97f9f6ac</code></pre><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210129143230.png"></p><p>扩容成功</p><h3 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h3><p>现在我们删除6007，6008这一个小集群</p><p><strong>删除6008从节点</strong></p><pre class=" language-shell"><code class="language-shell">## 后面这节点id是6008的idsrc/redis-cli --cluster del-node 192.168.186.132:6008 87d4ff53c193c24ff7b6c6cdd33478531dd7fe1e</code></pre><p><strong>删除6007主节点</strong></p><p>删除主节点之前需要先把hash槽释放掉</p><pre class=" language-shell"><code class="language-shell"> src/redis-cli --cluster reshard 192.168.186.132:6007</code></pre><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210129144535.png"></p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210129144643.png"></p><p>删除节点</p><pre class=" language-shell"><code class="language-shell">src/redis-cli --cluster del-node 192.168.186.132:6007 7e4da930cbbcccbb8656dbb5e1f5bead97f9f6ac</code></pre><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210129144908.png"></p><p>缩容成功</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安装手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装 </tag>
            
            <tag> Linux </tag>
            
            <tag> Redis </tag>
            
            <tag> 分布式缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka生产实践与性能优化</title>
      <link href="2021/01/25/kafka-sheng-chan-shi-jian-yu-xing-neng-you-hua/"/>
      <url>2021/01/25/kafka-sheng-chan-shi-jian-yu-xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="Kafka如何保证消息不丢失"><a href="#Kafka如何保证消息不丢失" class="headerlink" title="Kafka如何保证消息不丢失"></a>Kafka如何保证消息不丢失</h2><p>首先要想保证全链路的消息不丢失，要从生产端和消费端来考虑</p><h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><p>控制参数ack的设置</p><ul><li>acks=0： 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消息</li><li>acks=1： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一条消息。这种情况下，如果follower没有成功备份数据，而此时leader宕掉，消息会丢失</li><li>acks=-1或all： 这意味着leader需要等待所有备份(min.insync.replicas配置的备份个数)都成功写入日志，这种策略会保证只要有一个备份存活就不会丢失数据。<strong>min.insync.replicas必须保证大于1，等于1就和ack=1的情况一样</strong>。这时候消息基本不会丢失，是最强的数据保证。</li></ul><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p>消费端这边首先不能是自动提交，万一消费到数据还没处理完，就自动提交offset了，但是此时你consumer宕机，未处理完的数据丢失了。所以这里必须是手动提交才能最大程度的保证消息不丢失。</p><h2 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h2><h3 id="生产端-1"><a href="#生产端-1" class="headerlink" title="生产端"></a>生产端</h3><p>发送消息如果配置了重试机制，比如网络抖动时间过长导致发送端发送超时，实际broker可能已经接收到消息，但发送方会重新发送消息。消费者会多次消费消息。</p><h3 id="消费端-1"><a href="#消费端-1" class="headerlink" title="消费端"></a>消费端</h3><p>消费端这边配置的是自动提交，刚拉取了一批数据处理了一部分，但还没来得及提交，服务挂了，下次重启又会拉取相同的一批数据重复处理，出现了重复消费</p><p>解决重复消费可以再消费端通过<strong>消息幂等</strong>去做</p><h2 id="消息乱序问题"><a href="#消息乱序问题" class="headerlink" title="消息乱序问题"></a>消息乱序问题</h2><h3 id="生产端-2"><a href="#生产端-2" class="headerlink" title="生产端"></a>生产端</h3><p>生产端配置了异步发送，重试机制，可能会出现消息乱序。某一条消息由于网络抖动的原因没有发送成功，但它后面的消息发送成功了，由于重试机制发送失败的消息会再次发送，出现了消息乱序。</p><p>解决：可以用同步发送的模式去发消息，acks不能设置为0，这样也能保证消息发送的有序。</p><h3 id="消费端-2"><a href="#消费端-2" class="headerlink" title="消费端"></a>消费端</h3><p>将消息发送到同一个分区，然后用一个消费者去消费，保证了消费者消费顺序，不过性能较低。</p><p>性能低解决方案：可以在消费端增加几条内存队列(可以搞多个)，一个内存队列开启一个线程顺序处理消息。</p><h2 id="消息积压问题"><a href="#消息积压问题" class="headerlink" title="消息积压问题"></a>消息积压问题</h2><p>消息积压出现情况</p><ol><li>由于生产端生产消息与消费端消费速率不一致（消费者由于性能问题消费过慢）</li><li>消费组挂了一个消费者</li><li>消费端出现了bug导致消息一致重新消费</li></ol><p>如果积压了大量的消息在broker没有消费，要想紧急处理这一批消息，可以修改消费端程序，让其将收到的消息快速转发到其他topic(可以设置很多分区)，然后再启动多个消费者同时消费新主题的不同分区</p><p>由于消费端bug导致的消息积压，可以模拟死信队列实现方案，讲不成功的消息转移到死信队列，后续分析死信队列里面的消息解决消费端问题</p><h2 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h2><p>延时队列存储的对象是延时消息。延时消息是指消息被发送以后，并不想让消费者立刻获取，而是等待特定的时间后，消费者才能获取这个消息进行消费</p><p>实现方案：可以模拟RocketMQ的延时队列实现方案来实现。发送延时消息时先把消息按照不同的延迟时间段发送到指定的队列（topic_1s，topic_5s，topic_10s，…）；然后通过定时器进行轮训消费这些topic，查看消息是否到期，如果到期就把这个消息发送到具体的topic</p><h2 id="Kafka的事务"><a href="#Kafka的事务" class="headerlink" title="Kafka的事务"></a>Kafka的事务</h2><p>这里的事务和RocketMQ的事务消息是不一致的，Kafka的事务主要是保障一次发送多条消息的事务一致性(要么同时成功要么同时失败)；就是Kafka发送消息到不同的Topic里面去，保证同时发送成功或同时失败。</p><pre class=" language-java"><code class="language-java">Properties props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"bootstrap.servers"</span><span class="token punctuation">,</span> <span class="token string">"localhost:9092"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"transactional.id"</span><span class="token punctuation">,</span> <span class="token string">"my-transactional-id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Producer<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaProducer</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化事务</span> producer<span class="token punctuation">.</span><span class="token function">initTransactions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//开启事务</span>     producer<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//发到不同的主题的不同分区</span>         producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"hdfs-topic"</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"es-topic"</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"redis-topic"</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//提交事务</span>     producer<span class="token punctuation">.</span><span class="token function">commitTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ProducerFencedException</span> <span class="token operator">|</span> OutOfOrderSequenceException <span class="token operator">|</span> AuthorizationException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// We can't recover from these exceptions, so our only option is to close the producer and exit.</span>     producer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">KafkaException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// For all other exceptions, just abort the transaction and try again.</span>     <span class="token comment" spellcheck="true">//回滚事务</span>     producer<span class="token punctuation">.</span><span class="token function">abortTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> producer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> Kafka </tag>
            
            <tag> Java </tag>
            
            <tag> 生产实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka基本使用及设计原理</title>
      <link href="2021/01/23/kafka-ji-ben-shi-yong-ji-she-ji-yuan-li/"/>
      <url>2021/01/23/kafka-ji-ben-shi-yong-ji-she-ji-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Kafka是一个分布式基于Zookeeper的分布式消息系统，支持多分区，多副本。是由Scala语言开发，现在是Apache基金会顶级开源项目。它有着高吞吐、低延迟的特性。这种特性主要应用于大数据场景，日志收集场景。不适合一些复杂的业务场景，复杂的业务场景不适合Kafka建议RocketMQ。</p><h2 id="Kafka基本概念"><a href="#Kafka基本概念" class="headerlink" title="Kafka基本概念"></a>Kafka基本概念</h2><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>Kafka服务节点，可启动多个组成Broker集群，Broker基本信息都是存储在zookeeper，可以认为Broker集群是一个无状态的集群。</p><p>Broker主要职责：</p><ul><li>接收Producer和Consumer的请求，并把消息写进磁盘。Broker以Topic为基本单位划分成不同partition，消息存储在不同partition。</li><li>Broker可以保证同一个topic下的同一个partition消息是有序的。</li><li><strong>Broker中保存的数据是有有效期的，默认168小时，可以修改配置log.retention.hours调整</strong></li></ul><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>Kafka根据Topic将消息进行分组，相当于逻辑分组，发送消息的时候需要指定Topic</p><h3 id="ConsumerGroup"><a href="#ConsumerGroup" class="headerlink" title="ConsumerGroup"></a>ConsumerGroup</h3><p>消费者组，每个Consumer都有一个指定的ConsumerGroup，一条消息只可以被一个ConsumerGroup中的一个Consumer消费。一条消息可以被不同的ConsumerGroup消费。根据这可以实现单播消息和多播消息。</p><h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>一个topic有多个partition,每个partition内部消息都是有序的。每个partition都有着自己的一个集群，并且有一个Leader对外提供读写请求，其余都是Follow不能提供读写请求只是同步Leader数据并且在Leader宕掉的情况下进行选举提升为Leader。</p><p>每个Topic下的数据是海量的。对于这批海量的数据为了减小服务器压力，可以建多个partition，而对于partition可以派分到不同的broker上面，而不同的broker在不同的服务器上。这样也就是把消息的压力分到了不同的服务器上面，减少服务器压力。</p><p>简而言之，topic可以进行partition分区主要可以<strong>提升并行度</strong>和<strong>分布式存储</strong>（将大体量的数据分区存储在不同服务器）。</p><h3 id="单播消息"><a href="#单播消息" class="headerlink" title="单播消息"></a>单播消息</h3><p>一条消息只能被一个消费者消费，让所有消费者在同一个消费组里面就可以了。</p><h3 id="多播消息"><a href="#多播消息" class="headerlink" title="多播消息"></a>多播消息</h3><p>一条消息能被多个消费者消费，多个消费者放在不同的消费组里面进行消费，这时多个消费者就都可以收到消息。</p><h2 id="消息日志"><a href="#消息日志" class="headerlink" title="消息日志"></a>消息日志</h2><p>消息发送在topic下面的某一个partition下。实际消息存储在commit log文件里面，<strong>每个partition，都对应一个commit log文件</strong>，每一条消息都有一个唯一编号<strong>offset</strong>。存储结构是每一个Topic下面是多个partition文件，每一个文件里面存储着一个message消息序列，是一个offset数组。</p><p>每个Consumer是基于自己在commit log的消息进度来工作的，消息消费的offset是由Consumer自己来维护的(其实是ConsumerGroup来维护的，这里也可以看出每一个消费组里面的消息者只能消费一次消息)。指定offset可以消费特定的消息，也可以消费重复的消息（消息没有删除的情况下）。</p><p>从这也可以看出<strong>Consumer对Kafka集群的影响基本没有</strong>。</p><p>下面具体看一下Topic下面的日志情况</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210124143725.png"></p><p>进入my-repl-topic 0 分区下</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/image-20210124144757309.png"></p><p>Kafka 一个topic下一个分区的消息存储在一个文件夹下，文件夹命名为topic名字+分区号。消息在分区内是分段存储的，每段消息是存储在不一样的log文件下，每段日志消息规定不超过1G,方便kafka把log文件加载到内存去运算。</p><p>从这我们可以看出一个topic分区下又4个文件,主要是 *.index, *.log, *.timeindex</p><ul><li>*.log：消息存储文件 主要存offset和消息体</li><li>*.index：部分消息的索引文件，kafka每次往分区写入了4k（可配置）的消息就会记录一条当前消息的offset进index文件，一般定位消息的offset就是在index下面快速定位然后在通过index里面存储的地址去log文件里面快速找到对应的消息消费</li><li>*.timeindex：消息的发送时间索引文件，和 index文件写入机制一样不过会比index文件多存储一个消息发送时间戳，如果需要按照时间来定位消息的offset会在timeindex里面去查找</li></ul><p>这几个文件的文件名命令规则就是这个日志段文件里包含的起始offset</p><p><strong>log.segment.bytes，限定了每个日志段文件的大小，最大就是 1GB</strong></p><h3 id="offset记录机制"><a href="#offset记录机制" class="headerlink" title="offset记录机制"></a>offset记录机制</h3><p>上面第一张图有50个consumer_offsets-*文件，从上面描述的topic名字+分区号命令就可以知道有个consumer_offsets主题</p><p>共50个分区（可配置），consumer会将自己消息的偏移量（offset）发送到这个topic下面，消息key是consumerGroupId+topic+分区号</p><p>value是当前offset的值，这样做的目的是抗高并发，扛不住也可以通过增加分区，增加机器来解决</p><p>默认50分区<strong>配置offsets.topic.num.partitions可修改分区数</strong></p><h2 id="Controller选举机制"><a href="#Controller选举机制" class="headerlink" title="Controller选举机制"></a>Controller选举机制</h2><p>这里的Controller叫做核心总控制器，是在broker层面的。它会选举一个broker为核心总控制器，负责管理整个集群中分区，副本的状态。</p><h3 id="如何选举？"><a href="#如何选举？" class="headerlink" title="如何选举？"></a>如何选举？</h3><p>这里的选举主要是依赖于zookeeper来进行的</p><ol><li>当一个broker启动时，会在zookeeper那创建一个/controller临时节点，zookeeper会保证只有一个创建成功，这个broker就是这个集群的Controller.</li><li>当这个Controller宕机了，zookeeper临时节点消失，其他broker会一直watch这个/controller节点，发现节点消失会重新竞争创建/controller节点，创建成功的就成为了新的Controller</li></ol><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/image-20210124153129683.png"></p><h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><table><thead><tr><th><strong>监听</strong></th><th><strong>监听zk路径</strong></th><th>职责</th></tr></thead><tbody><tr><td>BrokerChangeListener</td><td>/brokers/ids</td><td>broker增减的监听</td></tr><tr><td>TopicChangeListener</td><td>/brokers/topics</td><td>topic新建的监听</td></tr><tr><td>DeleteTopicListener</td><td>/admin/delete_topics</td><td>topic删除的监听</td></tr><tr><td>PartitionChangeListener</td><td>/brokers/topics/TOPIC_NAME</td><td>topic partition扩容的监听</td></tr><tr><td>IsrChangeNotificationListener</td><td>/isr_change_notification</td><td>partition isr 变动的监听</td></tr><tr><td>PreferredReplicaElectionListener</td><td>/admin/preferred_replica_election</td><td>partition leader的选举</td></tr></tbody></table><h2 id="Partition副本选举机制"><a href="#Partition副本选举机制" class="headerlink" title="Partition副本选举机制"></a>Partition副本选举机制</h2><p>controller感知到broker节点挂了，unclean.leader.election.enable配置分2种情况选leader</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/image-20210124154904026.png"></p><p>Replicas：某个partition在哪几个broker上存在备份</p><p>ISR(In Sync Replicas)：ISR是replicas的一个子集，它只列出当前还存活着的，并且已同步备份了该partition的节点。（replica.lag.time.max.ms 配置决定的，超过这个时间都没有跟leader同步过的一次的副本会被移出ISR列表）</p><ul><li>unclean.leader.election.enable=false：controller会从ISR列表中选出leader，ISR空的时候会等待，这个时候这个分区不可用</li><li>unclean.leader.election.enable=true：controller会从ISR列表中选出leader，ISR空的时候会从ISR以外的副本中选leader，但新leader数据可能落后太多</li></ul><h2 id="消费者Rebalance机制"><a href="#消费者Rebalance机制" class="headerlink" title="消费者Rebalance机制"></a>消费者Rebalance机制</h2><p>消费者reblance机制就是当一个消费者组里面的消费者发生了变化或者分区数发生了变化，为了让分区可以被消费，kafka会重新分配分区。</p><p><strong>reblance机制只适用于不指定分区消费的情况</strong></p><p><strong>reblance过程，消费者不会消费消息</strong></p><p>2个关键概念</p><p>组协调器GroupCoordinator：Broker，组协调器主要负责监控消费组里面的所有消费者的心跳，判断是否宕机，开始reblance</p><p>消费组协调器LeaderCoordinator：消费者，制定分区方案</p><h3 id="reblance流程"><a href="#reblance流程" class="headerlink" title="reblance流程"></a>reblance流程</h3><ol><li>选举组协调器：每个消费组都会选举一个broker作为自己的组协调器GroupCoordinator，消费组里面的每个消费者启动时都会向kafka集群中的某个broker发送FindCoordinatorRequest来找到自己的组协调器，组协调器选择是根据消费者偏移量发送到的分区的leader的broker节点，就是消费组提交的offset到consumer_offsets的某个分区，而这个分区的leader是哪个broker,那么这个broker就是这个消费组的组协调器。</li><li>加入消费组：找到组协调器后，当一个消费者加入消费组，消费者会向组协调器发送JoinGroupRequest，组协调器会从消费组中选择第一个加入消费组的消费者作为消费组协调器LeaderCoordinator，然后消费组协调器制定分区方案并发送给组协调器。</li><li>同步阶段：组协调器收到消费组协调器的分区方案，将分区方案下发给其他消费者，每个消费者根据分区方案进行消息消费。</li></ol><h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><p>主要有3种分区策略，range、round-robin、sticky</p><p>假设现有0-9  10个分区，消费组里有3个消费者</p><ul><li>range：按照分区序号排序，0,1,2,3给第一个；4,5,6给第二个；7,8,9给第3个</li><li>round-robin：轮询分配，0,3,6,9给第一个；1,4,7给第二个；2,5,8给第3个</li><li>sticky：初始时分配策略与round-robin类似，但是在rebalance的时候，需要保证如下两个原则<ol><li>分区的分配要尽可能均匀</li><li>分区的分配尽可能与上次分配的保持相同</li></ol></li></ul><h2 id="HW与LEO详解"><a href="#HW与LEO详解" class="headerlink" title="HW与LEO详解"></a>HW与LEO详解</h2><p>HW(HignWatermark)高水位：consumer最多只能消费到HW,每个分区副本都有自己的HW，都分别自己维护HW。</p><p>LEO（log-end-offset）：日志最后的偏移量，每个分区副本的LEO并不一定相同，Kafka会取多个副本中最小的LEO为HW.</p><p>这里简单介绍一下高水位同步过程</p><p>前提：假设某主题3副本，HW|LEO为3</p><ol><li>两条消息写到Leader，这时Leader的LEO增加2，Leader LEO为5；3个副本HW为3，这时候消费者消费不到新写入的2条消息，他们只能消费到HW的消息</li><li>Follower开始fetch消息，当2个Follower都fetch了一条消息此时Leader LEO为5;；3个副本HW为4；2个Follower LEO为4，此时消费者可以消息4这条消息不能消费5这条消息</li></ol><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/image-20210124160604864.png"></p><h2 id="分区数与吞吐量成正相关吗"><a href="#分区数与吞吐量成正相关吗" class="headerlink" title="分区数与吞吐量成正相关吗"></a>分区数与吞吐量成正相关吗</h2><p>答案是否，kafka有自己的压测工具，可以测试分区数不同，各种情况下的吞吐量</p><p>创建3个分区数不同的topic</p><pre class=" language-shell"><code class="language-shell">bin/kafka-topics.sh --zookeeper localhost:2181 --create --replication-factor 1 --partitions 10 --topic test-10bin/kafka-topics.sh --zookeeper localhost:2181 --create --replication-factor 1 --partitions 100 --topic test-100bin/kafka-topics.sh --zookeeper localhost:2181 --create --replication-factor 1 --partitions 1000 --topic test-1000</code></pre><pre class=" language-shell"><code class="language-shell"># 往test里发送一百万消息，每条设置1KB# throughput 用来进行限流控制，当设定的值小于 0 时不限流，当设定的值大于 0 时，当发送的吞吐量大于该值时就会被阻塞一段时间bin/kafka-producer-perf-test.sh --topic test --num-records 1000000 --record-size 1024 --throughput -1 --producer-props bootstrap.servers=192.168.186.131:9092 acks=1</code></pre><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210125190349.png"></p><p>从压测结果来看，分区数10 吞吐量30.07 MB/sec；分区数100 吞吐量60.47 MB/sec；分区数1000 吞吐量30.03 MB/sec；</p><p>到达某个值吞吐量反而开始下降，说明一味的增加分区数并不能使我们的吞吐量得到提升，需要经过实际测试确定Kafka一些参数的设置（包括分区数和buff缓冲区等等）</p><p>注意：如果分区数设置过大，比如设置10000，可能会设置不成功，后台会报错”java.io.IOException : Too many open files”。</p><p>这是一种常见的 Linux 系统错误，通常意味着文件描述符不足，它一般发生在创建线程、创建 Socket、打开文件这些场景下 。 在 Linux系统的默认设置下，这个文件描述符的个数不是很多 ，通过 ulimit -n 命令可以查看：一般默认是1024，可以将该值增大，比如：ulimit -n 65535</p><h2 id="kafka高性能的原因"><a href="#kafka高性能的原因" class="headerlink" title="kafka高性能的原因"></a>kafka高性能的原因</h2><ul><li>磁盘顺序读写：kafka消息不能修改以及不会从文件中间删除保证了磁盘顺序读，kafka的消息写入文件都是追加在文件末尾，不会写入文件中的某个位置(随机写)保证了磁盘顺序写。</li><li>数据传输的零拷贝</li><li>读写数据的批量batch处理以及压缩传输</li></ul><h2 id="Zookeeper与Kafka"><a href="#Zookeeper与Kafka" class="headerlink" title="Zookeeper与Kafka"></a>Zookeeper与Kafka</h2><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/image-20210124160645795.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> Kafka </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KafKa单机、集群、控制台搭建</title>
      <link href="2021/01/19/kafka-dan-ji-yi-ji-ji-qun-da-jian/"/>
      <url>2021/01/19/kafka-dan-ji-yi-ji-ji-qun-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>java版本：1.8</p><p>操作系统：CentOS7</p><p>zookeeper：3.5.8</p><p>安装包：<a href="https://kafka.apache.org/downloads">https://kafka.apache.org/downloads</a></p><p>我这里选择的是kafka_2.11-2.4.1版本的KafKa，2.11是scala的版本，2.4.1是kafka的版本</p><h2 id="KafKa单机搭建"><a href="#KafKa单机搭建" class="headerlink" title="KafKa单机搭建"></a>KafKa单机搭建</h2><p>Kafka是用Scala语言开发，需要JVM环境，所以需要安装Java。</p><p>KafKa依赖zookeeper，所以需要安装zookeeper</p><p>对于zookeeper和Java环境的安装这里就不写了</p><h3 id="Kafka下载"><a href="#Kafka下载" class="headerlink" title="Kafka下载"></a>Kafka下载</h3><p>Kafka下载有多种方式，可以选择官网也可以选择镜像</p><ul><li><p>官网地址：<a href="https://kafka.apache.org/downloads">https://kafka.apache.org/downloads</a></p></li><li><p>镜像地址：<a href="https://mirror.bit.edu.cn/apache/kafka/2.4.1/kafka_2.11-2.4.1.tgz">https://mirror.bit.edu.cn/apache/kafka/2.4.1/kafka_2.11-2.4.1.tgz</a></p></li></ul><pre class=" language-shell"><code class="language-shell">## 镜像下载wget https://mirror.bit.edu.cn/apache/kafka/2.4.1/kafka_2.11-2.4.1.tgz## 解压tar -zxvf kafka_2.11-2.4.1.tgz -C  /## 软链接ln -s /kafka_2.11-2.4.1/ /kafkacd&nbsp;/kafka</code></pre><h3 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h3><pre class=" language-shell"><code class="language-shell">vim config/server.properties</code></pre><p>这里需要说几个关键配置</p><table><thead><tr><th>属性</th><th>默认值</th><th>解释</th></tr></thead><tbody><tr><td>broker.id</td><td>0</td><td>每个broker都可以用一个唯一的非负整数id进行标识；这个id可以作为broker的“名字”，你可以选择任意你喜欢的数字作为id，只要id是唯一的即可</td></tr><tr><td>log.dirs</td><td>/tmp/kafka-logs</td><td>kafka存放数据的路径。这个路径并不是唯一的，可以是多个，路径之间只需要使用逗号分隔即可；每当创建新partition时，都会选择在包含最少partitions的路径下进行</td></tr><tr><td>listeners</td><td>PLAINTEXT://:9092</td><td>server接受客户端连接的端口，ip配置kafka本机ip即可</td></tr><tr><td>zookeeper.connect</td><td>localhost:2181</td><td>zooKeeper连接字符串的格式为：hostname:port，此处hostname和port分别是ZooKeeper集群中某个节点的host和port；zookeeper如果是集群，连接方式为hostname1:port1, hostname2:port2, hostname3:port3</td></tr><tr><td>log.retention.hours</td><td>168</td><td>每个日志文件删除之前保存的时间。默认数据保存时间对所有topic都一样</td></tr><tr><td>num.partitions</td><td>1</td><td>创建topic的默认分区数</td></tr><tr><td>default.replication.factor</td><td>1</td><td>自动创建topic的默认副本数量，建议设置为大于等于2</td></tr><tr><td>min.insync.replicas</td><td>1</td><td>当producer设置acks为-1时，min.insync.replicas指定replicas的最小数目（必须确认每一个repica的写数据都是成功的），如果这个数目没有达到，producer发送消息会产生</td></tr><tr><td>delete.topic.enable</td><td>false</td><td>是否允许删除主题</td></tr></tbody></table><p>简版：</p><pre class=" language-shell"><code class="language-shell">#broker.id属性在kafka集群中必须要是唯一broker.id=0#kafka部署的机器ip和提供服务的端口号listeners=PLAINTEXT://192.168.186.131:9092#kafka的消息存储文件log.dir=/usr/local/data/kafka‐logs#kafka连接zookeeper的地址zookeeper.connect=localhost:2181</code></pre><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre class=" language-shell"><code class="language-shell">## -daemon 表示后台启动bin/kafka-server-start.sh -daemon config/server.properties</code></pre><p>后台启动日志会打印在logs目录的server.log</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>主题创建一个名字为“test”的Topic，partition=1，备份因子=1</p><pre class=" language-shell"><code class="language-shell">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</code></pre><p>发送消息</p><pre class=" language-shell"><code class="language-shell">bin/kafka-console-producer.sh --broker-list 192.168.186.131:9092 --topic test## 命令中输入要发送的消息的内容</code></pre><p>消费Topic为test的消息</p><pre class=" language-shell"><code class="language-shell">bin/kafka-console-consumer.sh --bootstrap-server 192.168.186.131:9092 --topic test</code></pre><h2 id="KafKa集群搭建"><a href="#KafKa集群搭建" class="headerlink" title="KafKa集群搭建"></a>KafKa集群搭建</h2><p>与单机搭建基本一致，主要改一下配置文件</p><p>我们有3个配置文件server.properties，server-1.properties，server-2.properties</p><p>server-1.properties:</p><pre class=" language-shell"><code class="language-shell">#broker.id属性在kafka集群中必须要是唯一broker.id=1#kafka部署的机器ip和提供服务的端口号listeners=PLAINTEXT://192.168.186.131:9093log.dir=/data/kafka/kafka‐logs‐1#kafka连接zookeeper的地址，要把多个kafka实例组成集群，对应连接的zookeeper必须相同zookeeper.connect=localhost:2181</code></pre><p>server-2.properties:</p><pre class=" language-shell"><code class="language-shell">#broker.id属性在kafka集群中必须要是唯一broker.id=2#kafka部署的机器ip和提供服务的端口号listeners=PLAINTEXT://192.168.186.131:9094log.dir=/data/kafka/kafka‐logs‐2#kafka连接zookeeper的地址，要把多个kafka实例组成集群，对应连接的zookeeper必须相同zookeeper.connect=localhost:2181</code></pre><p>启动</p><pre class=" language-shell"><code class="language-shell">bin/kafka‐server‐start.sh&nbsp;‐daemon&nbsp;config/server‐1.propertiesbin/kafka‐server‐start.sh&nbsp;‐daemon&nbsp;config/server‐2.properties</code></pre><h2 id="Kafka客户端常用命令"><a href="#Kafka客户端常用命令" class="headerlink" title="Kafka客户端常用命令"></a>Kafka客户端常用命令</h2><p>创建一个新的topic，副本数设置为3，分区数设置为2</p><pre class=" language-shell"><code class="language-shell">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 2 --topic my-repl-topic</code></pre><p>查看topic分区情况</p><pre class=" language-shell"><code class="language-shell">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-repl-topic</code></pre><p>发消息</p><pre class=" language-shell"><code class="language-shell">bin/kafka-console-producer.sh --broker-list 192.168.186.131:9092,192.168.186.131:9093,192.168.186.131:9094 --topic my-repl-topic</code></pre><p>消费消息</p><pre class=" language-shell"><code class="language-shell">bin/kafka-console-consumer.sh --bootstrap-server 192.168.186.131:9092,192.168.186.131:9093,192.168.186.131:9094 --from-beginning --topic my-repl-topic</code></pre><h2 id="Kafka控制台搭建"><a href="#Kafka控制台搭建" class="headerlink" title="Kafka控制台搭建"></a>Kafka控制台搭建</h2><p>Kafka官方是没有开发自己的控制台。yahoo构建了一个Kafka控制台管理后台（CMAK）。这个管理工具可以查看Kafka集群的当前运行状态包括broker的状态</p><p>项目地址：<a href="https://github.com/yahoo/kafka-manager">https://github.com/yahoo/kafka-manager</a></p><p>如果觉得编译过程太复杂，可以这里直接下载然后直接走安装后面的步骤</p><p>下载链接：</p><p><a href="https://blog-dm.oss-cn-shanghai.aliyuncs.com/zip/cmak-3.0.0.5.zip">https://blog-dm.oss-cn-shanghai.aliyuncs.com/zip/cmak-3.0.0.5.zip</a>    （需要jdk11,否则报错）</p><p>jdk11没有安装的可以使用老版本的kafka-manager,以下链接为kafka-manager1.3.3.7的版本，测试kafka_2.11-2.4.1可正常使用</p><p><a href="https://blog-dm.oss-cn-shanghai.aliyuncs.com/zip/kafka-manager-1.3.3.7.zip">https://blog-dm.oss-cn-shanghai.aliyuncs.com/zip/kafka-manager-1.3.3.7.zip</a>  （jdk8版本可用）</p><h3 id="下载管理工具CMAK"><a href="#下载管理工具CMAK" class="headerlink" title="下载管理工具CMAK"></a>下载管理工具CMAK</h3><pre class=" language-shell"><code class="language-shell">## 下载wget https://github.com/yahoo/kafka-manager/archive/3.0.0.5.zip## 解压unzip CMAK-3.0.0.5.zip -d /</code></pre><h3 id="sbt编译"><a href="#sbt编译" class="headerlink" title="sbt编译"></a>sbt编译</h3><p>yum安装sbt：</p><p>这个后台管理工具和Kafka一样是scala语言编写需要编译</p><pre class=" language-shell"><code class="language-shell">curl https://bintray.com/sbt/rpm/rpm > bintray-sbt-rpm.repomv bintray-sbt-rpm.repo /etc/yum.repos.d/yum install sbt</code></pre><p>修改仓库地址：（sbt 默认下载库文件很慢）填上阿里云的镜像 </p><pre class=" language-shell"><code class="language-shell"> vim ~/.sbt/repositories</code></pre><p>文件内容：</p><pre class=" language-shell"><code class="language-shell">[repositories]  local  aliyun-nexus: https://maven.aliyun.com/nexus/content/groups/public/  jcenter: https://jcenter.bintray.com/  typesafe-ivy-releases: https://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly  maven-central</code></pre><p>验证sbt安装成功</p><pre class=" language-shell"><code class="language-shell">sbt -version</code></pre><h3 id="编译CMAK（前身叫Kafka-manager）"><a href="#编译CMAK（前身叫Kafka-manager）" class="headerlink" title="编译CMAK（前身叫Kafka-manager）"></a>编译CMAK（前身叫Kafka-manager）</h3><pre class=" language-shell"><code class="language-shell">## 来到刚刚解压目录下执行./sbt clean dist## 编译如果还是不行报Download failed. Obtain the jar manually and place it at /root/.sbt/launchers/0.13.9/sbt-launch.jar## 可以修改解压目录下sbt编译文件下的http://repo.typesafe.com为https://repo.typesafe.com</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class=" language-shell"><code class="language-shell">## 重新解压编译后的代码unzip cmak-3.0.0.5.zip -d /ln -s /cmak-3.0.0.5/ /cmakcd /cmak## 修改配置文件vim conf/application.conf</code></pre><p>修改kafka-manager.zkhosts列表为自己的zk节点</p><pre class=" language-shell"><code class="language-shell">cmak.zkhosts="192.168.186.131:2181"  （3.0.0.5 - jdk11）cmak.zkhosts="192.168.186.131:2181" （1.3.3.7 - jdk8）</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>后台启动，日志存储nohup.out，默认端口9000，-Dhttp.port=9999可修改端口</p><pre class=" language-shell"><code class="language-shell">nohup bin/cmak -Dconfig.file=conf/application.conf &   （3.0.0.5 - jdk11）nohup bin/kafka-manager -Dconfig.file=conf/application.conf &   （1.3.3.7 - jdk8）</code></pre><p>打开：ip:9000</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210124030220.png"></p><p>添加一个集群</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210124030310.png"></p><p>主界面：</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210124030552.png"></p><p>Broker:</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/image-20210124141246214.png"></p><p>Topic列表:</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/image-20210124141303687.png"></p><p>Topic详情：</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/image-20210124141347466.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安装手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KafKa </tag>
            
            <tag> 安装 </tag>
            
            <tag> Linux </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ生产问题实践</title>
      <link href="2021/01/12/rocketmq-sheng-chan-wen-ti/"/>
      <url>2021/01/12/rocketmq-sheng-chan-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="RocketMQ如何保证消息不丢失"><a href="#RocketMQ如何保证消息不丢失" class="headerlink" title="RocketMQ如何保证消息不丢失"></a>RocketMQ如何保证消息不丢失</h2><p>RocketMQ的一个发送消息流程</p><p>生产者 =&gt; Broker =&gt; 消费者     Broker master =&gt; slave =&gt; 磁盘</p><ol><li>生产者发送消息给到Broker</li><li>Broker进行主从同步</li><li>Broker不管Master还是Slave进行刷盘操作</li><li>Broker将消息投递给消费者</li></ol><p>在上面4个步骤任何一个步骤都将会出现消息丢失的情况，当然别的MQ也会有同样的情况出现。其实还有第5种情况NameServer挂了。</p><p>下面针对这5种情况进行分析</p><h3 id="生产者发送消息"><a href="#生产者发送消息" class="headerlink" title="生产者发送消息"></a>生产者发送消息</h3><p>所有网络请求都是不可靠的，走网络请求都有一定的消息丢失的可能性。</p><p>同步发送是一个好办法，发送等Broker有应答了表示Broker接收成功进行下一步操作。</p><p>但这样有问题,我消息发送出去了，但本地代码执行异常了怎么办。或许有人说可以本地代码执行完成再去进行消息发送操作，但这样消息发送失败了怎么办。这些都有各种各样的问题。RocketMQ对于这些场景提供了事务消息的思路。</p><p>事务消息其实相当于给我们很多次反悔的操作。</p><h4 id="事务消息实现机制"><a href="#事务消息实现机制" class="headerlink" title="事务消息实现机制"></a>事务消息实现机制</h4><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210107112452.png"></p><p>步骤：</p><ol><li>发送方将half事务消息发送到broker</li><li>broker把消息持久化成功，向发送方返回ACK确认收到消息。</li><li>发送方开始执行本地事务</li><li>发送方根据本地事务执行结果向broker发送二次确认</li><li>broker收到发送方commit状态则将half事务消息标记为可投递，订阅方可以收到消息。。发送方rollback状态，则删除half事务消息。。如果步骤4的二次确认没有发送到broker则会过一段时间broker会对发送方进行消息回查，发送方收到消息回查，检查对应消息的本地事务执行结果。发送方根据回查结果继续步骤5。</li></ol><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A:"></a>Q&amp;A:</h4><p><strong>半事务消息发送失败怎么办？</strong></p><p>要想回答这个问题，首先得了解半事务消息有什么作用。半事务消息主要作用是一个探测功能，证明RocketMQ是可用的。如果没有启动事务消息我们通常的操作是执行本地然后发消息，这样就可能出现一个尴尬的情况，本地都执行成功了，写消息失败了。而引入了半事务消息机制，半事务消息写入失败，没事，我们这时一般认为MQ服务不可用，给要执行的本地代码一个标记，等MQ服务正常重新执行流程。</p><p><strong>本地事务执行失败怎么办？</strong></p><p>比如本地事务需要执行Mysql,刚好这时候Mysql宕了。我们一般可以把数据缓存起来，给Broker一个UNKNOW状态，等待Broker的回查，回查的时候吧缓存起来的数据继续执行本地事务。</p><h3 id="Broker主从同步"><a href="#Broker主从同步" class="headerlink" title="Broker主从同步"></a>Broker主从同步</h3><p>之前2m-2s-async集群的搭建方式其实是不推荐的，生产上一般是使用Dledger搭建集群。因为2m-2s有个生来就有的问题就是不会主从切换，主节点挂了从节点不会顶上去。直到RocketMQ4.5以后的版本才支持Dledger集群。</p><p>Dledger集群会托管CommitLog文件，所以不是像之前配置brokerRole解决主从同步数据丢失的情况。</p><h4 id="Dledger文件同步"><a href="#Dledger文件同步" class="headerlink" title="Dledger文件同步"></a>Dledger文件同步</h4><p>Dledger会通过两阶段提交解决文件同步问题，具体流程如下</p><p>数据同步会通过两个阶段，一个是uncommitted阶段，一个是commited阶段</p><ol><li>Leader Broker上的Dledger收到一条数据后，会标记为uncommitted状态，然后他通过自己的DledgerServer组件把这个uncommitted数据发给Follower Broker的DledgerServer组件</li><li>Follower Broker的DledgerServer收到uncommitted消息之后，必须返回一个ack给Leader Broker的Dledger。然后如果Leader Broker收到超过半数的Follower Broker返回的ack之后，就会把消息标记为committed状态</li><li>Leader Broker上的DledgerServer就会发送committed消息给Follower Broker上的DledgerServer，让他们把消息也标记为committed状态。这样，就基于Raft协议完成了两阶段的数据同步</li></ol><h3 id="Broker同步刷盘"><a href="#Broker同步刷盘" class="headerlink" title="Broker同步刷盘"></a>Broker同步刷盘</h3><p>RocketMQ的刷盘方式flushDiskType配置成同步刷盘就可以保证消息在刷盘过程中不会丢失了</p><h3 id="Broker投递消息"><a href="#Broker投递消息" class="headerlink" title="Broker投递消息"></a>Broker投递消息</h3><p>Broker投递消息本身就是看你的ack来解决的，只要不使用异步消费，一般消息是不会丢失的。但返回ack给broker的时候可能失败，下次就会再次消费消息，出现了重复消费的问题，下面会对重复消费进行解读。</p><h3 id="NameServer挂了"><a href="#NameServer挂了" class="headerlink" title="NameServer挂了"></a>NameServer挂了</h3><p>大家都知道RocketMQ是通过NameServer进行路由转发的，如果集群中所有NameServer都挂了怎么办。</p><p>在这种情况下，RocketMQ相当于整个服务都不可用了，那他本身肯定无法给我们保证消息不丢失了。我们只能自己设计一个降级方案来处理这个问题了。例如在订单系统中，如果多次尝试发送RocketMQ不成功，那就只能另外找给地方(Redis、文件或者内存等)把订单消息缓存下来，然后起一个线程定时的扫描这些失败的订单消息，尝试往RocketMQ发送。这样等RocketMQ的服务恢复过来后，就能第一时间把这些消息重新发送出去。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>完整分析过后，整个RocketMQ消息零丢失的方案就是</p><ul><li>生产者使用事务消息机制</li><li>Broker配置同步刷盘+Dledger主从架构</li><li>消费者不要使用异步消费</li><li>整个MQ挂了之后准备降级方案</li></ul><h2 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h2><p>消费者消费消息的时候业务代码执行完毕正准备给Broker一个ack的时候突然就崩了，这时候ack没有给Broker,offset没有变，之前消费的消息一定会被再次消费，这样就带来了重复消费的问题。解决这种问题的根本就是通过一个全局唯一的编号，记录在Mysql中，消费了增加一条记录，消费前查询一下数据路有没有消费过这条消息。</p><h2 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h2><p>在有些业务场景下可能要保证消息的顺序性。比如消息之间有依赖关系，只有前一个消费过了，后一个才能消费。</p><h3 id="如何保证消息顺序"><a href="#如何保证消息顺序" class="headerlink" title="如何保证消息顺序"></a>如何保证消息顺序</h3><p>消息顺序有2种，全局有序，局部有序</p><ul><li>全局有序：整个MQ系统的所有消息严格按照队列先入先出顺序进行消费。</li><li>局部有序：部分消息有序</li></ul><p>在大部分的MQ业务场景，我们只需要能够保证局部有序</p><p>解决办法：</p><p>发送者发送消息时，会通过MessageQueue轮询的方式保证消息尽量均匀的分布到所有的MessageQueue上，而消费者也就同样需要从多个MessageQueue上消费消息。而MessageQueue是RocketMQ存储消息的最小单元，他们之间的消息都是互相隔离的，在这种情况下，是无法保证消息全局有序</p><p>局部有序：只需要将有序的一组消息都存入同一个MessageQueue里，这样MessageQueue的FIFO设计天生就可以保证这一组消息的有序。RocketMQ中，可以在发送者发送消息时指定一个MessageSelector对象，让这个对象来决定消息发入哪一个MessageQueue。这样就可以保证一组有序的消息能够发到同一个MessageQueue里。</p><p>全局有序：Topic配置成只有一个MessageQueue队列。这样天生就能保证消息全局有序了</p><h2 id="消息积压问题"><a href="#消息积压问题" class="headerlink" title="消息积压问题"></a>消息积压问题</h2><p>在正常情况下，使用MQ都会要尽量保证他的消息生产速度和消费速度整体上是平衡的，但是如果部分消费者系统出现故障，就会造成大量的消息积累。这类问题通常在实际工作中会出现得比较隐蔽。由于网络波动或数据库故障等情况，会导致消息大量的积累。这在一些大型的互联网项目中，消息积压的速度是相当恐怖的。所以消息积压是个需要时时关注的问题。</p><h3 id="如何处理消息积压问题"><a href="#如何处理消息积压问题" class="headerlink" title="如何处理消息积压问题"></a>如何处理消息积压问题</h3><p>如果Topic下的MessageQueue配置得是足够多的，那每个Consumer实际上会分配多个MessageQueue来进行消费。这个时候，就可以简单的通过增加Consumer的服务节点数量来加快消息的消费，等积压消息消费完了，再恢复成正常情况。最极限的情况是把Consumer的节点个数设置成跟MessageQueue的个数相同。但是如果此时再继续增加Consumer的服务节点就没有用了。<br>而如果Topic下的MessageQueue配置得不够多的话，那就不能用上面这种增加Consumer节点个数的方法了。这时怎么办呢？ 这时如果要快速处理积压的消息，可以创建一个新的Topic，配置足够多的MessageQueue。然后把所有消费者节点的目标Topic转向新的Topic，并紧急上线一组新的消费者，只负责消费旧Topic中的消息，并转储到新的Topic中，这个速度是可以很快的。然后在新的Topic上，就可以通过增加消费者个数来提高消费速度了。之后再根据情况恢复成正常情况。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> 生产实践 </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ整体理解和消息样例</title>
      <link href="2021/01/04/rocketmq-zheng-ti-li-jie-he-xiao-xi-yang-li/"/>
      <url>2021/01/04/rocketmq-zheng-ti-li-jie-he-xiao-xi-yang-li/</url>
      
        <content type="html"><![CDATA[<h2 id="RocketMQ架构设计"><a href="#RocketMQ架构设计" class="headerlink" title="RocketMQ架构设计"></a>RocketMQ架构设计</h2><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210104103017.png"></p><p>在RocketMQ上主要分为4部分，Producer、Consumer、NameServer、Broker</p><ul><li>Producer：消息生产者，Producer通过NameServer拉取所有Broker集群，通过负载均衡择相对应的Broker进行消息投递。</li><li>Consumer：消息消费者，Consumer通过NameServer拉取所有Broker集群，通过pull和push2种模式对消息进行消费。</li><li>NameServer：NameServer是一个简化版的注册中心，无状态节点，主要主持Broker的动态注册与发现，功能主要包括对Broker的管理。接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活。<strong>每个NameServer之间不进行通信，他们都存储了整个Broker集群的数据</strong></li><li>Broker：消息中转角色，负责存储消息，转发消息；为生产者，消费者提供服务。</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="生产者组"><a href="#生产者组" class="headerlink" title="生产者组"></a>生产者组</h3><p>同一类Producer组成一个集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p><h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><p>消息生产者会把业务应用系统里产生的消息发送，到broker服务器。RocketMQ提供多种发送方式，<strong>同步发送、异步发送、顺序发送、单向发送</strong>。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p><h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>同一类Consumer组成一个集合，这类Consumer通常消费同一类消息且消费逻辑一致。</p><p>注：消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：<strong>集群消费和广播消费</strong>。</p><ul><li>集群消费：相同消费者组的每个Consumer实例平均分摊消息。</li><li>广播消费：相同消费者组的每个Consumer实例都接收全量的消息。</li></ul><h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>负责消费消息，一般是后台系统负责异步消费。消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。消息消费者提供了两种消费形式：<strong>拉取式消费、推动式消费</strong>。</p><ul><li>拉取式消费：通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</li><li>推动式消费：Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。推动式消费其底层就是对拉取式消费进行了一次封装，是长连接。</li></ul><h3 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）"></a>主题（Topic）</h3><p>一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p><p>同一个Topic下的数据，会分片保存到不同的Broker上，而每一个分片单位，就叫做MessageQueue。MessageQueue是生产者发送消息与消费者消费消息的最小单位。</p><h3 id="服务器（Broker）"><a href="#服务器（Broker）" class="headerlink" title="服务器（Broker）"></a>服务器（Broker）</h3><p>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p><h3 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h3><p>NameServer充当路由消息的提供者。Broker Server会在启动时向所有的NameServer注册自己的服务信息，并且后续通过心跳请求的方式保证这个服务信息的实时性。生产者或消费者能够通过NameServer查找各主题相应的Broker列表。</p><p><strong>多个NameServer实例组成无状态集群，相互独立，没有信息交换。这种特性也就意味着NameServer中任意的节点挂了，只要有一台服务节点正常，整个路由服务就不会有影响。</strong></p><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题Topic。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p><p>并且Message上有一个为消息设置的标志，Tag标签。用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p><h2 id="Broker集群模式"><a href="#Broker集群模式" class="headerlink" title="Broker集群模式"></a>Broker集群模式</h2><p>集群在RocketMQ中分为2种，<strong>普通集群和Dledger高可用集群</strong>。Dledger高可用集群是在4.5版本后引入的高可用集群。</p><h3 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h3><p>普通集群会给每个节点分配一个固定的角色，master负责响应客户端的请求，并存储消息。slave则只负责对master的消息进行同步保存，并响应部分客户端的读请求。消息同步方式分为同步同步和异步同步。</p><p><strong>这种集群模式下各个节点的角色无法进行切换，也就是说，master节点挂了，这一组Broker就不可用了。</strong></p><h3 id="Dledger高可用集群"><a href="#Dledger高可用集群" class="headerlink" title="Dledger高可用集群"></a>Dledger高可用集群</h3><p>普通集群有个致命的缺点就是不能高可用。就是master一挂，集群就不可用了。Dledger集群为了解决高可用问题引入的一种技术。</p><p>在这个集群模式下如果master挂了会选举一个新的master提供服务。Dledger都是通过<strong>Raft协议</strong>解决的选举和副本同步问题。</p><h4 id="Dledger的职责"><a href="#Dledger的职责" class="headerlink" title="Dledger的职责"></a>Dledger的职责</h4><ol><li>接管Broker的CommitLog消息存储</li><li>从集群中选举出master节点</li><li>完成master节点往slave节点的消息同步</li></ol><h4 id="Dledger选举"><a href="#Dledger选举" class="headerlink" title="Dledger选举"></a>Dledger选举</h4><p>Dledger是使用Raft算法来进行节点选举</p><p>每个节点有三个状态，leader，follower和candidate。正常运行的情况下，集群中会有一个leader，其他都是follower，而客户端的请求全部由leader处理，即使有客户端请求到了一个follower，也会将请求转发到leader。</p><p>集群启动阶段：</p><p>集群刚启动时，每个节点都是follower状态，之后集群内部会发送一个timeout信号，所有follower就转成candidate去拉取选票，获得大多数选票的节点选为leader，其他候选人转为follower。如果一个timeout信号发出时，没有选出leader，将会重新开始一次新的选举。而Leader节点会往其他节点发送心跳信号，确认他的leader状态</p><p>集群运行阶段：</p><p>集群启动后每个节点都会启动一个定时器，一段时间没有收到leader心跳，就转化为candidate状态。然后向其他成员发起投票请求，如果收到半数以上成员的投票，则Candidate会晋升为leader。然后leader也有可能会退化成follower。</p><h3 id="Dledger多副本消息同步"><a href="#Dledger多副本消息同步" class="headerlink" title="Dledger多副本消息同步"></a>Dledger多副本消息同步</h3><p>数据同步会通过两个阶段，一个是uncommitted阶段，一个是commited阶段。</p><ol><li><p>Leader Broker上的Dledger收到一条数据后，会标记为uncommitted状态，然后他通过自己的DledgerServer组件把这个uncommitted数据发给Follower Broker的DledgerServer组件。</p></li><li><p>Follower Broker的DledgerServer收到uncommitted消息之后，必须返回一个ack给Leader Broker的Dledger。然后如果Leader Broker收到超过半数的Follower Broker返回的ack之后，就会把消息标记为committed状态。</p></li><li><p>Leader Broker上的DledgerServer就会发送committed消息给Follower Broker上的DledgerServer，让他们把消息也标记为committed状态。</p></li></ol><p>这样，就基于Raft协议完成了两阶段的数据同步。</p><h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h2><p>分布式消息中间件为了保证性能，读写操作基本都是通过内存来操作的，内存操作在服务器宕机的情况下就存在消息丢失的情况。这时候我们肯定是对消息会进行持久化的。而持久化MQ一般都是采用的文件存储。</p><h3 id="磁盘文件读写（顺序写，零拷贝）"><a href="#磁盘文件读写（顺序写，零拷贝）" class="headerlink" title="磁盘文件读写（顺序写，零拷贝）"></a>磁盘文件读写（顺序写，零拷贝）</h3><p>文件存储必然带来的问题就是性能问题，文件存储性能一般而言都不高。但是RocketMQ大家都知道性能是很好的，是可以支持到百万级QPS的。它的优良性能是顺序写和零拷贝带来的。</p><ol><li><p>顺序写：目前的高性能磁盘，顺序写速度可以达到600MB/s， 超过了一般网卡的传输速度。但是磁盘随机写的速度只有大概100KB/s，和顺序写的性能相差6000倍！因为有如此巨大的速度差别，好的消息队列系统会比普通的消息队列系统速度快多个数量级。RocketMQ的消息用顺序写,保证了消息存储的速度。RocketMQ会提前分配1个G的磁盘空间给commitLog.之后生产者发送的消息直接分配到这个commitLog上去。这就是顺序写。</p></li><li><p>零拷贝：Linux操作系统分为用户态和内核态。IO操作不可避免的都会涉及到这2种状态的切换。</p><p>假设一台服务器发送了一条数据给客户端，通常会进行4次数据复制。</p><ol><li>从磁盘文件复制数据到内核态内存</li><li>从内核态内存复制数据到用户态客户端的内存上，如果是Java就是JVM虚拟内存</li><li>从用户态客户端内存复制数据到内核态内存</li><li>最后从网络驱动的内核态内存复制到网卡中进行传输。</li></ol><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210111164005.png"></p><p>而RocketMQ中用来mmap技术，不在将文件复制到用户内存中去。直接将内核内存进行映射。而这种零拷贝技术有一个限制，一次只能映射1.5~2G 的文件至用户态的虚拟内存，这也是为何RocketMQ默认设置单个CommitLog日志数据文件为1G的原因了</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210111164032.png"></p></li></ol><h3 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h3><p>RocketMQ消息的存储分为三个部分：commitlog、consumerqueue、index</p><ul><li>commitlog：生产者发送的消息存入到commitlog，commitlog有多个文件，每个文件固定大小1G。以第一条消息的偏移量为文件名。</li><li>consumerqueue：consumerqueue文件夹下是按Topic来分的，一个Topic一个文件夹。topic文件夹下是按队列来分的，一个队列一个文件夹。队列文件记录当前队列被哪些消费者组消费到了哪一条commitlog,记录的commitlog中的索引。</li><li>index：为了消息查询提供了一种通过key或时间区间来查询消息的方法</li></ul><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210111165049.png"></p><h2 id="消息主从复制"><a href="#消息主从复制" class="headerlink" title="消息主从复制"></a>消息主从复制</h2><p>Broker以集群启动必然包含一个功能便是主从复制方式。RocketMQ消息复制得方式有2个,同步复制和异步复制。</p><h3 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h3><p>同步复制就是等Master和Slave全部写入消息成功，反馈给客户端消息写入成功。</p><p>优势：数据更加完整，Slave有全部的数据备份，即使Master挂了也没事。</p><p>劣势：会增加数据写入延迟，降低系统吞吐量。</p><h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p>异步复制只要Master复制成功直接返回客户端消息写入成功，然后异步复制消息给Slave</p><p>优势：数据写入延迟低，系统吞吐量高。</p><p>劣势：消息丢失可能性高。Master节点故障，可能会有数据没有同步到Slave,导致消息丢失。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>消息复制方式是通过Broker配置文件里的brokerRole参数进行设置的，这个参数可以被设置成ASYNC_MASTER、 SYNC_MASTER、SLAVE三个值中的一个</p><h2 id="消息刷盘机制"><a href="#消息刷盘机制" class="headerlink" title="消息刷盘机制"></a>消息刷盘机制</h2><p>上面有副本同步方式，但只涉及到消息到服务端，此时消息并没有写入磁盘，写磁盘与另一个刷盘机制有关。</p><h3 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h3><p>在返回写成功状态时，消息已经被写入磁盘。</p><p>具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。</p><p>优势：数据更加完整，Slave有全部的数据备份，即使Master挂了也没事。</p><p>劣势：会增加数据写入延迟，降低系统吞吐量。</p><h3 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h3><p>在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</p><p>优势：数据写入延迟低，系统吞吐量高。</p><p>劣势：消息丢失可能性高。Master节点故障，可能会有数据没有同步到Slave,导致消息丢失。</p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>消息复制方式是通过Broker配置文件里的flushDiskType参数进行设置的，这个参数可以被设置成ASYNC_FLUSH：异步刷盘</p><p>SYNC_FLUSH：同步刷盘。</p><h2 id="生产者发送方式"><a href="#生产者发送方式" class="headerlink" title="生产者发送方式"></a>生产者发送方式</h2><h3 id="同步发送（等待消息返回继续操作）"><a href="#同步发送（等待消息返回继续操作）" class="headerlink" title="同步发送（等待消息返回继续操作）"></a>同步发送（等待消息返回继续操作）</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> MQClientException<span class="token punctuation">,</span> UnsupportedEncodingException<span class="token punctuation">,</span> RemotingException<span class="token punctuation">,</span> InterruptedException<span class="token punctuation">,</span> MQBrokerException <span class="token punctuation">{</span>    DefaultMQProducer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"sync_msg_simple_group"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"xx.xx.xx.xx:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String message <span class="token operator">=</span> <span class="token string">"Hello dm"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Message msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TopicSync"</span><span class="token punctuation">,</span><span class="token string">"TagS"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>message<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>RemotingHelper<span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SendResult sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s%n"</span><span class="token punctuation">,</span> sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="异步发送（消息发完直接进行后续操作，但会提供一个消息发送完成的回调方法）"><a href="#异步发送（消息发完直接进行后续操作，但会提供一个消息发送完成的回调方法）" class="headerlink" title="异步发送（消息发完直接进行后续操作，但会提供一个消息发送完成的回调方法）"></a>异步发送（消息发完直接进行后续操作，但会提供一个消息发送完成的回调方法）</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    DefaultMQProducer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"async_msg_simple_group"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"xx.xx.xx.xx:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置发送失败重试机制</span>    producer<span class="token punctuation">.</span><span class="token function">setRetryTimesWhenSendAsyncFailed</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String message <span class="token operator">=</span> <span class="token string">"Hello dm async "</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> messageCount <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>messageCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> messageCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>        Message msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">,</span><span class="token string">"TagSendOne"</span><span class="token punctuation">,</span><span class="token string">"OrderID188"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>message <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>RemotingHelper<span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//消息发送成功后，执行回调函数</span>        producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SendCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span>SendResult sendResult<span class="token punctuation">)</span> <span class="token punctuation">{</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-10d OK %s %n"</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> sendResult<span class="token punctuation">.</span><span class="token function">getMsgId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onException</span><span class="token punctuation">(</span>Throwable e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-10d Exception %s %n"</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="单向发送（消息发完就不管了）"><a href="#单向发送（消息发完就不管了）" class="headerlink" title="单向发送（消息发完就不管了）"></a>单向发送（消息发完就不管了）</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    DefaultMQProducer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"oneway_msg_simple_group"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"xx.xx.xx.xx:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String message <span class="token operator">=</span> <span class="token string">"Hello dm oneway "</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Message msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">,</span><span class="token string">"TagSendOne"</span><span class="token punctuation">,</span><span class="token string">"OrderID188"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>message <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>RemotingHelper<span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">sendOneway</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="消费者消费方式"><a href="#消费者消费方式" class="headerlink" title="消费者消费方式"></a>消费者消费方式</h2><h3 id="推模式-消费者等待Broker把消息推送过来"><a href="#推模式-消费者等待Broker把消息推送过来" class="headerlink" title="推模式(消费者等待Broker把消息推送过来)"></a>推模式(消费者等待Broker把消息推送过来)</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> MQClientException <span class="token punctuation">{</span>    DefaultMQPushConsumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"msg_simple_group"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"xx.xx.xx.xx:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"TopicStudent"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> ConsumeConcurrentlyStatus <span class="token function">consumeMessage</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>MessageExt<span class="token operator">></span> msgs<span class="token punctuation">,</span> ConsumeConcurrentlyContext context<span class="token punctuation">)</span>           <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>MessageExt msg <span class="token operator">:</span> msgs<span class="token punctuation">)</span><span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> ConsumeConcurrentlyStatus<span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="拉模式-消费者主动去Broker上拉取消息"><a href="#拉模式-消费者主动去Broker上拉取消息" class="headerlink" title="拉模式(消费者主动去Broker上拉取消息)"></a>拉模式(消费者主动去Broker上拉取消息)</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> MQClientException <span class="token punctuation">{</span>    DefaultMQPullConsumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPullConsumer</span><span class="token punctuation">(</span><span class="token string">"async_msg_simple_group"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"xx.Xx.Xx.Xx:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>MessageQueue<span class="token operator">></span> mqs <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">fetchSubscribeMessageQueues</span><span class="token punctuation">(</span><span class="token string">"TopicSync"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>MessageQueue mq <span class="token operator">:</span> mqs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consume from the queue: "</span> <span class="token operator">+</span> mq<span class="token punctuation">)</span><span class="token punctuation">;</span>        SINGLE_MQ<span class="token operator">:</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                PullResult pullResult <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">pullBlockIfNotFound</span><span class="token punctuation">(</span>mq<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token function">getMessageQueueOffset</span><span class="token punctuation">(</span>mq<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pullResult<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">putMessageQueueOffset</span><span class="token punctuation">(</span>mq<span class="token punctuation">,</span> pullResult<span class="token punctuation">.</span><span class="token function">getNextBeginOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">switch</span> <span class="token punctuation">(</span>pullResult<span class="token punctuation">.</span><span class="token function">getPullStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">case</span> FOUND<span class="token operator">:</span>                        List<span class="token operator">&lt;</span>MessageExt<span class="token operator">></span> messageExtList <span class="token operator">=</span> pullResult<span class="token punctuation">.</span><span class="token function">getMsgFoundList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>MessageExt m <span class="token operator">:</span> messageExtList<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> NO_MATCHED_MSG<span class="token operator">:</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> NO_NEW_MSG<span class="token operator">:</span>                        <span class="token keyword">break</span> SINGLE_MQ<span class="token punctuation">;</span>                    <span class="token keyword">case</span> OFFSET_ILLEGAL<span class="token operator">:</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">default</span><span class="token operator">:</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    consumer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>生产者往topic上面发送消息，消息会分配到不同的queue上，而且消费者消费消息也是一个队列取一个进行消费，这时候消费者消费消息就不是顺序的了，要想顺序消费就让它你想顺序的放在同一个队列上。消费者再注册MessageListenerOrderly，按队列消费，一个队列消费完在换下一个队列，这样消费就是顺序的。但是这样是局部有序，要想全局有序就让所有消息放在一个队列消费，但这样性能瓶颈会较大，一般局部有序就可以满足需求了。</p><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>这里的逻辑就是通过订单编号对mqs(队列个数)进行取模，分配到队列上去。这样就是相同订单编号进入相同队列</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        DefaultMQProducer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"ordered_group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"xx.xx.xx.xx:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> tags <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"TagA"</span><span class="token punctuation">,</span> <span class="token string">"TagC"</span><span class="token punctuation">,</span> <span class="token string">"TagD"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 订单列表</span>        List<span class="token operator">&lt;</span>OrderStep<span class="token operator">></span> orderList <span class="token operator">=</span> <span class="token function">buildOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SimpleDateFormat sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String dateStr <span class="token operator">=</span> sdf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 加个时间前缀</span>            String body <span class="token operator">=</span> dateStr <span class="token operator">+</span> <span class="token string">" Hello RocketMQ "</span><span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> orderList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            Message msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">,</span> tags<span class="token punctuation">[</span>i <span class="token operator">%</span> tags<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"KEY"</span> <span class="token operator">+</span> i<span class="token punctuation">,</span>                    body<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>RemotingHelper<span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            SendResult sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueueSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> MessageQueue <span class="token function">select</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>MessageQueue<span class="token operator">></span> mqs<span class="token punctuation">,</span> Message msg<span class="token punctuation">,</span> Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Long id <span class="token operator">=</span> <span class="token punctuation">(</span>Long<span class="token punctuation">)</span> arg<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//根据订单id选择发送queue</span>                    <span class="token keyword">long</span> index <span class="token operator">=</span> id <span class="token operator">%</span> mqs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> mqs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> orderList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrderId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//订单id</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"SendResult status:%s, queueId:%d, body:%s"</span><span class="token punctuation">,</span>                    sendResult<span class="token punctuation">.</span><span class="token function">getSendStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    sendResult<span class="token punctuation">.</span><span class="token function">getMessageQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueueId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 生成模拟订单数据     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>OrderStep<span class="token operator">></span> <span class="token function">buildOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>OrderStep<span class="token operator">></span> orderList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>OrderStep<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        OrderStep orderDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderStep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span>15103111039L<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setDesc</span><span class="token punctuation">(</span><span class="token string">"创建"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>orderDemo<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderStep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span>15103111065L<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setDesc</span><span class="token punctuation">(</span><span class="token string">"创建"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>orderDemo<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderStep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span>15103111039L<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setDesc</span><span class="token punctuation">(</span><span class="token string">"付款"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>orderDemo<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderStep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span>15103117235L<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setDesc</span><span class="token punctuation">(</span><span class="token string">"创建"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>orderDemo<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderStep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span>15103111065L<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setDesc</span><span class="token punctuation">(</span><span class="token string">"付款"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>orderDemo<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderStep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span>15103117235L<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setDesc</span><span class="token punctuation">(</span><span class="token string">"付款"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>orderDemo<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderStep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span>15103111065L<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setDesc</span><span class="token punctuation">(</span><span class="token string">"完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>orderDemo<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderStep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span>15103111039L<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setDesc</span><span class="token punctuation">(</span><span class="token string">"推送"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>orderDemo<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderStep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span>15103117235L<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setDesc</span><span class="token punctuation">(</span><span class="token string">"完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>orderDemo<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderStep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span>15103111039L<span class="token punctuation">)</span><span class="token punctuation">;</span>        orderDemo<span class="token punctuation">.</span><span class="token function">setDesc</span><span class="token punctuation">(</span><span class="token string">"购物车"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        orderList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>orderDemo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> orderList<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@ToString</span>    <span class="token annotation punctuation">@Data</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OrderStep</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">long</span> orderId<span class="token punctuation">;</span>        <span class="token keyword">private</span> String desc<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费者这里主要改动了监听的方法，消费者注册了监听-MessageListenerOrderly，可以顺序消费每一条队列</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        DefaultMQPushConsumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"ordered_group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"xx.xx.xx.xx:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 设置消费位置         */</span>        consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span>ConsumeFromWhere<span class="token punctuation">.</span>CONSUME_FROM_FIRST_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerOrderly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            AtomicLong consumeTimes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> ConsumeOrderlyStatus <span class="token function">consumeMessage</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>MessageExt<span class="token operator">></span> msgs<span class="token punctuation">,</span>                                                       ConsumeOrderlyContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>                context<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>MessageExt msg <span class="token operator">:</span> msgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 可以看到每个queue有唯一的consume来消费, 订单对每个queue(分区)有序</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"consumeThread="</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", queueId="</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span><span class="token function">getQueueId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", content:"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RemotingHelper<span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsupportedEncodingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//模拟业务逻辑处理中...</span>                    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> ConsumeOrderlyStatus<span class="token punctuation">.</span>SUCCESS<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Consumer Started.%n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h2><p>在其他的消息中间件中，对延迟消息都没有支持，只能通过其他的方法实现延迟队列，比如RabbitMQ一般通过TTL+死信或者延迟插件实现延迟队列。而RocketMQ原生支持延时队列,就是调用producer.send,消息不会直接发送出去而是会等待一段时间。不过开源版只支持18个级别；messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m<br>6m 7m 8m 9m 10m 20m 30m 1h 2h。商业版本是支持任意时刻的设置。</p><h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    DefaultMQProducer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"ExampleConsumer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"xx.xx.xx.xx:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> totalMessagesToSend <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> totalMessagesToSend<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Message message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TestTopic"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"Hello scheduled message "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//延时消费-设置延迟级别为6  2min</span>        message<span class="token punctuation">.</span><span class="token function">setDelayTimeLevel</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"message send is completed .%n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="广播消息"><a href="#广播消息" class="headerlink" title="广播消息"></a>广播消息</h2><p>集群消费模式下，每一条消息只会被一个消费组的一个消费者消费，而广播模式，是把消息发送给所有订阅了该Topic的消费者，不管消费者是不是同一个消费组。</p><h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> MQClientException <span class="token punctuation">{</span>    DefaultMQPushConsumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"please_rename_unique_group_name_1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"xx.xx.xx.xx:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span>ConsumeFromWhere<span class="token punctuation">.</span>CONSUME_FROM_LAST_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置为广播消息</span>    consumer<span class="token punctuation">.</span><span class="token function">setMessageModel</span><span class="token punctuation">(</span>MessageModel<span class="token punctuation">.</span>BROADCASTING<span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> ConsumeConcurrentlyStatus <span class="token function">consumeMessage</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>MessageExt<span class="token operator">></span> msgs<span class="token punctuation">,</span>                                                        ConsumeConcurrentlyContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s Receive New Messages: %s %n"</span><span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msgs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> ConsumeConcurrentlyStatus<span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Broadcast Consumer Started.%n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><p>批量消息是将多个消息组合成一条批量消息发送出去，是为了减少网络IO,提升系统吞吐量。</p><p>注意：官方对于批量消息大小的限制是1M，实际使用时，这个1MB的限制可以稍微扩大点，实际最大的限制是4194304字节，大概4MB。但是使用批量消息时，这个消息长度确实是必须考虑的一个问题。而且批量消息的使用是有一定限制的，这些消息应该有相同的Topic，相同的waitStoreMsgOK。而且不能是延迟消息、事务消息等。</p><h3 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    DefaultMQProducer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"batch_group"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"xx.xx.xx.xx:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String topic <span class="token operator">=</span> <span class="token string">"BatchTest"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 模拟消息</span>    List<span class="token operator">&lt;</span>Message<span class="token operator">></span> messages <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    messages<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token string">"TagA"</span><span class="token punctuation">,</span> <span class="token string">"OrderID001"</span><span class="token punctuation">,</span> <span class="token string">"Hello world 0"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    messages<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token string">"TagA"</span><span class="token punctuation">,</span> <span class="token string">"OrderID002"</span><span class="token punctuation">,</span> <span class="token string">"Hello world 1"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    messages<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token string">"TagA"</span><span class="token punctuation">,</span> <span class="token string">"OrderID003"</span><span class="token punctuation">,</span> <span class="token string">"Hello world 2"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ListSplitter splitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListSplitter</span><span class="token punctuation">(</span>messages<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 对批量消息进行拆分</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>splitter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>Message<span class="token operator">></span>  listItem <span class="token operator">=</span> splitter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>listItem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>消息拆分</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListSplitter</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Message<span class="token operator">>></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 一个批量消息大小</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIZE_LIMIT <span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1MB</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> List<span class="token operator">&lt;</span>Message<span class="token operator">></span> messages<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> currIndex<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ListSplitter</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Message<span class="token operator">></span> messages<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>messages <span class="token operator">=</span> messages<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> currIndex <span class="token operator">&lt;</span> messages<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Message<span class="token operator">></span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> nextIndex <span class="token operator">=</span> currIndex<span class="token punctuation">;</span>        <span class="token keyword">int</span> totalSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历消息准备拆分</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> nextIndex <span class="token operator">&lt;</span> messages<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> nextIndex<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Message message <span class="token operator">=</span> messages<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>nextIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> tmpSize <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>            Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> properties <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">getProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> properties<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                tmpSize <span class="token operator">+=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            tmpSize <span class="token operator">=</span> tmpSize <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//for log overhead</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpSize <span class="token operator">></span> SIZE_LIMIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">-</span> currIndex <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    nextIndex<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpSize <span class="token operator">+</span> totalSize <span class="token operator">></span> SIZE_LIMIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                totalSize <span class="token operator">+=</span> tmpSize<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        List<span class="token operator">&lt;</span>Message<span class="token operator">></span> subList <span class="token operator">=</span> messages<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span>currIndex<span class="token punctuation">,</span> nextIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        currIndex <span class="token operator">=</span> nextIndex<span class="token punctuation">;</span>        <span class="token keyword">return</span> subList<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h2><p>RocketMQ设计了很多种消息过滤方式，简单的一般可以用Tag进行过滤。复杂一点的可以使用参数过滤加SQL92.</p><p>消息过滤一般是在broker端进行过滤，性能上也是比较高的。</p><p>注意：推模式的消费者才可以使用SQL过滤，拉模式不可以</p><h3 id="SQL92语法"><a href="#SQL92语法" class="headerlink" title="SQL92语法"></a>SQL92语法</h3><ul><li>数值比较：比如：&gt;、&gt;=、&lt;、&lt;=、BETWEEN、=</li><li>字符比较：比如：=、&lt;&gt;、IN</li><li>空串判断：IS NULL 、 IS NOT NULL</li><li>逻辑符号：AND，OR，NOT；</li><li>常量支持类型为：<br>数值，比如：123，3.1415；<br>字符，比如：’abc’，必须用单引号包裹起来；<br>NULL，特殊的常量<br>布尔值，TRUE 或 FALSE</li></ul><h3 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    DefaultMQProducer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"please_rename_unique_group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"xx.xx.xx.xx:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> tags <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">"TagA"</span><span class="token punctuation">,</span> <span class="token string">"TagB"</span><span class="token punctuation">,</span> <span class="token string">"TagC"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Message msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"SqlFilterTest"</span><span class="token punctuation">,</span>                                  tags<span class="token punctuation">[</span>i <span class="token operator">%</span> tags<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">,</span>                                  <span class="token punctuation">(</span><span class="token string">"Hello RocketMQ "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>RemotingHelper<span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span>                                 <span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span><span class="token function">putUserProperty</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SendResult sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s%n"</span><span class="token punctuation">,</span> sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    DefaultMQPushConsumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"please_rename_unique_group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"xx.xx.xx.xx:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// SQL 过滤</span>    consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"SqlFilterTest"</span><span class="token punctuation">,</span>                       MessageSelector<span class="token punctuation">.</span><span class="token function">bySql</span><span class="token punctuation">(</span><span class="token string">"(TAGS is not null and TAGS in ('TagA', 'TagB'))"</span> <span class="token operator">+</span>                                             <span class="token string">"and (a is not null and a between 0 and 3)"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> ConsumeConcurrentlyStatus <span class="token function">consumeMessage</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>MessageExt<span class="token operator">></span> msgs<span class="token punctuation">,</span>                                                        ConsumeConcurrentlyContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s Receive New Messages: %s %n"</span><span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msgs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> ConsumeConcurrentlyStatus<span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Consumer Started.%n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    </code></pre><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>事务消息和延时消息一样都是RocketMQ特有的。事务消息官方解释是分布式系统中保持最终一致性的2阶段提交的消息实现。简单来说就是保证本地事务执行与发送消息到broker2个操作的原子性。</p><p>注：事务消息只保证消息发送者的本地事务与发消息这两个操作的原子性，因此，事务消息的只涉及到消息发送者。</p><h3 id="事务消息使用限制"><a href="#事务消息使用限制" class="headerlink" title="事务消息使用限制"></a><strong>事务消息使用限制</strong></h3><ol><li>事务消息不支持延迟消息和批量消息</li><li>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为15 次，但是用户可以通过 Broker 配置文件的 transactionCheckMax 参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N = transactionCheckMax ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 AbstractTransactionCheckListener 类来修改这个行为</li><li>事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 transactionMsgTimeout 参数</li><li>事务性消息可能不止一次被检查或消费</li><li>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制</li><li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者</li></ol><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20210107112452.png"></p><p>步骤：</p><ol><li>发送方将half事务消息发送到broker</li><li>broker把消息持久化成功，向发送方返回ACK确认收到消息。</li><li>发送方开始执行本地事务</li><li>发送方根据本地事务执行结果向broker发送二次确认</li><li>broker收到发送方commit状态则将half事务消息标记为可投递，订阅方可以收到消息。。发送方rollback状态，则删除half事务消息。。如果步骤4的二次确认没有发送到broker则会过一段时间broker会对发送方进行消息回查，发送方收到消息回查，检查对应消息的本地事务执行结果。发送方根据回查结果继续步骤5。</li></ol><h3 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> MQClientException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        TransactionListener transactionListener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransactionListenerImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TransactionMQProducer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransactionMQProducer</span><span class="token punctuation">(</span><span class="token string">"please_rename_unique_group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"xx.xx.xx.Xx:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ExecutorService executorService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>                thread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"client-transaction-msg-check-thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> thread<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">setExecutorService</span><span class="token punctuation">(</span>executorService<span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">setTransactionListener</span><span class="token punctuation">(</span>transactionListener<span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> tags <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">"TagA"</span><span class="token punctuation">,</span> <span class="token string">"TagB"</span><span class="token punctuation">,</span> <span class="token string">"TagC"</span><span class="token punctuation">,</span> <span class="token string">"TagD"</span><span class="token punctuation">,</span> <span class="token string">"TagE"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Message msg <span class="token operator">=</span>                    <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">,</span> tags<span class="token punctuation">[</span>i <span class="token operator">%</span> tags<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"KEY"</span> <span class="token operator">+</span> i<span class="token punctuation">,</span>                        <span class="token punctuation">(</span><span class="token string">"Hello RocketMQ "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>RemotingHelper<span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                SendResult sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">sendMessageInTransaction</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s%n"</span><span class="token punctuation">,</span> sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MQClientException</span> <span class="token operator">|</span> UnsupportedEncodingException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionListenerImpl</span> <span class="token keyword">implements</span> <span class="token class-name">TransactionListener</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 在提交完事务消息后执行。     * 返回COMMIT_MESSAGE状态的消息会立即被消费者消费到。     * 返回ROLLBACK_MESSAGE状态的消息会被丢弃。     * 返回UNKNOWN状态的消息会由Broker过一段时间再来回查事务的状态。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> LocalTransactionState <span class="token function">executeLocalTransaction</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String tags <span class="token operator">=</span> msg<span class="token punctuation">.</span><span class="token function">getTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//TagA的消息会立即被消费者消费到</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>tags<span class="token punctuation">,</span> <span class="token string">"TagA"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> LocalTransactionState<span class="token punctuation">.</span>COMMIT_MESSAGE<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//TagB的消息会被丢弃</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>tags<span class="token punctuation">,</span> <span class="token string">"TagB"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> LocalTransactionState<span class="token punctuation">.</span>ROLLBACK_MESSAGE<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//其他消息会等待Broker进行事务状态回查。</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> LocalTransactionState<span class="token punctuation">.</span>UNKNOW<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 在对UNKNOWN状态的消息进行状态回查时执行。返回的结果是一样的。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> LocalTransactionState <span class="token function">checkLocalTransaction</span><span class="token punctuation">(</span>MessageExt msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String tags <span class="token operator">=</span> msg<span class="token punctuation">.</span><span class="token function">getTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//TagC的消息过一段时间会被消费者消费到</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>tags<span class="token punctuation">,</span> <span class="token string">"TagC"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> LocalTransactionState<span class="token punctuation">.</span>COMMIT_MESSAGE<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//TagD的消息也会在状态回查时被丢弃掉</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>tags<span class="token punctuation">,</span> <span class="token string">"TagD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> LocalTransactionState<span class="token punctuation">.</span>ROLLBACK_MESSAGE<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//剩下TagE的消息会在多次状态回查后最终丢弃</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> LocalTransactionState<span class="token punctuation">.</span>UNKNOW<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> Java </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ集群搭建</title>
      <link href="2020/12/28/rocketmq-an-zhuang/"/>
      <url>2020/12/28/rocketmq-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>java版本：1.8</p><p>操作系统：CentOS7</p><p>安装包：<a href="https://rocketmq.apache.org/dowloading/releases/">https://rocketmq.apache.org/dowloading/releases/</a></p><p>我这里选择的是4.7.1版本的rocketMQ</p><h2 id="RocketMQ-集群搭建"><a href="#RocketMQ-集群搭建" class="headerlink" title="RocketMQ 集群搭建"></a>RocketMQ 集群搭建</h2><p>注：此集群主从之间不会自动选举，也就是说主节点挂了，从节点不会顶上去</p><p>目标：2主2从异步集群</p><p>需要2台机器，具体配置下表</p><table><thead><tr><th>机器</th><th>nameserver节点</th><th>broker主</th><th>broker从</th></tr></thead><tbody><tr><td>机器1</td><td>nameserver</td><td>broker-a</td><td>broker-b-s</td></tr><tr><td>机器2</td><td>nameserver</td><td>broker-b</td><td>broker-a-s</td></tr></tbody></table><p>安装包解压（这里的安装包是zip格式的，所以使用unzip）</p><pre class=" language-shell"><code class="language-shell">unzip rocketmq-all-4.7.1-bin-release.zip -d /</code></pre><p>增加软链接（纯粹为了方便，不影响安装）</p><pre class=" language-shell"><code class="language-shell">ln -s rocketmq-all-4.7.1-bin-release/ rocketmq</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>这里先解释下配置文件各参数意义</p><pre class=" language-shell"><code class="language-shell">#所属集群名字，名字一样的节点就在同一个集群内brokerClusterName=rocketmq-cluster#broker名字，名字一样的节点就是一组主从节点。brokerName=broker-a#brokerid,0就表示是Master，>0的都是表示 SlavebrokerId=0#nameServer地址，分号分割namesrvAddr=192.168.186.131:9876;192.168.186.132:9876#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=true#Broker 对外服务的监听端口listenPort=10911#删除文件时间点，默认凌晨 4点deleteWhen=04#文件保留时间，默认 48 小时fileReservedTime=120#commitLog每个文件的大小默认1GmapedFileSizeCommitLog=1073741824#ConsumeQueue每个文件默认存30W条，根据业务情况调整mapedFileSizeConsumeQueue=300000#destroyMapedFileIntervalForcibly=120000#redeleteHangedFileInterval=120000#检测物理文件磁盘空间diskMaxUsedSpaceRatio=88#存储路径storePathRootDir=/data/rocketmq/store-a-master#commitLog 存储路径storePathCommitLog=/data/rocketmq/store-a-master/commitlog#消费队列存储路径存储路径storePathConsumeQueue=/data/rocketmq/store-a-master/consumequeue#消息索引存储路径storePathIndex=/data/rocketmq/store-a-master/index#checkpoint 文件存储路径storeCheckpoint=/data/rocketmq/store-a-master/checkpoint#abort 文件存储路径abortFile=/data/rocketmq/store-a-master/abort#限制的消息大小maxMessageSize=65536#flushCommitLogLeastPages=4#flushConsumeQueueLeastPages=2#flushCommitLogThoroughInterval=10000#flushConsumeQueueThoroughInterval=60000#Broker 的角色#- ASYNC_MASTER 异步复制Master#- SYNC_MASTER 同步双写Master#- SLAVEbrokerRole=ASYNC_MASTER#刷盘方式#- ASYNC_FLUSH 异步刷盘#- SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH#checkTransactionMessageEnable=false#发消息线程池数量#sendMessageThreadPoolNums=128#拉消息线程池数量#pullMessageThreadPoolNums=128</code></pre><p>这里我们直接更改它原来的配置文件，由于我们要搭建的是<strong>2主2从异步刷盘集群</strong>。所以我们进入2m-2s-async目录，并对当前目录的配置参数进行修改。其实直接启动应该也是没有问题的</p><pre class=" language-shell"><code class="language-shell">[root@localhost 2m-2s-async]# pwd/rocketmq/conf/2m-2s-async</code></pre><p>下面是配置参数：这里主要修改了以下几个参数brokerName（主从相同），brokerId（主0从1），listenPort同一主机不同，文件路径区分不同</p><p>broker-a.properties</p><pre class=" language-shell"><code class="language-shell">brokerClusterName=rocketmq-clusterbrokerName=broker-abrokerId=0namesrvAddr=192.168.186.131:9876;192.168.186.132:9876defaultTopicQueueNums=4autoCreateTopicEnable=trueautoCreateSubscriptionGroup=truelistenPort=10911deleteWhen=04fileReservedTime=120mapedFileSizeCommitLog=1073741824mapedFileSizeConsumeQueue=300000diskMaxUsedSpaceRatio=88storePathRootDir=/data/rocketmq/store-a-masterstorePathCommitLog=/data/rocketmq/store-a-master/commitlogstorePathConsumeQueue=/data/rocketmq/store-a-master/consumequeuestorePathIndex=/data/rocketmq/store-a-master/indexstoreCheckpoint=/data/rocketmq/store-a-master/checkpointabortFile=/data/rocketmq/store-a-master/abortmaxMessageSize=65536brokerRole=ASYNC_MASTERflushDiskType=ASYNC_FLUSH</code></pre><p>broker-b-s.properties</p><pre class=" language-shell"><code class="language-shell">brokerClusterName=rocketmq-clusterbrokerName=broker-bbrokerId=1namesrvAddr=192.168.186.131:9876;192.168.186.132:9876defaultTopicQueueNums=4autoCreateTopicEnable=trueautoCreateSubscriptionGroup=truelistenPort=10912deleteWhen=04fileReservedTime=120mapedFileSizeCommitLog=1073741824mapedFileSizeConsumeQueue=300000 diskMaxUsedSpaceRatio=88storePathRootDir=/data/rocketmq/store-b-slavestorePathCommitLog=/data/rocketmq/store-b-slave/commitlogstorePathConsumeQueue=/data/rocketmq/store-b-slave/consumequeuestorePathIndex=/data/rocketmq/store-b-slave/indexstoreCheckpoint=/data/rocketmq/store-b-slave/checkpointabortFile=/data/rocketmq/store-b-slave/abortmaxMessageSize=65536brokerRole=ASYNC_MASTERflushDiskType=ASYNC_FLUSH</code></pre><p>broker-a-s.properties</p><pre class=" language-shell"><code class="language-shell">brokerClusterName=rocketmq-clusterbrokerName=broker-abrokerId=1namesrvAddr=192.168.186.131:9876;192.168.186.132:9876defaultTopicQueueNums=4autoCreateTopicEnable=trueautoCreateSubscriptionGroup=truelistenPort=10911deleteWhen=04fileReservedTime=120mapedFileSizeCommitLog=1073741824mapedFileSizeConsumeQueue=300000diskMaxUsedSpaceRatio=88storePathRootDir=/data/rocketmq/store-a-slavestorePathCommitLog=/data/rocketmq/store-a-slave/commitlogstorePathConsumeQueue=/data/rocketmq/store-a-slave/consumequeuestorePathIndex=/data/rocketmq/store-a-slave/indexstoreCheckpoint=/data/rocketmq/store-a-slave/checkpointabortFile=/data/rocketmq/store-a-slave/abortmaxMessageSize=65536brokerRole=ASYNC_MASTERflushDiskType=ASYNC_FLUSH</code></pre><p>broker-b.properties</p><pre class=" language-shell"><code class="language-shell">brokerClusterName=rocketmq-clusterbrokerName=broker-bbrokerId=0namesrvAddr=192.168.186.131:9876;192.168.186.132:9876defaultTopicQueueNums=4autoCreateTopicEnable=trueautoCreateSubscriptionGroup=truelistenPort=10912deleteWhen=04fileReservedTime=120mapedFileSizeCommitLog=1073741824mapedFileSizeConsumeQueue=300000 diskMaxUsedSpaceRatio=88storePathRootDir=/data/rocketmq/store-b-masterstorePathCommitLog=/data/rocketmq/store-b-master/commitlogstorePathConsumeQueue=/data/rocketmq/store-b-master/consumequeuestorePathIndex=/data/rocketmq/store-b-master/indexstoreCheckpoint=/data/rocketmq/store-b-master/checkpointabortFile=/data/rocketmq/store-b-master/abortmaxMessageSize=65536brokerRole=ASYNC_MASTERflushDiskType=ASYNC_FLUSH</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>注意：启动前需要修改runbroker.sh和runserver.sh中的JVM参数，默认rocketmq给的nameserver4g，broker8g,不修改可能机器内存不够启动报错。机器内存足够的话尽量不改，默认配置是经过实验室测试较优配置。</p><p>后台启动nameserver(2台机器全部启动)</p><pre class=" language-shell"><code class="language-shell">nohup bin/mqnamesrv &</code></pre><p>启动成功标识</p><pre class=" language-shell"><code class="language-shell">### 启动成功标识cat nohup.outJava HotSpot(TM) 64-Bit Server VM warning: Using the DefNew young collector with the CMS collector is deprecated and will likely be removed in a future releaseJava HotSpot(TM) 64-Bit Server VM warning: UseCMSCompactAtFullCollection is deprecated and will likely be removed in a future release.The Name Server boot success. serializeType=JSON</code></pre><p>启动每台机器的broker</p><pre class=" language-shell"><code class="language-shell">nohup bin/mqbroker -c conf/2m-2s-async/xxx.properties &</code></pre><h3 id="默认测试工具验证"><a href="#默认测试工具验证" class="headerlink" title="默认测试工具验证"></a>默认测试工具验证</h3><p>首先需要配置nameserver</p><pre class=" language-shell"><code class="language-shell">vim tools.sh# 在export JAVA_HOME上面添加如下这段代码export NAMESRV_ADDR='192.168.186.131:9876;192.168.186.132:9876'</code></pre><p>生产者发送消息</p><pre class=" language-shell"><code class="language-shell">bin/tools.sh org.apache.rocketmq.example.quickstart.Producer </code></pre><p>消费消息</p><pre class=" language-shell"><code class="language-shell">bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</code></pre><h2 id="管理控制台搭建"><a href="#管理控制台搭建" class="headerlink" title="管理控制台搭建"></a>管理控制台搭建</h2><p>RocketMQ和RabbitMQ不同,没有官方的管理控制台,但是Rocket的社区扩展项目中提供了一个控制台。</p><p>地址：<a href="https://github.com/apache/rocketmq-externals">https://github.com/apache/rocketmq-externals</a></p><h3 id="前期maven准备"><a href="#前期maven准备" class="headerlink" title="前期maven准备"></a>前期maven准备</h3><p>地址：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p><pre><code>tar -zxvf apache-maven-3.6.3-bin.tar.gz -C /mv /apache-maven-3.6.3/ /usr/local/maven</code></pre><pre class=" language-shell"><code class="language-shell">vim /etc/profile### 增加代码export MAVEN_HOME=/usr/local/maven在PATH后追加： :$MAVEN_HOME/bin ### 刷新配置source /etc/profile### 验证mvn -v</code></pre><h3 id="控制台安装"><a href="#控制台安装" class="headerlink" title="控制台安装"></a>控制台安装</h3><p>解压</p><pre class=" language-shell"><code class="language-shell">unzip rocketmq-externals-master.zip -d /</code></pre><p>软链接</p><pre class=" language-shell"><code class="language-shell">ln -s /rocketmq-externals-master/ rocketmq-console</code></pre><p>搭建</p><pre class=" language-shell"><code class="language-shell">### 指定nameserver地址；；修改当前application.properties配置参数rocketmq.config.namesrvAddr=192.168.186.131:9876;192.168.186.132:9876cd /rocketmq-console/rocketmq-consolemvn clean package -Dmaven.test.skip=true### rocketmq-console-ng-1.0.1.jar----target目录下java -jar rocketmq-console-ng-1.0.1.jar</code></pre><p>在当前ip:8080上即可访问</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安装手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装 </tag>
            
            <tag> Linux </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper安装及常用命令</title>
      <link href="2020/12/04/zookeeper-an-zhuang/"/>
      <url>2020/12/04/zookeeper-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>发现zookeeper3.5.3之后出了许多新特性，就趁此时机安装一下较新版本zookeeper，顺便记录一下安装步骤，方便以后查验。</p><p>首先准备zookeeper,在这里我使用的是centos7，java环境是1.8.安装的zookeeper是3.5.8.首先找到对应版本下载。</p><h2 id="ZooKeeper单机安装"><a href="#ZooKeeper单机安装" class="headerlink" title="ZooKeeper单机安装"></a>ZooKeeper单机安装</h2><p>下载解压zookeeper</p><p>我这里直接从github上面下载对应的源码包，rz命令上传</p><p>地址：<a href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a></p><p>rz/sz安装命令</p><pre class=" language-shell"><code class="language-shell">yum install lrzsz</code></pre><p>安装包解压</p><pre class=" language-shell"><code class="language-shell">tar -zxvf apache-zookeeper-3.5.8-bin.tar.gz -C /</code></pre><p>增加软链接（纯粹为了方便，不影响安装）</p><pre class=" language-shell"><code class="language-shell">ln -s /apache-zookeeper-3.5.8-bin/ /zk</code></pre><p>进入zk目录，重命名配置文件</p><pre class=" language-shell"><code class="language-shell">cp conf/zoo_sample.cfg conf/zoo.cfg</code></pre><p>启动zookeeper</p><pre class=" language-shell"><code class="language-shell">./bin/zkServer.sh start ./conf/zoo.cfg</code></pre><p>连接zk服务端</p><pre class=" language-shell"><code class="language-shell">./bin/zkCli.sh -server 127.0.0.1:2181</code></pre><p>至此zookeeper安装完毕</p><h2 id="ZooKeeper集群安装"><a href="#ZooKeeper集群安装" class="headerlink" title="ZooKeeper集群安装"></a>ZooKeeper集群安装</h2><p>为了方便这里我直接安装的是伪集群，集群架构1主2从1观察者，总共4个节点</p><p>步骤和上面单机一样，不过我们这里需要4个配置文件，并修改配置</p><p>复制4个配置文件</p><pre class=" language-shell"><code class="language-shell">cp conf/zoo.cfg conf/zoo1.cfgcp conf/zoo.cfg conf/zoo2.cfgcp conf/zoo.cfg conf/zoo3.cfgcp conf/zoo.cfg conf/zoo4.cfg</code></pre><p>修改配置</p><pre class=" language-shell"><code class="language-shell">tickTime=2000initLimit=10syncLimit=5# dataDir修改配置为/zk/data1,/zk/data2,/zk/data3,/zk/data4dataDir=/zk/data1# clientPort修改配置为2181,2182,2183,2184clientPort=2181server.1=127.0.0.1:2001:3001server.2=127.0.0.1:2002:3002server.3=127.0.0.1:2003:3003server.4=127.0.0.1:2004:3004:observer</code></pre><p>创建4个目录，就是上面的dataDir目录</p><pre class=" language-shell"><code class="language-shell">mkdir data1mkdir data2mkdir data3mkdir data4</code></pre><p>创建文件myid,标识服务server id</p><pre class=" language-shell"><code class="language-shell">echo 1 > data1/myidecho 2 > data2/myidecho 3 > data3/myidecho 4 > data4/myid</code></pre><p>启动4个实例</p><pre class=" language-shell"><code class="language-shell">./bin/zkServer.sh start conf/zoo1.cfg./bin/zkServer.sh start conf/zoo2.cfg./bin/zkServer.sh start conf/zoo3.cfg./bin/zkServer.sh start conf/zoo4.cfg</code></pre><p>可查询状态</p><pre class=" language-shell"><code class="language-shell">./bin/zkServer.sh status conf/zoo1.cfg ./bin/zkServer.sh status conf/zoo2.cfg./bin/zkServer.sh status conf/zoo3.cfg./bin/zkServer.sh status conf/zoo4.cfg# 状态返回依次ZooKeeper JMX enabled by defaultUsing config: conf/zoo1.cfgClient port found: 2181. Client address: localhost.Mode: follower#========================ZooKeeper JMX enabled by defaultUsing config: conf/zoo2.cfgClient port found: 2182. Client address: localhost.Mode: leader#========================ZooKeeper JMX enabled by defaultUsing config: conf/zoo3.cfgClient port found: 2183. Client address: localhost.Mode: follower#========================ZooKeeper JMX enabled by defaultUsing config: conf/zoo4.cfgClient port found: 2184. Client address: localhost.Mode: observer#========================</code></pre><p>从状态返回很明显1,3节点为follower,2节点为leader,4节点为observer</p><p>连接服务端</p><pre class=" language-shell"><code class="language-shell">./bin/zkCli.sh -server 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183,127.0.0.1:2184</code></pre><h2 id="启动参数配置"><a href="#启动参数配置" class="headerlink" title="启动参数配置"></a>启动参数配置</h2><p>启动参数都是在zkServer.sh里面的ZOOMAIN参数里面配置</p><pre class=" language-shell"><code class="language-shell">ZOOMAIN="-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=$JMXLOCALONLY org.apache.zookeeper.server.quorum.QuorumPeerMain"</code></pre><h3 id="TTL节点"><a href="#TTL节点" class="headerlink" title="TTL节点"></a>TTL节点</h3><p>ttl节点默认是禁止的。如果要想使用ttl节点必须在启动参数配置</p><p>没有开启的情况</p><pre class=" language-shell"><code class="language-shell">[zk: 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183,127.0.0.1:2184(CONNECTED) 0] create -t 500 /tsetttlKeeperErrorCode = Unimplemented for /tsetttl</code></pre><p>开启需要在启动配置加  <strong>-Dzookeeper.extendedTypesEnabled=true</strong></p><h2 id="ACL超级管理员配置"><a href="#ACL超级管理员配置" class="headerlink" title="ACL超级管理员配置"></a>ACL超级管理员配置</h2><p>配置参数 <strong>-Dzookeeper.skipACL=yes</strong>可以跳过权限验证，一般安全就配置为false</p><p>获取加密密文</p><pre class=" language-shell"><code class="language-shell">echo -n zk:123456 | openssl dgst -binary -sha1 | openssl base64# 返回值N0YquoLgOZWu74hzsd3OJTZZUw0=</code></pre><p>启动脚本添加**-Dzookeeper.DigestAuthenticationProvider.superDigest=zk:N0YquoLgOZWu74hzsd3OJTZZUw0=**</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安装手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装 </tag>
            
            <tag> Linux </tag>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unsafe魔法类解析及应用</title>
      <link href="2020/11/05/atomic-unsafe-mo-fa-lei/"/>
      <url>2020/11/05/atomic-unsafe-mo-fa-lei/</url>
      
        <content type="html"><![CDATA[<p>Unsafe类提供了一些极度不安全的方法，这些方法会直接访问系统内存和对系统内存进行操作。，由于它是直接对内存进行的操作，所以从他的命名也可以看出它是不安全的。Unsafe类的使用必须<strong>慎重</strong>；juc包中大量运用了Unsafe类，对Unsafe的了解也会方便与了解juc的一些类，即使一般情况下我们不使用这个类，但我们也有必要对其进行理解。</p><p>Unsafe的API的分类大致是内存操作，CAS，内存屏障，线程调度；</p><h2 id="Unsafe类的使用"><a href="#Unsafe类的使用" class="headerlink" title="Unsafe类的使用"></a>Unsafe类的使用</h2><p>Unsafe方法是单例的，要想使用Unsafe首先需要调用Unsafe类的getUnsafe方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe theUnsafe<span class="token punctuation">;</span><span class="token annotation punctuation">@CallerSensitive</span><span class="token keyword">public</span> <span class="token keyword">static</span> Unsafe <span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Class <span class="token class-name">var0</span> <span class="token operator">=</span> Reflection<span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>VM<span class="token punctuation">.</span><span class="token function">isSystemDomainLoader</span><span class="token punctuation">(</span>var0<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SecurityException</span><span class="token punctuation">(</span><span class="token string">"Unsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> theUnsafe<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从上面代码**!VM.isSystemDomainLoader(var0.getClassLoader())**</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isSystemDomainLoader</span><span class="token punctuation">(</span>ClassLoader var0<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> var0 <span class="token operator">==</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看出如果你调用Unsafe类必须保证Unsafe类是系统类加载器（系统类加载器ClassLoader==null,因为系统类加载器是由C加载的）去加载的。直接调用getUnsafe会报错。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 调用结果</span>Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>SecurityException<span class="token operator">:</span> Unsafe    at sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span>Unsafe<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">90</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>dm<span class="token punctuation">.</span>jmm<span class="token punctuation">.</span>util<span class="token punctuation">.</span>test<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">33</span><span class="token punctuation">)</span></code></pre><p>通过资料发现Unsafe的使用有2种方法</p><ol><li><p>通过Java命令行命令<code>-Xbootclasspath/a: ${path}</code>把调用Unsafe相关方法的类test所在jar包路径追加到默认的bootstrap路径中，使得test被引导类加载器加载，从而通过<code>Unsafe.getUnsafe</code>方法安全的获取Unsafe实例。</p></li><li><p>通过反射拿取，<strong>下面的应用皆用这种方式</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Unsafe <span class="token function">reflectGetUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Field field <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"theUnsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>Unsafe<span class="token punctuation">)</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>先简单介绍一下内存屏障吧。内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。</p><p>还记得之前JMM模型是如何禁止重排序的吗，里面有详细介绍了内存屏障包括volatile触发内存屏障。<a href="https://dmsupine.com/2020/10/26/java-guan-jian-zi-synchronized-volatile/">Java关键字系列（一）-synchronized与volatile</a></p><p>在这里我们可以使用Unsafe手动设置内存屏障。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">loadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">storeFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//内存屏障，禁止load、store操作重排序</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">fullFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以之前举例证明重排序存在的代码为例，之前是通过添加volatile可以解决，现在通过手动添加内存屏障解决</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">test</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">shortWait</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 添加屏障代码，需引入上面通过反射拿取Unsafe类</span>                    UnsafeInstance<span class="token punctuation">.</span><span class="token function">reflectGetUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fullFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    x <span class="token operator">=</span> b<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 添加屏障代码，需引入上面通过反射拿取Unsafe类</span>                    UnsafeInstance<span class="token punctuation">.</span><span class="token function">reflectGetUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fullFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    y <span class="token operator">=</span> a<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String result <span class="token operator">=</span> <span class="token string">"第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"次 ("</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> y <span class="token operator">+</span> <span class="token string">"）"</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 等待一段时间，时间单位纳秒     * @param interval     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shortWait</span><span class="token punctuation">(</span><span class="token keyword">long</span> interval<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> end<span class="token punctuation">;</span>        <span class="token keyword">do</span><span class="token punctuation">{</span>            end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>start <span class="token operator">+</span> interval <span class="token operator">>=</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>现在这段代码运行就不会结束了，证明内存屏障设置成功了。</p><h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2><p>Unsafe相关的内存操作都是与堆外内存相关，包括堆外内存的分配，释放，拷贝等等。</p><h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>大家都知道Java 对象基本都是存放在堆或者栈上面的，它们的分配，释放都是依靠JVM来解决的。但在我们的Java中有一种内存叫做堆外内存，这部分内存不被JVM所托管。元空间的内存就是堆外内存，所以如果我们不设置**-XX：MaxMetaspaceSize**参数，由于它是堆外内存就有可能导致元空间内存不断往上加，最后可能撑爆系统内存（堆外内存不受JVM内存管理，它依托的是系统内存）。</p><p>而对堆外内存的操作我们通常是使用Unsafe类操作，这种操作危险。如果代码内存溢出，可能会把服务器内存打宕掉。<strong>这里一定得注意内存的释放。</strong></p><p><strong>Q:既然JVM可以管理内存，为什么我们会有使用堆外内存的需求呢？</strong></p><ol><li>减少GC次数，避免垃圾回收停顿对应用程序的影响。JVM是有GC机制的。如果我们操作的一个内存是比较大的，可能会频繁GC。但我们使用堆外内存（不受JVM控制），会有效的减少GC的STW。</li><li>提升程序I/O操作的性能。在I/O通信过程中，有堆内内存-&gt;堆外内存的数据拷贝操作，如果有这种需求我们可以直接把数据存储到堆外内存，减少堆内内存到堆外内存的时间，提升IO性能。这也是零拷贝的思想，在Netty和RocketMQ都有应用。关于零拷贝的详细可见<a href="https://dmsupine.com/2020/09/07/netty-xian-cheng-mo-xing-chu-tan-he-netty-de-chang-jian-wen-ti/">Netty线程模型初探和Netty的常见问题</a></li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//分配内存, 相当于C++的malloc函数</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">allocateMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//扩充内存</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">reallocateMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> address<span class="token punctuation">,</span> <span class="token keyword">long</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//释放内存</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在给定的内存块中设置值</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">setMemory</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">long</span> bytes<span class="token punctuation">,</span> <span class="token keyword">byte</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//内存拷贝</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">copyMemory</span><span class="token punctuation">(</span>Object srcBase<span class="token punctuation">,</span> <span class="token keyword">long</span> srcOffset<span class="token punctuation">,</span> Object destBase<span class="token punctuation">,</span> <span class="token keyword">long</span> destOffset<span class="token punctuation">,</span> <span class="token keyword">long</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等</span><span class="token keyword">public</span> <span class="token keyword">native</span> Object <span class="token function">getObject</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有: putInt,putDouble，putLong，putChar等</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">putObject</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> Object x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取给定地址的byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的）</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">byte</span> <span class="token function">getByte</span><span class="token punctuation">(</span><span class="token keyword">long</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的）</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">putByte</span><span class="token punctuation">(</span><span class="token keyword">long</span> address<span class="token punctuation">,</span> <span class="token keyword">byte</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS全称CompareAndSwap，从名字就可以看出它是什么作用了，就是比较和交换。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 下面几个方法作用一样</span><span class="token comment" spellcheck="true">// 介绍一下参数值0--修改field的对象，offset--对象中某field的偏移量，expected--期望值，update--更新值</span><span class="token comment" spellcheck="true">// 他的操作就是将内存位置的值和expected进行比较，是不是一样，一样就把update和当前内存位置的值进行交换</span><span class="token comment" spellcheck="true">// 整个过程是原子的。</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span>  Object expected<span class="token punctuation">,</span> Object update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> expected<span class="token punctuation">,</span><span class="token keyword">int</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">long</span> expected<span class="token punctuation">,</span> <span class="token keyword">long</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>CAS在整个juc中应用是最为广泛的，比如AQS,Atomic等等，可能就是因为他是原子的所以才会在并发包中得到这么广泛的应用吧。其实他整个操作都是基于offset进行操作的，offset可以使用unsafe的objectFieldOffset获取。通过offset就可以找到内存地址，我们在从内存地址中获取这个值，拿到值就跟期望值expected进行比较，如果一样就把更新值update赋值到这个地址上去。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> Atomic </tag>
            
            <tag> Unsafe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java关键字系列（一）-synchronized与volatile</title>
      <link href="2020/10/26/java-guan-jian-zi-synchronized-volatile/"/>
      <url>2020/10/26/java-guan-jian-zi-synchronized-volatile/</url>
      
        <content type="html"><![CDATA[<p>Java中有许多关键字，比如synchronized，volatile，transient，final，static，native等等，在这里我想针对对这些关键字进行一个统一的了解，并做一个系列。</p><p>在这些关键字中与并发息息相关的就是synchronized和volatile，在了解这2个关键字首先必须了解一个模型就是JMM模型。但是在了解JMM模型前需要先了解下硬件内存架构。</p><h2 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h2><p>大家都知道现代计算机CPU与内存处理速度相差是极大的。这样就会导致一个局面是处理器等内存的数据，这样就发挥不出来CPU的优势。所以我们CPU为了解决这种差距就使用了多级缓存架构。在我们的CPU中都是有L1,L2,L3三级缓存。将运算的数据从内存写到缓存中去，CPU把数据处理完成，再讲数据写回到主内存去。但这样有一个问题就是缓存不一致的问题，试想如果程序是高并发的就会出现多个CPU同时操作主内存导致不同处理器数据不一致的问题，CPU解决这个问题使用了MESI缓存一致性协议。</p><h2 id="JMM模型"><a href="#JMM模型" class="headerlink" title="JMM模型"></a>JMM模型</h2><p>JMM全称叫做Java内存模型，他与JVM内存模型是不一样的，JVM内存模型是针对于内存区域的划分，而JMM模型是一种抽象概念，它描述的是一个变量在主内存与工作内存中的访问方式。下面就是JMM内存模型图。</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20201026162328.png" alt="JMM内存模型图"></p><p>Q:从这张图我们可以简单的看出线程间是如何通信的。假设现在有一个变量a,我们要对其进行修改，修改完之后我们怎么告诉线程B我改了呢？</p><p>A:首先线程A会从主内存中取出变量a,复制到工作内存，然后在工作内存中进行修改，修改完之后将数据同步回主内存，线程B再从主内存中取值。这就是线程间通信的基本过程。</p><p>其实在线程间通信，主要依赖于8种操作。</p><table><thead><tr><th align="center">操作</th><th align="center">作用域</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><strong>read</strong> 读取</td><td align="center">主内存</td><td align="center">它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</td></tr><tr><td align="center"><strong>load</strong> 加载</td><td align="center">工作内存</td><td align="center">它把read操作从主内存中得到的变量值放入工作内存的变量副本中</td></tr><tr><td align="center"><strong>user</strong> 使用</td><td align="center">工作内存</td><td align="center">它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要<br>使用到变量的值的字节码指令时将会执行这个操作</td></tr><tr><td align="center"><strong>assign</strong> 赋值</td><td align="center">工作内存</td><td align="center">它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给<br>变量赋值的字节码指令时执行这个操作</td></tr><tr><td align="center"><strong>store</strong> 存储</td><td align="center">工作内存</td><td align="center">它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用</td></tr><tr><td align="center"><strong>write</strong> 写入</td><td align="center">主内存</td><td align="center"></td></tr><tr><td align="center"><strong>lock</strong> 锁定</td><td align="center">主内存</td><td align="center">它把一个变量标识为一条线程独占的状态</td></tr><tr><td align="center"><strong>unlock</strong> 解锁</td><td align="center">主内存</td><td align="center">它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</td></tr></tbody></table><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20201026170259.png"></p><p>JMM主要解决的问题是原子性，可见性，有序性</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指一个操作不可被中断，即使是多线程环境下，他的操作也是不可以中断，比如大家都知道i++就不是原子性的，因为简单的i++代码在底层字节码层面是有三步操作的（下面代码有所说明）。他们会在这3步操作中发生线程时间片轮转调度机制在3步中发生，它的i++操作就被打断了。这就违反了原子性。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// javap 反编译 对应字节码</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">com<span class="token punctuation">.</span>dm<span class="token punctuation">.</span>jmm<span class="token punctuation">.</span>util<span class="token punctuation">.</span>test</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> com<span class="token punctuation">.</span>dm<span class="token punctuation">.</span>jmm<span class="token punctuation">.</span>util<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> aload_0       <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Object."&lt;init>":()V</span>       <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> iconst_0       <span class="token number">1</span><span class="token operator">:</span> istore_1       <span class="token number">2</span><span class="token operator">:</span> iinc          <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>       <span class="token number">5</span><span class="token operator">:</span> <span class="token keyword">return</span><span class="token punctuation">}</span></code></pre><p>像i++这种代码在多线程环境下运行是有问题的。比如在线程A执行了istore_1的时候线程轮转到线程B去执行i++,并且线程B已经执行完了i++操作此时i=1,线程切换回A继续操作iinc,最后i还是1，就导致了bug的产生。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                counter<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上诉代码你执行无数次产生的结果都是不一致的,而且不一定为10000，这里即证明了i++不是原子性的,怎么解决在下面会有介绍。</p><pre class=" language-java"><code class="language-java"><span class="token number">9324</span>Process finished with exit code <span class="token number">0</span></code></pre><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>单线程模型下不存在可见性问题，可见性问题必然是多线程下产生的。</p><p>在上面的JMM模型中，如果线程A从主内存拿走一个变量并在工作内存中进行了写操作且没同步到主内存，这时候线程B也从主内存拿走了这个变量，但此时这个变量值是线程A没修改之前的值。从这个例子中可以看出线程A修改的值线程B不可见。</p><p>下面是验证代码，运行代码会发现程序不会停止，说明了不可见，但在while(!flag)里面加上System.out.println发现又可见了，很奇怪，个人觉得是由于System.out.println里面含有同步块的问题。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">test</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"此时可见"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Thread b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>在了解有序性之前需要首先了解一个现象叫指令重排，</p><h4 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h4><p>指令重排简单来说有的代码JVM结果不变的情况下会自动优化，使本来是1,2,3执行的代码优化为2,1,3等等。虽然说指令重排是在保证结果不变的情况下来产生的这里会涉及到<strong>as-if-serial语义</strong>和<strong>happens-before原则</strong>，但在特定情况下就会产生差别，使结果的不确定性使你的程序无法控制。下面贴一个代码来证明指令重排的现象。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">test</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">shortWait</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    x <span class="token operator">=</span> b<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    y <span class="token operator">=</span> a<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String result <span class="token operator">=</span> <span class="token string">"第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"次 ("</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> y <span class="token operator">+</span> <span class="token string">"）"</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 等待一段时间，时间单位纳秒     * @param interval     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shortWait</span><span class="token punctuation">(</span><span class="token keyword">long</span> interval<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> end<span class="token punctuation">;</span>        <span class="token keyword">do</span><span class="token punctuation">{</span>            end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>start <span class="token operator">+</span> interval <span class="token operator">>=</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 结果</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">11</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">28.814</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO com<span class="token punctuation">.</span>dm<span class="token punctuation">.</span>jmm<span class="token punctuation">.</span>util<span class="token punctuation">.</span>test <span class="token operator">-</span> 第<span class="token number">656298</span>次 <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>）<span class="token number">11</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">28.814</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO com<span class="token punctuation">.</span>dm<span class="token punctuation">.</span>jmm<span class="token punctuation">.</span>util<span class="token punctuation">.</span>test <span class="token operator">-</span> 第<span class="token number">656299</span>次 <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>）<span class="token number">11</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">28.814</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO com<span class="token punctuation">.</span>dm<span class="token punctuation">.</span>jmm<span class="token punctuation">.</span>util<span class="token punctuation">.</span>test <span class="token operator">-</span> 第<span class="token number">656300</span>次 <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>）<span class="token number">11</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">28.815</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO com<span class="token punctuation">.</span>dm<span class="token punctuation">.</span>jmm<span class="token punctuation">.</span>util<span class="token punctuation">.</span>test <span class="token operator">-</span> 第<span class="token number">656301</span>次 <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>）<span class="token number">11</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">28.815</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO com<span class="token punctuation">.</span>dm<span class="token punctuation">.</span>jmm<span class="token punctuation">.</span>util<span class="token punctuation">.</span>test <span class="token operator">-</span> 第<span class="token number">656302</span>次 <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>）第<span class="token number">656303</span>次 <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>）</code></pre><p>从这段代码可以推测出结果应该是(0,1); (1,0); ,(1,1)三个结果，0,0这个结果理论上是不会产生的，但执行后发现程序终止了(0,0)结果产生了。(0,0)的产生必然发生了指令重排，因为不发生指令重排a,b必然有一个为1，不管线程怎么走，a,b必然为1那，x,y也至少有一个为1，出现了(0,0)则代表a=1和x=b之间发生了重排序或者b=1和y=a发生了重排序。</p><p>执行结果不可控在代码里面是很恐怖的，as-if-serial语义保证了单线程执行结果不能被改变，happens-before原则保证了正确同步的多线程执行结果不能被改变，JVM会根据2个原则进行指令重排保证语义的正确。</p><ul><li><p><strong>as-if-serial语义</strong></p><p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p></li><li><p><strong>happens-before原则</strong></p><p>从JDK 5开始，Java使用新的JSR-133内存模型，提供了happens-before原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据</p><p>happens-before 原则内容如下</p><ol><li>程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</li><li>锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</li><li>volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li><li>线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</li><li>传递性 A先于B ，B先于C 那么A必然先于C</li><li>线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</li><li>线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</li><li>对象终结规则对象的构造函数执行，结束先于finalize()方法</li></ol></li></ul><h2 id="解决原子性问题"><a href="#解决原子性问题" class="headerlink" title="解决原子性问题"></a>解决原子性问题</h2><p>JVM自身是对八大基本数据类型读写操作提供原子性的，比如int x = 9;其余操作的原子性可以通过synchronized和ReentrantLock解决或者通过Unsafe魔法类的CAS来解决。含有Atomic的类，比如AtomicInteger底层就大量的运用到了Unsafe.针对上面原子性的代码进行原子性的调整。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> Object object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    counter<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 执行结果</span><span class="token number">10000</span>Process finished with exit code <span class="token number">0</span></code></pre><p>这段代码与上面的代码唯一不一样的地方就是在counter自增的地方加了一个synchronized同步块。而这同步块解决了原子性问题。</p><h2 id="解决可见性问题"><a href="#解决可见性问题" class="headerlink" title="解决可见性问题"></a>解决可见性问题</h2><p>一般解决可见性问题可以使用volatile来解决。</p><p>同样贴上代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"此时可见"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Thread b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这段代码与上面的代码唯一不一样的地方就是flag变量加了一个volatile关键字。而这解决了可见性问题。</p><h2 id="解决有序性问题"><a href="#解决有序性问题" class="headerlink" title="解决有序性问题"></a>解决有序性问题</h2><p>解决有序性问题同样也可以使用volatile关键字。这里就不贴代码了。在上诉代码里面给x,y,a,b加个volatile就OK了、</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>上面提到最多的就是volatile关键字。volatile关键字解决了有序性问题，可见性问题，但是他没有解决原子性问题。你可以用上诉counter自增代码测试一下。结果和不加volatile是一致的，不确定结果。</p><p>volatile总共有以下2个作用</p><ul><li>被volatile修饰的共享变量对所有线程总数可见的</li><li>禁止指令重排</li></ul><h3 id="volatile如何禁止指令重排"><a href="#volatile如何禁止指令重排" class="headerlink" title="volatile如何禁止指令重排"></a>volatile如何禁止指令重排</h3><p>在这之前得首先了解一个叫做内存屏障的概念。</p><h4 id="什么叫内存屏障？"><a href="#什么叫内存屏障？" class="headerlink" title="什么叫内存屏障？"></a>什么叫内存屏障？</h4><p>不同的硬件实现内存屏障的方式是不一样的。Java内存模型会屏蔽这种差异，JVM提供了四种内存屏障。</p><ul><li>LoadLoad屏障：第一次load操作进工作内存才可以进行第二次load操作。</li><li>LoadStore屏障：load操作进工作内存才可以进行store操作。</li><li>StoreStore屏障：第一次store操作完成后并且刷新到主内存才可以进行第二次的store操作。</li><li>StoreLoad屏障：store操作完成后并且刷新到主内存才可以进行load操作。</li></ul><p>而在指令之间插入了内存屏障就会禁止在内存屏障前后的指令执行重排序优化解决了有序性问题，而且会强制刷新CPU缓存数据解决了可见性问题。</p><h4 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h4><table><thead><tr><th>第一次操作</th><th>第二次操作：普通读</th><th>第二次操作：普通写</th><th>第二次操作：volatile读</th><th>第二次操作：volatile写</th></tr></thead><tbody><tr><td>普通读</td><td></td><td></td><td></td><td>LoadStore</td></tr><tr><td>普通写</td><td></td><td></td><td></td><td>StoreStore</td></tr><tr><td>volatile读</td><td>LoadLoad</td><td>LoadStore</td><td>LoadLoad</td><td>LoadStore</td></tr><tr><td>volatile写</td><td></td><td></td><td>StoreLoad</td><td>StoreStore</td></tr></tbody></table><h3 id="DCL-Double-Check-Lock-双重检查"><a href="#DCL-Double-Check-Lock-双重检查" class="headerlink" title="DCL(Double Check Lock)双重检查"></a>DCL(Double Check Lock)双重检查</h3><p>单例模式想必都很熟悉，下面是一个常见的单例模式</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DoubleCheckLock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Object instance<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>DoubleCheckLock<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>双重检查这里就不必说了，但这段代码有一个致命的地方，就是在instance = new Object();</p><p>在new 一个对象通常是有3个步骤</p><ol><li>分配对象内存空间</li><li>初始化对象</li><li>设置对象指向刚分配的内存地址</li></ol><p>而对象在设置对象指向刚分配的内存地址这一步的时候对象就不是空了,而这3步不做处理会发生指令重排，如果重排变成了1-&gt;3-&gt;2,又是高并发场景去拿这个单例就会出现空指针异常（即使这种出现的可能性极小但理论上是会发生的）</p><p>解决这个问题可以再单例上加上一个volatile解决，private volatile  static Object instance;</p><h3 id="volatile如何解决可见性问题"><a href="#volatile如何解决可见性问题" class="headerlink" title="volatile如何解决可见性问题"></a>volatile如何解决可见性问题</h3><p>指令遇到了内存屏障会出现强制刷新，缓存数据会和主存进行同步。会通过缓存一致性协议进行同步。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>syncronized是一个Java同步器是内置锁，synchronized是一种对象锁(锁的是对象而非引用)，作用粒度是对象，可以用来实现对临界资源的<strong>同步互斥访问</strong>，是<strong>可重入</strong>的。</p><p>多线程编程下，我们在访问一个临界资源，由于线程执行的过程是不可控的，所以需要采用同步机制来协同对对象可变状态的访问，这个时候我们就需要同步器。</p><p>Java中有2种方式来解决线程并发安全问题。synchronized，lock</p><h3 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h3><p>synchronized是基于JVM内置锁实现，通过内部对象Monitor(监视器锁)实现，监视器锁的实现依赖底层操作系统的Mutex lock（互斥锁）实现，它是一个重量级锁性能较低。synchronized在1.5之后版本做了重大的优化，如锁粗化、锁消除，锁膨胀升级等来减少锁操作的开销，synchronized的并发性能已经基本与Lock持平。</p><p>Monitor是一种同步机制，synchronized也被称为内置锁原因就是Monitor存在于每一个对象中，当对象头MarkWord的锁标识位为10的时候，会有一个指针指向Monitor内存地址的起始位。</p><p>下图为32位虚拟机对象头的bit位分配</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20201103170434.png"></p><p>从上图可以看出内置锁共有4种状态无锁，偏向锁，轻量级锁，重量级锁。</p><h4 id="锁的膨胀升级"><a href="#锁的膨胀升级" class="headerlink" title="锁的膨胀升级"></a>锁的膨胀升级</h4><p>内置锁有一个锁的膨胀升级过程，他会从无锁状态-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁。而且锁只会升级不会降级。</p><ul><li><p>偏向锁</p><p>一个对象获得了锁，此时就是偏向锁，如果这个线程在想拿锁，无需再申请锁。在没有锁竞争的情况下，会使用偏向锁。</p></li><li><p>轻量级锁</p><p>在多个线程交替执行同步块的时候，会升级到轻量级锁。</p></li><li><p>自旋锁</p><p>当线程竞争激烈，多个线程请求同步块的时候，轻量级锁失效的情况下，不会马上升级为重量级锁，而是升级为自旋锁，自旋锁会计算自旋次数，如果自旋次数达到阈值就会升级到重量级锁。</p></li><li><p>重量级锁</p><p>锁竞争激烈自旋锁达到阈值，升级重量级锁。</p></li></ul><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>Java虚拟机在JIT编译时对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>Java虚拟机会把几个连续的同步块合并为一个，将原来的锁粗化</p><h2 id="MESI-缓存一致性协议"><a href="#MESI-缓存一致性协议" class="headerlink" title="MESI 缓存一致性协议"></a>MESI 缓存一致性协议</h2><p>MESI 是指四种状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：M(修改)，E(独享)，S(共享)，I(失效)</p><table><thead><tr><th>状态</th><th>描述</th><th>监听</th></tr></thead><tbody><tr><td>M(修改)</td><td>Cache line有效，数据被修改了，和内存中的数据不一致，数据在本Cache中</td><td>缓存行必须时刻监听所有试图读该缓存行相对就主存的<br>操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td></tr><tr><td>E(独享)</td><td>Cache line有效，数据和内存中的数据一致，数据在本Cache中</td><td>缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有<br>这种操作，该缓存行需要变成S（共享）状态。</td></tr><tr><td>S(共享)</td><td>Cache line有效，数据和内存中的数据一致，数据在很多Cache中</td><td>缓存行也必须监听其它缓存使该缓存行无效或者独享<br>该缓存行的请求，并将该缓存行变成无效（Invalid）。</td></tr><tr><td>I(失效)</td><td>该Cache line无效</td><td>无</td></tr></tbody></table><p>举个例子：</p><p>假设:2个线程T1,T2，一个变量a = 1;被volatile修饰会共享变量</p><ol><li>现在T1线程读了a=1,T1给a标记一个状态E(独享)</li><li>现在T1线程读了a=1,T1给a标记一个状态E(独享)</li><li>然后现在T1,T2都要对a进行修改，2个线程不可以直接修改，他们都对各自的缓存行进行加锁，加锁成功后才可以修改，修改后状态S-&gt;M，那么问题来了，他们之间的加锁2个线程之间都互相不知道，那这加锁没啥用？线程对缓存行加锁时候会向外部发一个消息告诉别的线程我已经加锁了，你们别加了，那如果2方同时加锁，同时发消息呢？他们发消息必定会经过总线，在总线这总线会对2方进行一个裁决（总线裁决）谁加锁成功，加锁成功的才能进行修改，另一方只能将自己的数据给丢掉状态S-&gt;I</li></ol><p>如果一个变量太大，一个缓存行放不下，放在了多个缓存行，为了保证原子性，加锁的时候加不了，此时CPU就直接升级为总线锁</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> Java关键字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列常见问题及解决方案</title>
      <link href="2020/10/08/xiao-xi-dui-lie/"/>
      <url>2020/10/08/xiao-xi-dui-lie/</url>
      
        <content type="html"><![CDATA[<p>当前市场常见的几种消息中间件就有比如说RabbitMQ、RocketMQ、Kafka，他们都各有优势，下面会介绍他们之间的差别和优缺点。这里不针对某种消息队列，常见消息队列糅杂在一起谈谈</p><h2 id="常用消息中间件简单介绍"><a href="#常用消息中间件简单介绍" class="headerlink" title="常用消息中间件简单介绍"></a>常用消息中间件简单介绍</h2><p>只是简单介绍几种常用消息中间件消息生产和消息消费的过程，具体底层架构和文件存储结构在这里就不做过多的阐述。</p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>erlang开发，先说下RabbitMQ的几个关键词吧，如果你安装过RabbitMQ并且在他的可视化界面进行操作，一定对下面这几个关键词不陌生</p><ul><li>server：服务节点</li><li>exchange：交换机</li><li>virtual host：虚拟机</li><li>queue：消息队列</li><li>route_key：很关键，它的作用就是帮助我们的生产者路由到哪个队列</li></ul><p>生产消息和消费消息过程：生产者发送消息到一个具体的exchange交换机上面并且还带着一个route_key，不同的队列还绑定者不同的route_key.通过生产者携带的route_key和交换机类型（主题交换机，扇形交换机，直接交换机）来判定将消息发送到哪个消息队列上去。然后消费者已经订阅了某个队列，只要那个队列来数据了。消费者就可以通过某些策略去消费消息。</p><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>阿里的一个开源消息中间件，最大的特点就是支持事务消息，定时消息，Java开发。它跟Kafka有点类似，所以想理解Kafka的可以先了解下RocketMQ,可以一定程度上降低Kafka的学习难度（Kafka应该算是最复杂的一个消息中间件）。下面同样先介绍一下他的一些关键名词。</p><ul><li>name server：一个无状态的集群，name server的集群节点之间是无信息交流的，nameserver里面存储着所有的broker,producer和cosumer,每个节点都有一份。</li><li>broker server：集群，主要作用是存储消息，转发消息。</li><li>topic：主题，每个消息必定带着一个主题</li></ul><p>生产消息和消费消息过程：生产者生产一条消息，带着topic,从name server里面拉取存着这个topic的broker节点列表，从节点列表里面选一个发送，然后在这一个broker里面选取一个queue发送，消费者通过绑定的topic从name server里面取一个broker里面的队列进行消费。当然这里面还有很多细节，比如拉取式消费，推动式消费，顺序消费，广播消费，集群消费，事务消息，同步发送，异步发送，消息存储架构，这些就不一一说了，后面可能会写一篇只针对于RocketMQ的博文。</p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>scala开发，性能强，适用于大数据场景，强依赖于Zookeeper。Kafka基本别的事也不做，他只存储消息，其他什么选举，转发都交给zookeeper去做了，所以性能极高。同样先介绍几个关键词</p><ul><li>broker：一个Kafka节点就是一个broker</li><li>topic：对消息进行归类，每条消息都必须带着一个topic</li><li>partition：一个topic可以分出很多partition,每个partition内部消息是有序的</li><li>cosumer  group：消费组，同一个partition里面的消息只能被一个消费组的一个消费者消费</li></ul><p>生产消息和消费消息过程：生产者负责将消息发送到topic下面的某一个partition.然后一个消费组里面的消费者只能消费一个partition里面的消息，也就是说一条消息不能被同一个消费组里面的多个消费者消费。，大概就这样了</p><h2 id="消息中间件对比"><a href="#消息中间件对比" class="headerlink" title="消息中间件对比"></a>消息中间件对比</h2><p>这里只针对于我所了解的消息中间件进行对比，比如</p><table><thead><tr><th></th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>持久化方式</td><td>内存/文件</td><td>磁盘</td><td>磁盘</td></tr><tr><td>集群管理</td><td></td><td>name server</td><td>zookeeper</td></tr><tr><td>数据可靠性</td><td>好，producer支持同步异步ack</td><td>很好，支持同步刷盘/异步刷盘/同步双写/异步复制</td><td>很好，同步刷盘/同步复制</td></tr><tr><td>性能</td><td>好，内存：RocketMQ的1/2，DIsk：RocketMQ的1/3</td><td>很好，10万/s</td><td>极好，百万条/s</td></tr><tr><td>性能稳定性</td><td>消息堆积，性能下降</td><td>单机最多5万队列</td><td>队列/分区增多，性能急剧下降</td></tr><tr><td>事务消息</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>定时消息</td><td>不支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h2 id="消息中间件场景"><a href="#消息中间件场景" class="headerlink" title="消息中间件场景"></a>消息中间件场景</h2><p>说到消息中间件一般就是异步处理，应用解耦，流量削峰，日志处理</p><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>有时候我们处理业务代码希望更快的反应结果给客户端，而其他附带的业务可以利用消息队列慢慢处理去。比如我们处理订单业务逻辑，可能会附带其他逻辑比如积分服务，购物车服务，优惠卷服务等等。我们可以将这些服务发送到消息队列里面去慢慢处理，这就是异步处理。提高系统响应速度。</p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>有时我们会有多个业务逻辑耦合，比如订单服务和库存服务耦合。有时会因为耦合导致库存服务的异常导致下订单失败。我们可以下订单然后发送消息到消息队列然后库存服务在去消费消息。</p><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p>有时会因为流量的暴增而导致应用系统扛不住流量而导致应用宕掉。这时候我们就可以把流量打到消息队列，应用去消息队列拉取消息去消费。</p><h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><p>一般日志收集系统是ELK,但有时因为一些需求，会对ELK架构进行一些调整，利用Kafka去接收消息，然后将消息交给logstash去转化成json,然后logstash吧数据交给elastaticsearch实现数据存储，然后通过Kibana进行可视化管理。</p><h2 id="消息中间件常见问题及解决思路"><a href="#消息中间件常见问题及解决思路" class="headerlink" title="消息中间件常见问题及解决思路"></a>消息中间件常见问题及解决思路</h2><h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><p>消息队列都有多个生产者和多个消费者，那么我们如何保证消费消息的顺序性呢。假设有一个需求是生产者生产了订单消息，加购物车消息，加积分消息，要求我们保证订单-&gt;购物车-&gt;积分顺序消费。解决办法就是一个生产者让一个消费者消费，此时消费一定是顺序的。</p><p>RabbitMQ就可以生产者通过routingkey和交换机类型使只有一个消费者可以消费到这条消息</p><p>RocketMQ是通过生产者往一个queue上面发，消费者也通过这个队列消费保证了消费的顺序性</p><p>Kafka有个特性就是一个消费组里的消费者只会消费一个partition里面的消息,要想保证消息的全局有序性，可以让partition数量为1和消费组消费者数量也是1就ok了。partition数量为1是为了生产者只往这一个partition消费，消费组消费者数量是1为了不让别的这个消费组里面的别的消费者消费partition中的消息。</p><h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><p>消息队列是通过网络进行消息的传输，由于网络的不可靠，比如网络抖动，必然会出现各种各样的问题，其中就有重复消费，重复消费首先你得保证发送端是有重试机制的，如果没有重试机制也就没有重复消费问题了。</p><p><strong>发送端问题</strong>：试想如果你消费了消息，正要告诉exchange或nameserver我消费成功了，但exchange或nameserver由于网络抖动没有接受到消息回复确认，它们又发送了一条消息让你来消费，这就出现了重复消费的问题</p><p><strong>消费端问题</strong>：消费了消息正要提交ack给exchange或nameserve但一个不小心消费端挂了，好，此时你已经消费了一条消息但没有告诉exchange,消费端重启发送端吧刚刚消费掉的消息给你消费了，出现了重复消费</p><p>解决重复消费问题就是消息幂等性问题：</p><ol><li>很简单给每一条消息一个唯一id,确保了消息的唯一性自然就解决了重复消费的问题。</li><li>做一个消息消费的日志表记录消费成功的消息编号，如果将要消费的消息在日志表里面就不在消费这条消息。</li></ol><h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><p>消息丢失的问题通常和性能相挂钩，鱼和熊掌不可兼得，要想要性能就必然存在消息丢失的情况，要想要消息完全不丢失就必然会牺牲性能，这2者要想要哪一种看业务需求，这里拿Kafka举例。</p><p><strong>发送端问题</strong>：发送端往往会有一些消息消费确认策略，在Kafka消息发送端有一个配置叫acks,</p><ul><li>acks=0：消息发送端不需要等待broker的确认收到消息就可以继续发送消息，性能很高，大多数用于日志收集，行为数据采集等场景，这些场景丢一些数据也是无所谓的，但由于数据的量级很大，所以性能要求极高。</li><li>acks=1：消息发送端发送给broker会等待broker将消息写进log中不需要等待follower备份成功，后告诉发送端我收到消息了。此时<strong>如果leader挂了，由于没有follower没有备份数据，就发生了消息丢失的问题</strong></li><li>acks=-1或all：消息发送端发送给broker会等待所有备份都备份成功就告诉消息发送端我收到了，这时候即使你挂了leader,照样可以不丢失消息。等待备份个数由<strong>min.insync.replicas</strong>配置控制，当<strong>min.insync.replicas=1</strong>时效果和acks=1一样会产生丢失消息的情况。</li></ul><p><strong>消费端问题</strong>：如果消息发送端是配置的是自动签收的话，如果我消息发过来了，我直接签收了，但我并没有消费掉，此时消费端宕机这条还未被消费的消息就不会再消费了，而broker又认为你消费了不会再把消息给你消费。</p><h3 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h3><p>消息堆积产生情况：</p><ul><li>有时会因为消费端消费太慢导致堆积大量的消息。</li><li>当发送端发送了大量的消息在exchange或broker,而现在没有消费者消费。消费者一但启动一堆消息直接打到消费端严重会造成消费端宕机。</li><li>由于消费端有bug导致消息一直消费不成功。就会导致broker，exchange产生大量的消息。这种情况一般可以利用死信队列解决，消息消费失败多少次直接转移到死信队列。</li></ul><p>消息堆积解决办法：</p><p>这里解决办法是在消费端无bug情况下，且消费端性能使用没问题的情况下。</p><ul><li>最简单直接的办法加机器，做集群，消费端消费慢直接多加几个消费者消费不就ok了吗？</li><li>我们不可能一直加机器来解决这个问题吧，其实我们可以利用一个折中的办法，我们使用一个消费者消费，但这里我们并不消费消息，而是将消息转移到其他的topic上面，这个消费者消费速率会把大量的堆积消息以最快的速度给吃掉，然后让其他的消费者去消费去。这一般用于紧急处理大量消息使用。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap1.7和1.8对比与线程安全源码解析</title>
      <link href="2020/09/16/concurrenthashmap/"/>
      <url>2020/09/16/concurrenthashmap/</url>
      
        <content type="html"><![CDATA[<p>ConcurrentHashMap与HashMap在Api,参数,数据结构上面基本都是类似的，实现原理也基本都是一致的在这里就不做过多的说明了，若不清楚可以看下另一篇HashMap的对比博文<a href="https://dmsupine.com/2020/09/01/hashmap/">HashMap1.7和1.8对比与源码解析</a>:ConcurrentHashMap和HashMap最大的区别不用说就是一个线程安全一个线程不安全。本篇博文主要介绍的是ConcurrentHashMap是怎么实现的线程安全。</p><h2 id="jdk1-7和jdk1-8对比"><a href="#jdk1-7和jdk1-8对比" class="headerlink" title="jdk1.7和jdk1.8对比"></a>jdk1.7和jdk1.8对比</h2><p>在看怎么实现之前，先大体介绍一下1.7和1.8的实现区别，1.7主要是用ReentrantLock实现分段锁实现的线程安全。1.8是使用CAS+分段锁实现的。从这上面也可以明显的看出1.8性能更好，不好也不会优化是吧。下面就看下他们是怎么实现的。</p><p><strong>建议：ConcurrentHashMap源码大量运用到了Unsafe魔法类，ReentrantLock，二进制运算，看源码前对这些有了了解看起来会舒服很多</strong></p><h2 id="ConcurrentHashMap-jdk1-7源码解析"><a href="#ConcurrentHashMap-jdk1-7源码解析" class="headerlink" title="ConcurrentHashMap jdk1.7源码解析"></a>ConcurrentHashMap jdk1.7源码解析</h2><p>先看一下需要用到的参数有哪些</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// HashMap初始容量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 加载因子</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Segment[]初始并发等级：决定了Segment[]的长度</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CONCURRENCY_LEVEL <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Segment对象下HashEntry[]最大容量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 最小Segment[]容量：</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 最大Segement[]容量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_SEGMENTS <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 锁重试次数</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RETRIES_BEFORE_LOCK <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre><p>看到参数介绍，想必对一个词很熟悉Segment,其实hashMap分段锁锁的就是Segment,Segment是不存HashMap的数据，在Segment下面就是HashMap的数据结构数组+链表。put操作就是先找到一个Segment,加个锁然后在找到对应的bucket位置然后把值往里面放如果有值就形成链表。这样做的目的就是减少锁竞争。只有落在同一个Segment上面的资源才会发生锁竞争，减小了锁竞争的几率。hashTable也是线程安全的，了解他的实现机制就知道HashTable put一个值直接全部锁住，这样锁竞争大大增加，性能很差。现在使用Hashtable的想必也比较少了吧。</p><p>在看put方法前先喽一眼ConcurrentHashMap的构造方法</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span>                         <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">int</span> concurrencyLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>loadFactor <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> concurrencyLevel <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>concurrencyLevel <span class="token operator">></span> MAX_SEGMENTS<span class="token punctuation">)</span>        concurrencyLevel <span class="token operator">=</span> MAX_SEGMENTS<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Find power-of-two sizes best matching arguments</span>    <span class="token comment" spellcheck="true">// concurrencyLevel就是DEFAULT_CONCURRENCY_LEVEL = 16;</span>    <span class="token comment" spellcheck="true">// ssize是concurrencyLevel计算而来是大于它的最小的2的n次幂，sshift是n次幂的n</span>    <span class="token keyword">int</span> sshift <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 默认为4</span>    <span class="token keyword">int</span> ssize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 默认为16</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ssize <span class="token operator">&lt;</span> concurrencyLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">++</span>sshift<span class="token punctuation">;</span>        ssize <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>segmentShift <span class="token operator">=</span> <span class="token number">32</span> <span class="token operator">-</span> sshift<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 默认28</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>segmentMask <span class="token operator">=</span> ssize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 默认15</span>    <span class="token comment" spellcheck="true">// 这里咔咔一顿计算主要就是算出cap的大小就是一个Segment下面的table长度。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>        initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> initialCapacity <span class="token operator">/</span> ssize<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">*</span> ssize <span class="token operator">&lt;</span> initialCapacity<span class="token punctuation">)</span>        <span class="token operator">++</span>c<span class="token punctuation">;</span>    <span class="token keyword">int</span> cap <span class="token operator">=</span> MIN_SEGMENT_TABLE_CAPACITY<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cap <span class="token operator">&lt;</span> c<span class="token punctuation">)</span>        cap <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// create segments and segments[0]</span>    <span class="token comment" spellcheck="true">// 构造Segment0</span>    Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> s0 <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>cap <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">,</span>                         <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token punctuation">[</span>cap<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建ssize长度的Segment数组</span>    Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ss <span class="token operator">=</span> <span class="token punctuation">(</span>Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token punctuation">[</span>ssize<span class="token punctuation">]</span><span class="token punctuation">;</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedObject</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> SBASE<span class="token punctuation">,</span> s0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ordered write of segments[0]</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>segments <span class="token operator">=</span> ss<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>下图发现Segment继承了ReentrantLock所以很明显它是通过ReentrantLock实现的锁</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20200914174529.png"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> s<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里一波操作只为了确认当前Segmnet在什么位置，并把当前元素应该落的Segment取出来，准备做put操作</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">>>></span> segmentShift<span class="token punctuation">)</span> <span class="token operator">&amp;</span> segmentMask<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>UNSAFE<span class="token punctuation">.</span>getObject          <span class="token comment" spellcheck="true">// nonvolatile; recheck</span>         <span class="token punctuation">(</span>segments<span class="token punctuation">,</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;&lt;</span> SSHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> SBASE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//  in ensureSegment</span>        <span class="token comment" spellcheck="true">// 延迟创建Segment</span>        s <span class="token operator">=</span> <span class="token function">ensureSegment</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// put元素</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里尝试去拿锁拿成功了node为null失败就阻塞在里面进去</span>    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> node <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span>    <span class="token function">scanAndLockForPut</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    V oldValue<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 取出当前Segment中的table，话说直接用table去做不行吗这时候由于Segment上面有锁只有一个线程执行table所以应该是没问题的。</span>        <span class="token comment" spellcheck="true">// 这里很有可能是为了去volatile,在table上面是有volatile修饰的，去volatile可以优化性能。</span>        HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 计算出当前元素落在Segment中table中的哪一个位置</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里是Segment中应该落的table位置的第一个元素</span>        HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first <span class="token operator">=</span> <span class="token function">entryAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 自旋</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 头不是空，说明Hash碰撞了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                K k<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 这里是判一下插入的这个key我有没有,有的化刷新值，没有的话e=e.next</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                    <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 这里判断是否覆盖原来的值</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 进入else循环说明e是null,2种情况：一种是first节点是null,还有一种是上面这个if语句链表往后传传到最后了</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// node不等于空很有可能是上面tryLock加锁失败scanAndLockForPut所返回的，这一部分下面在看</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 头插法</span>                    node<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>                    <span class="token comment" spellcheck="true">// 初始化node</span>                    node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> c <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 扩容</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> threshold <span class="token operator">&amp;&amp;</span> tab<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>                    <span class="token function">rehash</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>                    <span class="token comment" spellcheck="true">// put值</span>                    <span class="token function">setEntryAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>modCount<span class="token punctuation">;</span>                count <span class="token operator">=</span> c<span class="token punctuation">;</span>                oldValue <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 释放锁</span>        <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面主要介绍了put方法，其中有几个疑问点，一是scanAndLockForPut方法细节，二是rehash扩容细节，三是put方法里面用了许多Unsafe里面的许多魔法类，后面对Unsafe有所理解在补充这一部分。</p><h3 id="scanAndLockForPut-方法"><a href="#scanAndLockForPut-方法" class="headerlink" title="scanAndLockForPut 方法"></a>scanAndLockForPut 方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">scanAndLockForPut</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里取得对应Segment中的对应数组位置的第一个元素</span>    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first <span class="token operator">=</span> <span class="token function">entryForHash</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> first<span class="token punctuation">;</span>    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> node <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化重试次数，控制自旋次数，避免无止境的自旋导致资源的浪费</span>    <span class="token keyword">int</span> retries <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// negative while locating node</span>    <span class="token comment" spellcheck="true">// 加锁失败，开始自旋</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// to recheck first below</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retries <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// e节点是null，2种情况，1是本身first就是null，还有一种e = e.next;链表挪到最后了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 这里判断node节点是避免重复new Node节点，因为如果first节点有人更改了会重置retries=-1</span>                <span class="token comment" spellcheck="true">// 又会走到这个地方但node不是null了，所以这里需要再次判断node是不是null</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// speculatively create node</span>                    node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                retries <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>                retries <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 自增retries如果大于最大重试次数加锁阻塞</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>retries <span class="token operator">></span> MAX_SCAN_RETRIES<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 每偶数次检查是否有线程修改了first节点，这时候需要重置first节点并更改retries = -1;使其重新自旋</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>retries <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                 <span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">entryForHash</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e <span class="token operator">=</span> first <span class="token operator">=</span> f<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// re-traverse if entry changed</span>            retries <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="rehash方法"><a href="#rehash方法" class="headerlink" title="rehash方法"></a>rehash方法</h3><p>这一块源码比较简单就是一些指针的移动，主要扩容逻辑就是遍历Segment的table,复制一个新的table是原table的2倍大小。然后遍历这个table的每一个节点，如果这个节点挂着一个链表就可以rehash这个链表下的每一个元素，假设链表新的落的位置为7,10,10,11,9,9,9。这时候倒着来看这条链表是9，一直往上看直到不同的元素就是9，9，9然后他会直接把这9,9,9直接挪到新的数组上去。然后遍历剩余的元素处理，</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rehash</span><span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里就是构建新数组，并重新计算扩容阈值threshold，和掩码sizeMask（计算元素在数组中的位置）</span>    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span>        <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sizeMask <span class="token operator">=</span> newCapacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历老数组</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldCapacity <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> oldTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 算出当前元素在数组中的新位置idx</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> sizeMask<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// next是null证明链表上就一个元素，直接newTable[idx] = e;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//  Single node on list</span>                newTable<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 走else说明链表不止一个元素</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Reuse consecutive sequence at same slot</span>                <span class="token comment" spellcheck="true">// lastRun:之前遍历的最后一个元素</span>                <span class="token comment" spellcheck="true">// lastIdx:之前遍历的最后一个元素的位置</span>                HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lastRun <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">int</span> lastIdx <span class="token operator">=</span> idx<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 遍历这条链表，找到最后的连续节点只要不连续重新构造lastRun，lastIdx</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> last <span class="token operator">=</span> next<span class="token punctuation">;</span>                     last <span class="token operator">!=</span> null<span class="token punctuation">;</span>                     last <span class="token operator">=</span> last<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 计算节点位置</span>                    <span class="token keyword">int</span> k <span class="token operator">=</span> last<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> sizeMask<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 重新构造lastRun，lastIdx </span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> lastIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        lastIdx <span class="token operator">=</span> k<span class="token punctuation">;</span>                        lastRun <span class="token operator">=</span> last<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 连续节点放到新数组的位置</span>                newTable<span class="token punctuation">[</span>lastIdx<span class="token punctuation">]</span> <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Clone remaining nodes</span>                <span class="token comment" spellcheck="true">// 其余节点rehash</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> e<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    V v <span class="token operator">=</span> p<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                    <span class="token keyword">int</span> h <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>                    <span class="token keyword">int</span> k <span class="token operator">=</span> h <span class="token operator">&amp;</span> sizeMask<span class="token punctuation">;</span>                    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n <span class="token operator">=</span> newTable<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                    newTable<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> p<span class="token punctuation">.</span>key<span class="token punctuation">,</span> v<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> nodeIndex <span class="token operator">=</span> node<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> sizeMask<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// add the new node</span>    node<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>newTable<span class="token punctuation">[</span>nodeIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    newTable<span class="token punctuation">[</span>nodeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="ConcurrentHashMap-jdk1-8源码解析"><a href="#ConcurrentHashMap-jdk1-8源码解析" class="headerlink" title="ConcurrentHashMap jdk1.8源码解析"></a>ConcurrentHashMap jdk1.8源码解析</h2><p>在看ConcurrentHashMap源码之前还有几个区别于1.7参数需要介绍一下；（这里只介绍下面源码出现的参数）</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 大于0表示table最大存放元素的个数</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> sizeCtl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当Node.hash为MOVED时, 代表着table正在扩容</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MOVED <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 此元素后接红黑树</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEBIN <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 链表树化阈值</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span></code></pre><p>还是第一步来看一下构造方法</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>1.8的构造方法相比于1.7还是比较简单的。里面只做了一件事就是计算sizeCtl，可看参数介绍</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>initialCapacity <span class="token operator">>=</span> <span class="token punctuation">(</span>MAXIMUM_CAPACITY <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>               MAXIMUM_CAPACITY <span class="token operator">:</span>               <span class="token comment" spellcheck="true">// 这里对1.5倍的initialCapacity+1进行2的n次幂取值，比如传入16就tableSizeFor(25)所以就是对25找n次幂，结果就是bucket个数</span>               <span class="token comment" spellcheck="true">// 这里不是很明白为什么要对initialCapacity + (initialCapacity >>> 1) + 1做2的n次幂，而不是直接对initialCapacity做2的n次幂</span>               <span class="token comment" spellcheck="true">// 如有知道的，希望同僚告知。</span>               <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sizeCtl <span class="token operator">=</span> cap<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h3><p>1.8的put与1.7区别还是很大的，具体流程是，put一个值，先来个死循环，如果table是空的就执行initTable初始化table,不是空就看是否这一个bucket是空的，如果是直接CAS插入元素，如果不是就看当前hash表是不是在扩容是的化当前线程去帮助扩容，不是的话就开始链表插入，链表插入判断是不是红黑树，是的化插树，不是的话插入链表，插入链表要记录链表长度，链表长度要大于红黑树阈值，就树化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null <span class="token operator">||</span> value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 看当前table是不是空，是空就要初始化table</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 看当前数组位置是否为空，为空说明当前我是第一个插入这个位置的元素</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// CAS把元素插入</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span>                         <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// no lock when adding to empty bin</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 这里是判断HashMap是不是正在扩容</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 这里就厉害了，一般而言正在扩容我们当前线程应该是阻塞的，但HashMap就不这样想，他让当前线程跑去先帮HashMap扩容，</span>            <span class="token comment" spellcheck="true">// 这个方法是重点后面看</span>            tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 正式插入链表之中</span>            V oldVal <span class="token operator">=</span> null<span class="token punctuation">;</span>、            <span class="token comment" spellcheck="true">// 先加一个同步块；保证线程安全</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// f是当前元素可以转头看下第1个else if;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// fh是f.hash 说明没有异常状态不在扩容，不是红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 记录链表长度，为树化做准备</span>                        binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 遍历链表</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            K ek<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 看链表里面是否有这个key，有就判onlyIfAbsent是否覆盖value</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                                 <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                                    e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 指针往后挪，并且如果当前节点的下一个节点是null,证明到底了；</span>                            <span class="token comment" spellcheck="true">// 就让当前节点的下一个节点初始化node,等于Node插入链表（尾插法）</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>                                                          value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 走到这，说明fh&lt;0，看他是不是一个树，是的化树里面插入</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>                        binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 红黑树结构旋转插入</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>                                                              value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                                p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// binCount说明插入成功了甭管是树插成功还是链表成功。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果链表长度大于TREEIFY_THRESHOLD阈值就树化</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD<span class="token punctuation">)</span>                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 避免走addCount</span>                    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 走这说明数组当前位置只插入了一个元素，因为往链表里面插还是树里面都会重置oldVal,就会在上面 if (oldVal != null)  return出去</span>    <span class="token comment" spellcheck="true">// 检查是否需要扩容,下面会看到这个方法的详细</span>    <span class="token function">addCount</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这里看是否sizeCtl是否小于0，小于0说明有另一个线程正在初始化，这时候就让出CPU</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lost initialization race; just spin</span>        <span class="token comment" spellcheck="true">// CAS更新sc的值到-1；SIZECTL是sizeCtl的偏移量，</span>        <span class="token comment" spellcheck="true">// 这里的作用可以配合第一个if看就一目了然了</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 在判断一次table是不是空</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// sc大于0说明构造函数已经计算过，否则使用默认值</span>                    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>                    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 初始化table</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                    table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 计算扩容阈值0.75n</span>                    sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> tab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="transfer扩容方法"><a href="#transfer扩容方法" class="headerlink" title="transfer扩容方法"></a>transfer扩容方法</h3><p>在table中有3种节点类型</p><ul><li>TreeBin：节点下是红黑树</li><li>ForwardingNode：扩容存放的节点</li><li>Node：链表节点</li></ul><p>扩容流程：每个线程根据CPU核数分配处理多少bucket,然后多线程扩容，如果有线程put的时候发现正在扩容就帮table进行扩容。</p><p>// TODO</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">,</span> stride<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 多线程扩容，这里将数组长度/8/线程总数是每个线程需要处理的bucket数，如果小于16，按16处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span>NCPU <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> NCPU <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TRANSFER_STRIDE<span class="token punctuation">)</span>        stride <span class="token operator">=</span> MIN_TRANSFER_STRIDE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// subdivide range</span>    <span class="token comment" spellcheck="true">// nextTab是null,表示刚进来扩容，辅助扩容，nextTab不是null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// initiating</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 新的table 长度是n &lt;&lt; 1是2n,所以扩容大小是原来的2倍</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            nextTab <span class="token operator">=</span> nt<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// try to cope with OOME</span>            sizeCtl <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        nextTable <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 标识扩容进度</span>        transferIndex <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> nextn <span class="token operator">=</span> nextTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    ForwardingNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> fwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForwardingNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// true表示当前线程bucket迁移结束，开始往后推进</span>    <span class="token keyword">boolean</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 完成扩容</span>    <span class="token keyword">boolean</span> finishing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// to ensure sweep before committing nextTab</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bound <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> fh<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>advance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextIndex<span class="token punctuation">,</span> nextBound<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>i <span class="token operator">>=</span> bound <span class="token operator">||</span> finishing<span class="token punctuation">)</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nextIndex <span class="token operator">=</span> transferIndex<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span>                     <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> TRANSFERINDEX<span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span>                      nextBound <span class="token operator">=</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">></span> stride <span class="token operator">?</span>                                   nextIndex <span class="token operator">-</span> stride <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                bound <span class="token operator">=</span> nextBound<span class="token punctuation">;</span>                i <span class="token operator">=</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> n <span class="token operator">||</span> i <span class="token operator">+</span> n <span class="token operator">>=</span> nextn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sc<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>finishing<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nextTable <span class="token operator">=</span> null<span class="token punctuation">;</span>                table <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>                sizeCtl <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">,</span> sc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                finishing <span class="token operator">=</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// recheck before commit</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>            advance <span class="token operator">=</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>            advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// already processed</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> ln<span class="token punctuation">,</span> hn<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> runBit <span class="token operator">=</span> fh <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lastRun <span class="token operator">=</span> f<span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> runBit<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                runBit <span class="token operator">=</span> b<span class="token punctuation">;</span>                                lastRun <span class="token operator">=</span> p<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>runBit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            ln <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                            hn <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            hn <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                            ln <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span> K pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span> V pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                                ln <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> t <span class="token operator">=</span> <span class="token punctuation">(</span>TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>f<span class="token punctuation">;</span>                        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lo <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hi <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token keyword">int</span> lc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> t<span class="token punctuation">.</span>first<span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> h <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>                            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span>                                <span class="token punctuation">(</span>h<span class="token punctuation">,</span> e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span>val<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> loTail<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    lo <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                                loTail <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token operator">++</span>lc<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token keyword">else</span> <span class="token punctuation">{</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> hiTail<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    hi <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                                hiTail <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token operator">++</span>hc<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        ln <span class="token operator">=</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span>                        <span class="token punctuation">(</span>hc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>                        hn <span class="token operator">=</span> <span class="token punctuation">(</span>hc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span>                        <span class="token punctuation">(</span>lc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="helpTransfer方法"><a href="#helpTransfer方法" class="headerlink" title="helpTransfer方法"></a>helpTransfer方法</h3><p>这里是ConcurrentHashMap的精华所在，它的作用就是帮助正在扩容的线程进行扩容，而不是在那傻傻在那等着扩容结束。</p><p>// TODO</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">ForwardingNode</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>nextTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ForwardingNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span>nextTable<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> nextTable <span class="token operator">&amp;&amp;</span> table <span class="token operator">==</span> tab <span class="token operator">&amp;&amp;</span>               <span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">>>></span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">!=</span> rs <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span>                sc <span class="token operator">==</span> rs <span class="token operator">+</span> MAX_RESIZERS <span class="token operator">||</span> transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nextTab<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> table<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 集合 </tag>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper初探及使用场景</title>
      <link href="2020/09/08/zookeeper-chu-tan-ji-shi-yong-chang-jing/"/>
      <url>2020/09/08/zookeeper-chu-tan-ji-shi-yong-chang-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="认识ZooKeeper"><a href="#认识ZooKeeper" class="headerlink" title="认识ZooKeeper"></a>认识ZooKeeper</h2><p>ZooKeeper是一个分布式调度协调服务，分布式应用的产生必定会带来多节点之间的协调问题，这个时候ZooKeeper就出现了。很多开源中间件都用到了ZooKeeper,比如KafKa就是强依赖于ZooKeeper.它自身也是一个分布式应用。</p><h2 id="ZooKeeper节点特性"><a href="#ZooKeeper节点特性" class="headerlink" title="ZooKeeper节点特性"></a>ZooKeeper节点特性</h2><p>ZooKeeper共有4种节点，分别是持久节点，持久序号节点，临时节点，临时序号节点</p><table><thead><tr><th align="left"></th><th>特性</th><th>创建命令</th></tr></thead><tbody><tr><td align="left">持久节点</td><td>持久化保存的节点，默认创建</td><td>create /test</td></tr><tr><td align="left">持久序号节点</td><td>持久化保存的节点，创建的时候会在路径上加上序号作为后缀比如/test会创建出/test00000001</td><td>create -s /test</td></tr><tr><td align="left">临时节点</td><td>临时节点会在客户端删除的时候自动删除</td><td>create -e /test</td></tr><tr><td align="left">临时序号节点</td><td>临时节点会在客户端删除的时候自动删除，创建的时候会在路径上加上序号作为后缀比如/test会创建出/test00000001</td><td>create -e -s /test</td></tr><tr><td align="left">Container节点</td><td>Container节点目录下没有子节点会在zookeeper内部的定时任务轮训下自动删除,（刚开始的没有不算，只有有了子节点后被清除才会有之前的逻辑）</td><td>create ‐c /test</td></tr><tr><td align="left">TTL 节点</td><td>禁用，需在系统配置增加 zookeeper.extendedTypesEnabled=true，</td><td>create ‐t 500 /test</td></tr></tbody></table><h2 id="Zookeeper-ACL-权限控制"><a href="#Zookeeper-ACL-权限控制" class="headerlink" title="Zookeeper ACL 权限控制"></a>Zookeeper ACL 权限控制</h2><p>权限信息</p><ul><li>创建权限（c: create）:授予权限的对象可以在数据节点下创建子节点</li><li>更新权限（w: wirte）:授予权限的对象可以更新该数据节点</li><li>读取权限（r: read）：授予权限的对象可以读取该节点的内容以及子节点的列表信息</li><li>删除权限（d: delete）：授予权限的对象可以删除该数据节点的子节点</li><li>管理者权限（a: admin）：授予权限的对象可以对该数据节点体进行 ACL 权限设置</li></ul><p>ACL的设置有2种方式：</p><ol><li><p>创建节点的时候直接设置</p><pre class=" language-shell"><code class="language-shell">create /test-node datatest digest:test:V28q/NynI4JI3Rk54h0r8O5kMug=:cdrwa</code></pre></li><li><p>单独设置</p><pre class=" language-shell"><code class="language-shell">setAcl /test-node digest:test:V28q/NynI4JI3Rk54h0r8O5kMug=:cdrwa</code></pre><p>授权过后不能直接访问需要授权才能访问</p><p>授权</p><pre class=" language-shell"><code class="language-shell">addauth digest test:test</code></pre><p>上诉授权是密文，如果想要明文授权我们需要先获取权限在进行授权</p><pre class=" language-shell"><code class="language-shell">addauth digest test:testcreate /test-node1 test auth:test:test:cdwra</code></pre><p>最后还有一种授权方式是对ip进行授权</p><pre class=" language-shell"><code class="language-shell">create /test-node2 data ip:192.168.186.131:cdwrasetAcl /test-node2 ip:192.168.186.131:cdwra</code></pre></li></ol><p>超级管理员模式</p><p>启动脚本添加</p><p><strong>-Dzookeeper.DigestAuthenticationProvider.superDigest=zk:N0YquoLgOZWu74hzsd3OJTZZUw0=</strong></p><p>具体可看zookeeper安装博文</p><h2 id="ZooKeeper集群"><a href="#ZooKeeper集群" class="headerlink" title="ZooKeeper集群"></a>ZooKeeper集群</h2><p>ZooKeeper集群主要解决的是<strong>高可用</strong>、<strong>读写分离提高承载能力</strong>。ZooKeeper集群必须保证有<strong>至少三个节点</strong>，不然部署失败</p><p>集群角色</p><table><thead><tr><th></th><th>角色名称</th><th>功能</th></tr></thead><tbody><tr><td>leader</td><td>主节点，领导者</td><td>写数据，通过选举产生</td></tr><tr><td>follower</td><td>从节点，追随者</td><td>读数据，主节点的备选节点，拥有投票权</td></tr><tr><td>observer</td><td>次级子节点，观察者</td><td>读数据，无投票权，不能选举为主节点，计算集群可用状态不会将其计算在内</td></tr></tbody></table><h3 id="数据提交机制"><a href="#数据提交机制" class="headerlink" title="数据提交机制"></a>数据提交机制</h3><p>ZooKeeper是一个CP架构，它专注于的是一致性，为什么它拥有一致性？</p><p>流程：客户端会向服务端发起写请求，如果请求对象不是主节点，从节点会把请求转发给主节点，数据写进主节点，主节点发送请求proposal给从节点，从节点写进事务日志后给主节点一个ack，主节点统计ack数量，如果ack数量是集群半数以上，主节点又会发起一个commit请求给客户端，客户端记录事务提交，并把数据更新到内存中去，主节点告诉客户端我写好了，在同步数据这段时间，ZooKeeper对于客户端而言是不可用的，多以它不满足可用性，所以他是CP架构。</p><p>在集群运行过程当中如果有一个follower节点宕机，由于宕机节点没过半，集群仍然能正常服务。当leader收到新的客户端请求，此时无法同步给宕机的节点。造成数据不一致。为了解决这个问题，当节点启动时，第一件事情就是找当前的Leader，比对数据是否一致。不一致则开始同步,同步完成之后在进行对外提供服务。 </p><p><strong>如何比对Leader的数据版本呢？</strong>这里通过ZXID事物ID来确认。比Leader就需要同步。</p><p>ZXID： ZXID是一个长度64位的数字，其中低32位是按照数字递增，任何数据的变更都会导致,低32位的数字简单加1。高32位是leader周期编号，每当选举出一个新的leader时，新的leader就从本地事物日志中取出ZXID,然后解析出高32位的周期编号，进行加1，再将低32位的全部设置为0。这样就保证了每次新选举的leader后，保证了ZXID的唯一性而且是保证递增的。</p><h3 id="集群选举机制"><a href="#集群选举机制" class="headerlink" title="集群选举机制"></a>集群选举机制</h3><ul><li><h4 id="选票pk成功的条件"><a href="#选票pk成功的条件" class="headerlink" title="选票pk成功的条件"></a>选票pk成功的条件</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// FastLeaderElection.totalOrderPredicate</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newEpoch <span class="token operator">></span> curEpoch<span class="token punctuation">)</span> <span class="token operator">||</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>newEpoch <span class="token operator">==</span> curEpoch<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>newZxid <span class="token operator">></span> curZxid<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newZxid <span class="token operator">==</span> curZxid<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>newId <span class="token operator">></span> curId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>从代码可以看出</p><p>选举成功3个条件符合其一</p><ol><li>选举周期大的</li><li>周期相等选事务id大的</li><li>周期相等，事务id相等，选serverid大的，serverid就是配置文件配的集群server.*,也就是myid</li></ol><h4 id="选举成功的条件"><a href="#选举成功的条件" class="headerlink" title="选举成功的条件"></a>选举成功的条件</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// FastLeaderElection.termPredicate</span>voteSet<span class="token punctuation">.</span><span class="token function">hasAllQuorums</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// hasAllQuorums</span><span class="token operator">!</span>qvAckset<span class="token punctuation">.</span><span class="token function">getQuorumVerifier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">containsQuorum</span><span class="token punctuation">(</span>qvAckset<span class="token punctuation">.</span><span class="token function">getAckset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// QuorumMaj.containsQuorum</span><span class="token punctuation">(</span>ackSet<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> half<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// QuorumMaj</span>half <span class="token operator">=</span> votingMembers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre><p>从这段代码可以看出选举成功就是对某一节点的选票超过半数即为选举成功</p><h4 id="选举触发条件"><a href="#选举触发条件" class="headerlink" title="选举触发条件"></a>选举触发条件</h4><ul><li><p>节点初始化启动时</p><p>节点启动的时候会在集群中寻找是否有leader,找到了就与leader建立通信，自身变为follower或observer,没有找到Leader,当前节点记录为LOOKING，开始选举</p></li><li><p>半数以上节点无法和Leader建立通信</p><p>Leader一挂，只要有半数节点感知到Leader挂了，就所有follower进入到LOOKING状态，开始选举</p></li></ul><h4 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h4><p>每个节点启动后都会默认给自己投票，收到其他节点会通过选票pk成功的条件判断谁获胜了，当前节点会更改自己的选票为获胜方，下一轮选举会发给其他节点，最后统计选票，选票超过半数即为LEADING，若自己节点不是LEADING节点就是FOLLOWER或OBSERVER。</p><p>如果集群已经选举完成，新节点加入集群，会首先发送选票给其他节点，其他节点接收到选票后由于已经有LEADING，会把LEADING节点发送给新节点，新节点更改为FOLLOWER.</p></li></ul><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ul><li><p>为什么建议集群奇数个节点？</p><p>节省资源，3节点和4节点都是挂2个节点不可用，所以用4个节点站在可用性的角度来看没意义</p></li><li><p>为什么要有半数机制？</p><p>脑裂问题，假设你有4个节点，由于网络抖动分裂成了2个集群，然后这2个集群都会进行选举，会选举出2个leader,网络恢复后就有2个leader，肯定是有问题的，但半数机制就保证了这种问题不会发生，就算网络抖动也只会选举出一个leader</p></li></ul><h2 id="ZooKeeper使用场景"><a href="#ZooKeeper使用场景" class="headerlink" title="ZooKeeper使用场景"></a>ZooKeeper使用场景</h2><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>在单体应用中，我们可以用synchronized或者ReentrantLock来实现锁机制。但在分布式应用中不行，因为synchronized或者ReentrantLock只针对于一个JVM中可以使用。所以我们必须使用分布式锁来实现锁机制。可以使用Redis或ZooKeeper实现，Redis就不多说了。</p><p>实现分布式锁的主要逻辑就是利用临时序号节点，我创建一个临时序号节点，继续创建临时序号节点会自增最后形成一堆有序的节点，通过序号我们可以知道哪个节点在前哪个节点在后，序号最小的节点才有资格拿锁，后一个节点监听前一个节点，当前一个节点被删除了，我后一个节点就可以去尝试激活锁了。</p><p>这里为什么不直接每个节点监听加锁节点，加锁节点删除在找到最小序号去加锁呢？</p><p>这里主要是防止羊群效应，一旦加锁节点被释放就会有大量的节点被触发，然后反查Lock子节点可能会让zookeeper承受巨大的压力。</p><p>这里写一个简单的demo</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> String server <span class="token operator">=</span> <span class="token string">"你的zookeeper地址"</span><span class="token punctuation">;</span><span class="token keyword">private</span> ZkClient zkClient<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String rootPath <span class="token operator">=</span> <span class="token string">"/dm-lock"</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">ZookeeperLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    zkClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZkClient</span><span class="token punctuation">(</span>server<span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建根节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>zkClient<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>rootPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        zkClient<span class="token punctuation">.</span><span class="token function">createPersistent</span><span class="token punctuation">(</span>rootPath<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 加锁 */</span><span class="token keyword">public</span> Lock <span class="token function">lock</span><span class="token punctuation">(</span>String lockId<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建临时序号节点</span>    Lock lockNode <span class="token operator">=</span> <span class="token function">createLockNode</span><span class="token punctuation">(</span>lockId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 尝试拿锁</span>    lockNode <span class="token operator">=</span> <span class="token function">tryActiveLock</span><span class="token punctuation">(</span>lockNode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 没有拿到锁</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lockNode<span class="token punctuation">.</span><span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 把线程hang在这里然后等待监听事件触发，拿到锁，释放线程</span>                <span class="token comment" spellcheck="true">// 在tryActiveLockelse逻辑里面</span>                lockNode<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 线程hang住的时间里面还没拿到锁就抛异常</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lockNode<span class="token punctuation">.</span><span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"lock timeout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> lockNode<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 释放锁 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span>Lock lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        zkClient<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 尝试激活锁 */</span><span class="token keyword">private</span> Lock <span class="token function">tryActiveLock</span><span class="token punctuation">(</span>Lock lockNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//  获取根节点下面所有的排好序的子节点</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> zkClient<span class="token punctuation">.</span><span class="token function">getChildren</span><span class="token punctuation">(</span>rootPath<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">></span> rootPath <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> p<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 取最小的节点，这个节点就应该是应该加锁的节点</span>    String firstNodePath <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 最小节点是不是当前节点,是就直接加锁</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstNodePath<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>lockNode<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lockNode<span class="token punctuation">.</span><span class="token function">setActive</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 取得当前节点减一，要监听这个节点</span>        String upNodePath <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>lockNode<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        zkClient<span class="token punctuation">.</span><span class="token function">subscribeDataChanges</span><span class="token punctuation">(</span>upNodePath<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">IZkDataListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDataChange</span><span class="token punctuation">(</span>String dataPath<span class="token punctuation">,</span> Object data<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 前一个节点被释放回调</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDataDeleted</span><span class="token punctuation">(</span>String dataPath<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 重新尝试拿锁</span>                Lock lock <span class="token operator">=</span> <span class="token function">tryActiveLock</span><span class="token punctuation">(</span>lockNode<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 之前同步块的线程释放</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        lockNode<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                zkClient<span class="token punctuation">.</span><span class="token function">unsubscribeDataChanges</span><span class="token punctuation">(</span>upNodePath<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> lockNode<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 创建临时序号节点 */</span><span class="token keyword">public</span> Lock <span class="token function">createLockNode</span><span class="token punctuation">(</span>String lockId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String nodePath <span class="token operator">=</span> zkClient<span class="token punctuation">.</span><span class="token function">createEphemeralSequential</span><span class="token punctuation">(</span>rootPath <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> lockId<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Lock</span><span class="token punctuation">(</span>lockId<span class="token punctuation">,</span> nodePath<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当然这里的代码还是会有一些问题的，比如重试机制的处理，幽灵节点的处理，这里只是更好的理解分布式锁，建议直接使用Curator客户端。</p><h3 id="Curator分布式锁使用及源码"><a href="#Curator分布式锁使用及源码" class="headerlink" title="Curator分布式锁使用及源码"></a>Curator分布式锁使用及源码</h3><p>基本使用</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 配置类</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CuratorConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"start"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> CuratorFramework <span class="token function">curatorFramework</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        RetryPolicy retryPolicy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExponentialBackoffRetry</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> CuratorFrameworkFactory<span class="token punctuation">.</span><span class="token function">newClient</span><span class="token punctuation">(</span>ZookeeperConstants<span class="token punctuation">.</span>SERVER<span class="token punctuation">,</span> retryPolicy<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MutexLock</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    CuratorFramework curatorFramework<span class="token punctuation">;</span>    <span class="token keyword">public</span> Object <span class="token function">handler</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        InterProcessMutex interProcessMutex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessMutex</span><span class="token punctuation">(</span>curatorFramework<span class="token punctuation">,</span> <span class="token string">"/product_"</span><span class="token operator">+</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            interProcessMutex<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 模拟业务执行</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            interProcessMutex<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">"ok"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>原理和之前使用的zkClient原理基本一致</p><ol><li>请求进来，没有根节点，创建容器节点作为根节点，</li><li>在跟节点下创建临时序号节点</li><li>判断节点是不是最小的节点，是最小的节点直接获取锁，不是就监听前一个节点</li><li>获得锁的请求，处理完业务代码释放锁删除节点然后监听它的节点收到通知，走第三步</li></ol><p>源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 从interProcessMutex.acquire();进入代码</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">internalLock</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span><span class="token string">"Lost connection while trying to acquire lock: "</span> <span class="token operator">+</span> basePath<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">internalLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*           Note on concurrency: a given lockData instance           can be only acted on by a single thread so locking isn't necessary        */</span>    <span class="token comment" spellcheck="true">// 获取当前线程</span>    Thread currentThread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// threadData是一个Map,key是当前线程，value是LocalData LocalData里面主要是加锁路径和加锁次数</span>    LockData lockData <span class="token operator">=</span> threadData<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 不是空说明当前线程已经获得锁了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> lockData <span class="token operator">!=</span> null <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// re-entering</span>        <span class="token comment" spellcheck="true">// 这里对LocalData里面的lockCount自增，这里说明了锁的可重入特性</span>        lockData<span class="token punctuation">.</span>lockCount<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这里是加锁逻辑，主要方法是attemptLock</span>    String lockPath <span class="token operator">=</span> internals<span class="token punctuation">.</span><span class="token function">attemptLock</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> <span class="token function">getLockNodeBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 加锁成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> lockPath <span class="token operator">!=</span> null <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 加锁信息放进threadData里面</span>        LockData newLockData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockData</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">,</span> lockPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        threadData<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">,</span> newLockData<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>attemptLock方法：</p><pre class=" language-java"><code class="language-java">String <span class="token function">attemptLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lockNodeBytes<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">long</span>      startMillis <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> Long      millisToWait <span class="token operator">=</span> <span class="token punctuation">(</span>unit <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    localLockNodeBytes <span class="token operator">=</span> <span class="token punctuation">(</span>revocable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">:</span> lockNodeBytes<span class="token punctuation">;</span>    <span class="token keyword">int</span>             retryCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    String          ourPath <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">boolean</span>         hasTheLock <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span>         isDone <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">!</span>isDone <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        isDone <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">try</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 主要逻辑</span>            <span class="token comment" spellcheck="true">// 加锁逻辑</span>            ourPath <span class="token operator">=</span> driver<span class="token punctuation">.</span><span class="token function">createsTheLock</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> path<span class="token punctuation">,</span> localLockNodeBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 判断节点是不是最小的节点，是最小的节点直接获取锁，不是就监听前一个节点</span>            hasTheLock <span class="token operator">=</span> <span class="token function">internalLockLoop</span><span class="token punctuation">(</span>startMillis<span class="token punctuation">,</span> millisToWait<span class="token punctuation">,</span> ourPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span> KeeperException<span class="token punctuation">.</span>NoNodeException e <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// gets thrown by StandardLockInternalsDriver when it can't find the lock node</span>            <span class="token comment" spellcheck="true">// this can happen when the session expires, etc. So, if the retry allows, just try it all again</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> client<span class="token punctuation">.</span><span class="token function">getZookeeperClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRetryPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">allowRetry</span><span class="token punctuation">(</span>retryCount<span class="token operator">++</span><span class="token punctuation">,</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startMillis<span class="token punctuation">,</span> RetryLoop<span class="token punctuation">.</span><span class="token function">getDefaultRetrySleeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>            <span class="token punctuation">{</span>                isDone <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">throw</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> hasTheLock <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> ourPath<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>加锁逻辑createsTheLock方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">createsTheLock</span><span class="token punctuation">(</span>CuratorFramework client<span class="token punctuation">,</span> String path<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lockNodeBytes<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    String ourPath<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> lockNodeBytes <span class="token operator">!=</span> null <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        ourPath <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">creatingParentContainersIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withProtection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withMode</span><span class="token punctuation">(</span>CreateMode<span class="token punctuation">.</span>EPHEMERAL_SEQUENTIAL<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> lockNodeBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这里会创建一个根节点是容器节点（子节点全部删完会删除父节点，子节点全部删了就没有必要维护父节点了，所以直接删除掉），还有子节点是临时序号节点</span>        ourPath <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">creatingParentContainersIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withProtection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withMode</span><span class="token punctuation">(</span>CreateMode<span class="token punctuation">.</span>EPHEMERAL_SEQUENTIAL<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ourPath<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>internalLockLoop：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">internalLockLoop</span><span class="token punctuation">(</span><span class="token keyword">long</span> startMillis<span class="token punctuation">,</span> Long millisToWait<span class="token punctuation">,</span> String ourPath<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 是否获取锁</span>    <span class="token keyword">boolean</span>     haveTheLock <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span>     doDelete <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">try</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> revocable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            client<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">usingWatcher</span><span class="token punctuation">(</span>revocableWatcher<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span>ourPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 自旋直至获得锁，或者到达超时时间</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>client<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> CuratorFrameworkState<span class="token punctuation">.</span>STARTED<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>haveTheLock <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取所有子节点并排序</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span>        children <span class="token operator">=</span> <span class="token function">getSortedChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 处理当前节点把父路径截取仅获取后面，sequenceNodeName在children列表中</span>            String              sequenceNodeName <span class="token operator">=</span> ourPath<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>basePath<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// +1 to include the slash</span>            <span class="token comment" spellcheck="true">// 判断节点是否是最小</span>            PredicateResults    predicateResults <span class="token operator">=</span> driver<span class="token punctuation">.</span><span class="token function">getsTheLock</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> children<span class="token punctuation">,</span> sequenceNodeName<span class="token punctuation">,</span> maxLeases<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获取锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> predicateResults<span class="token punctuation">.</span><span class="token function">getsTheLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 更新flag</span>                haveTheLock <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 没有拿到锁开启监听</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 监听节点</span>                String  previousSequencePath <span class="token operator">=</span> basePath <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> predicateResults<span class="token punctuation">.</span><span class="token function">getPathToWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 加锁等待，watcher里面会释放锁，继续while循环</span>                <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token keyword">try</span>                    <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// use getData() instead of exists() to avoid leaving unneeded watchers which is a type of resource leak</span>                        <span class="token comment" spellcheck="true">// 监听</span>                        client<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">usingWatcher</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span>previousSequencePath<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 有millisToWait就等待一段时间</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span> millisToWait <span class="token operator">!=</span> null <span class="token punctuation">)</span>                        <span class="token punctuation">{</span>                            millisToWait <span class="token operator">-=</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>                            startMillis <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span> millisToWait <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">)</span>                            <span class="token punctuation">{</span>                                doDelete <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// timed out - delete our node</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token function">wait</span><span class="token punctuation">(</span>millisToWait<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">// 一直等待</span>                        <span class="token keyword">else</span>                        <span class="token punctuation">{</span>                            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">catch</span> <span class="token punctuation">(</span> KeeperException<span class="token punctuation">.</span>NoNodeException e <span class="token punctuation">)</span>                    <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// it has been deleted (i.e. lock released). Try to acquire again</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span> Exception e <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        ThreadUtils<span class="token punctuation">.</span><span class="token function">checkInterrupted</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        doDelete <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">finally</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> doDelete <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">deleteOurPath</span><span class="token punctuation">(</span>ourPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> haveTheLock<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>getsTheLock方法：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 判断节点是否是最小</span><span class="token keyword">public</span> PredicateResults <span class="token function">getsTheLock</span><span class="token punctuation">(</span>CuratorFramework client<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> children<span class="token punctuation">,</span> String sequenceNodeName<span class="token punctuation">,</span> <span class="token keyword">int</span> maxLeases<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 看sequenceNodeName在children中的位置</span>    <span class="token keyword">int</span>             ourIndex <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>sequenceNodeName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">validateOurIndex</span><span class="token punctuation">(</span>sequenceNodeName<span class="token punctuation">,</span> ourIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// maxLeases是1的逻辑在LockInternals的构造方法中。</span>    <span class="token comment" spellcheck="true">// maxLeases是1，只要ourIndex是0就表示最小，这里是互斥锁，如果是读写锁maxLeases就不是1后面会说到</span>    <span class="token keyword">boolean</span>         getsTheLock <span class="token operator">=</span> ourIndex <span class="token operator">&lt;</span> maxLeases<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 要监听的节点如果拿到锁了不监听pathToWatch是null.否则监听前一个节点</span>    String          pathToWatch <span class="token operator">=</span> getsTheLock <span class="token operator">?</span> null <span class="token operator">:</span> children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ourIndex <span class="token operator">-</span> maxLeases<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 基本信息封装</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PredicateResults</span><span class="token punctuation">(</span>pathToWatch<span class="token punctuation">,</span> getsTheLock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="分布式注册中心"><a href="#分布式注册中心" class="headerlink" title="分布式注册中心"></a>分布式注册中心</h3><p>在这里，首先得了解注册中心是什么？单体应用升级到分布式应用，肯定会有成千上万个服务节点不同的客户端会调用这些服务节点，如果把这些服务节点配置到客户端的话会很复杂，这时候就需要一个中间件来帮助我们找到我们需要调用的服务，这就是服务发现。</p><p>一般注册中心需要一下几个功能，服务注册，服务发现，服务订阅</p><ul><li>服务注册：服务刚启动将自己的信息注册到注册中心</li><li>服务发现：客户端通过注册中心找到自己要调用的服务，然后通过RPC进行调用</li><li>服务订阅：能动态感知服务的变化</li></ul><p>我们可以把注册的服务写成临时节点，只要服务一下线就会自动删除对应的服务。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty线程模型初探和Netty的常见问题</title>
      <link href="2020/09/07/netty-xian-cheng-mo-xing-chu-tan-he-netty-de-chang-jian-wen-ti/"/>
      <url>2020/09/07/netty-xian-cheng-mo-xing-chu-tan-he-netty-de-chang-jian-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Netty是现在比较流行的NIO框架。它的健壮性、可扩展性、性能方面都得到了很多项目的验证。</p><p>要想了解Netty，首先得了解IO模型。Java支持三种IO模型分别是BIO,NIO,AIO。</p><ul><li>BIO：同步阻塞模型，连接一个请求就会有一个线程，假设有个客户端连接进来了，一直不做读写操作，这个连接就会一直占用，会大量的浪费资源，，如果连接的客户端巨多，就会导致线程数暴增，可能服务器都撑不住。使用场景，连接数比较小且不会有连接数暴增</li><li>NIO：同步非阻塞模型，主要实现的是一个线程可以处理多个连接，它的实现逻辑是把所有打过来的请求都会丢到一个selector（多路复用器）上面去，多路复用器在去轮询，根据请求类型进行读、写、连接处理。多路复用器底层就是调用的操作系统的select，poll，epoll方法实现。使用场景：连接数多但连接较短。</li><li>AIO：异步非阻塞模型，发起请求后会回调服务端程序去执行对应的请求，相当于一个钩子程序，NIO的升级版。使用场景：连接数多，且连接耗时较长</li></ul><h2 id="认识Netty"><a href="#认识Netty" class="headerlink" title="认识Netty"></a>认识Netty</h2><p>Netty说白了就是对NIO的一层封装，改造了原来的IO模型提升性能，为了让你代码写起来更方便，增强扩展性。</p><p>Netty在游戏领域，开源中间件（Dubbo,RocketMQ）,大数据领域(Hadoop)，通信行业等方向都有不少的应用。</p><p>Netty优点</p><ul><li>使用简单</li><li>功能强大，内置了很多编解码功能，对主流协议的支持</li><li>定制能力强，可以通过ChannelHandler进行定制化开发</li><li>性能高</li><li>经历了多种行业的锤炼，证明了它的稳定性</li></ul><h2 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h2><p>Netty线程模型跟Reactor模式相一致。而Reacror模式又分为三种。主要核心逻辑可以参照Doug Lea大佬的<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable IO in Java</a></p><ul><li><p>单线程模型</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20200907215427.png" alt="单线程模型"></p><p>从图可以看出Reactor内部通过selector进行监控，如果收到的是一个连接请求就通过dispatch分发任务给acceptor去处理并生成一个handler去处理之后的读写请求。因为处理连接和读写请求都在一个线程里面去执行，所以如果handler被阻塞了,会导致其他的线程同样不能执行，性能受到影响。</p></li><li><p>多线程模型</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20200907220454.png" alt="多线程模型"></p><p>从图看出，Reactor收到一个连接请求就分发给acceptor,然后acceptor创建一个Handler处理后续事件Handler不处理业务操作，只负责响应度和写，业务操作扔到线程池里面去操作。这里的性能瓶颈是单Reactor，当有大量的客户端进行连接，可能会有处理不过来的情况。</p></li><li><p>主从多线程模型</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/image-20200907221055477.png" alt="主从多线程模型"></p></li></ul><p>这里使用了多个Reactor,mainReactor处理进来的连接请求，交给acceptor处理，然后acceptor将新的连接分配给一个子线程，子线程subReactor将分配过来的连接加入连接队列并通过自己的selector进行监听，并创建一个Handler处理后续事件。</p><p>对于Netty而言上诉几种模型都可以实现。主要看NioEventLoopGroup线程个数的分配。</p><p>单线程模型</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 只申请一个工作线程</span>NioEventLoopGroup group <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bootstrap<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>group<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServerHandlerInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>多线程模型</p><pre class=" language-java"><code class="language-java">NioEventLoopGroup eventGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bootstrap<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>eventGroup<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServerHandlerInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>主从多线程模型(最常用)</p><pre class=" language-java"><code class="language-java">NioEventLoopGroup bossGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>NioEventLoopGroup workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bootstrap<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>bossGroup<span class="token punctuation">,</span>workerGroup<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServerHandlerInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Netty的线程模型是对于上诉的Reactor模式进行了一定的升级，但核心思想没有变。</p><p><a href="https://www.processon.com/view/link/5ee107f7f346fb1ae5592b33">Netty线程模型图</a></p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/clipboard.png" alt="Netty线程模型架构"></p><h2 id="Netty相关组件"><a href="#Netty相关组件" class="headerlink" title="Netty相关组件"></a>Netty相关组件</h2><p>Netty的一个服务端通用代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    EventLoopGroup bossGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    EventLoopGroup workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bootstrap<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>bossGroup<span class="token punctuation">,</span> workerGroup<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token operator">&lt;</span>SocketChannel<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span>SocketChannel ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                    ChannelPipeline pipeline <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"decoder"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"encoder"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ChannelFuture channelFuture <span class="token operator">=</span> bootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">9000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channelFuture<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        bossGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        workerGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>Selector：通过Selector监听多个连接的channel事件，通过selector轮训所有注册的channel,</li><li>NioEventLoopGroup：相当于一个线程池，内部维护类一组线程（NioEventLoop），每个线程处理多个Channel上的事件。</li><li>NioEventLoop：里面有线程和任务队列，有run方法处理不同的事件</li><li>ServerBootstrap：串联Netty所有组件，是Netty的启动类。</li><li>ChannelHandler：ChannelHandler处理I/O事件，并将其转发到pipeline中的下一个处理程序<ul><li>ChannelInboundHandler：处理入站IO事件</li><li>ChannelOutboundHandler：处理出站IO事件</li></ul></li><li>ChannelHandlerContext：关联ChannelHandler</li><li>ChannelPipline：一个由ChannelHandlerContext构成的过滤器链，它是一个双向链表,他会维护一个head和tail,入站则是head-&gt;tail,出站是tail到head,<strong>注意：入站和出站在这里是相对的，read是入站事件，write是出站事件，服务端写数据到客户端，服务端是出站事件，客户端是入站事件</strong></li></ul><h2 id="Netty常见问题"><a href="#Netty常见问题" class="headerlink" title="Netty常见问题"></a>Netty常见问题</h2><h3 id="编解码问题"><a href="#编解码问题" class="headerlink" title="编解码问题"></a>编解码问题</h3><pre class=" language-java"><code class="language-java"> ChannelPipeline pipeline <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"decoder"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 解码器</span> pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"encoder"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 编码器</span> pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>首先服务器之间的通讯只能是字节，然后我们要把消息发送到客户端，首先要对发送内容进行编码，客户端要对收到内容进行解码.上诉代码就是一个编解码的pipeline.通过分析StringEncoder编码器应该继承的是ChannelOutboundHandlerAdapter或者实现了ChannelOutboundHandler满足出站事件。StringDecoder解码器应该继承的是ChannelInboundHandlerAdapter或者实现了ChannelInboundHandler满足入站事件。看一下继承关系图，发现分析正确</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20200907231616.png" alt="StringDecoder继承关系图"></p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20200907231755.png" alt="StringEncoder继承关系图"></p><p>Netty还有其他的编解码器，比如ObjectEncoder和ObjectDecoder</p><h3 id="粘包拆包问题"><a href="#粘包拆包问题" class="headerlink" title="粘包拆包问题"></a>粘包拆包问题</h3><p>由于TCP是面向流的，所以是无消息保护边界的。发送端有时为了更有效地将数据包发送给对方，有时会把多个数据包合并为一个发送就是粘包问题，把一个数据包拆分成多个就是拆包问题。这样带来的问题就是虽然你是提高了效率，但是接收端这边就无法分清哪个数据包是哪个了。</p><p>解决方案：</p><ol><li>对发送内容进行边界控制，就是在你所发送的内容开始与结束加上标志符。但这样不好用，因为每次开发你都的加上边界符，不易于其他人对代码的理解。</li><li>在你所发送的内容上加上发送内容的长度，通过长度判断数据的开始与结束。</li></ol><h3 id="Netty零拷贝"><a href="#Netty零拷贝" class="headerlink" title="Netty零拷贝"></a>Netty零拷贝</h3><p>在零拷贝之前必须了解直接内存与堆内存的区别；堆内存顾名思义就是放在JVM堆里面的内存,直接内存是排除掉堆内存的其他内存相当于物理内存，gc不参与到其中，这部分内存JVM管不着；</p><p>申请直接内存：java申请直接内存会调用本地native方法，在物理内存上申请一块空间，然后自己JVM堆内存上也分配一块叫DirectByteBuffer的空间，DirectByteBuffer里面会存申请的物理内存的内存地址的开始位置，和数据长度，通过定位和长度就能确定数据了。</p><p>内存回收：JVM gc 管不了他们那么怎么将这部分内存进行回收呢？在申请直接内存的时候会给引用对象绑定一个Cleaner机制，就是只要引用对象一被GC,那么就会触发Cleaner机制把内存回收。</p><p>直接内存与堆内存对比：读写上直接内存更快；申请空间上堆内存更快。</p><p>下面可以介绍零拷贝了</p><p>我们客户端发一条数据到服务端，服务端需要在IO读写层面需要做哪些操作呢？</p><p>假设没有零拷贝，发生的情况就是客户端发一条数据到服务端，服务端将这条数据放到socket缓冲区然后拷贝到直接内存（数据不能直接给堆内存），然后直接内存把数据拷贝到JVM堆内存，然后JVM对数据进行修改后在将数据拷贝到直接内存（数据不能直接给socket缓冲区）,然后直接内存把数据拷贝到socket缓冲区。大家数一下中间发生了几次拷贝。共4次拷贝，</p><p>以刚刚的例子来说零拷贝技术就是客户端发一条数据到服务端，服务端将这条数据socket缓冲区然后拷贝到直接内存，然后堆内存会有一个DirectByteBuffer映射到这一块直接内存，然后JVM对数据进行修改将数据直接改到直接内存，然后直接内存拷贝给socket缓冲区总共发生2次拷贝，零拷贝就是减少数据之间的拷贝。</p><h4 id="直接内存优缺点"><a href="#直接内存优缺点" class="headerlink" title="直接内存优缺点"></a>直接内存优缺点</h4><p>优点：</p><pre><code>        * 不占用堆内存        * 内存读写快</code></pre><p>缺点</p><ul><li>申请空间慢</li><li>有物理内存被撑爆的可能性，这就跟JVM元空间内存机制是一样的，元空间也是直接内存，然后元空间必须设置最大值一个道理。在这里我们可以和元空间的处理类似，加上一个配置参数-XX：MaxDirectMemorySize控制直接内存的大小</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> IO模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap1.7和1.8对比与源码解析</title>
      <link href="2020/09/01/hashmap/"/>
      <url>2020/09/01/hashmap/</url>
      
        <content type="html"><![CDATA[<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p><strong>put过程</strong>：它会hash传入的key值，将hash的值&amp;上map长度减一（这里用的是&amp;而不是取模运算，应该是考虑到性能问题，这里是length-1是应为这样可以取到0到map.length-1的值）插入到对应的数组下标上面去。这时产生了一个问题就是2个key值hash到一个位置怎么办？这就是Hash碰撞，产生了Hash碰撞在当前数组位置产生一个链表，如果链表过长查询效率可能会减低，在jdk1.8上面达到了一定的程度会链表转红黑树增强查询效率。</p><p><strong>get过程</strong>：hash传入的key值，将hash的值&amp;上map长度减一在数组里面去找找到对应的数组位置如果不是传入的key值就顺着链表或红黑树继续往里面找，所以他的时间复杂度是O(1)。</p><p><strong>扩容</strong>：当数据达到map总长度的加载因子倍数就会开始扩容</p><h2 id="基本参数介绍"><a href="#基本参数介绍" class="headerlink" title="基本参数介绍"></a>基本参数介绍</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 数组默认大小，默认为16，必须设值为2的n次幂，如果设值不是2的n次幂它会往大于你的值的最近的2次幂</span><span class="token comment" spellcheck="true">// 比如你设map长度为9它会修改map长度为2的4次，也就是16</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 加载因子，数组长度大于容量的0.75就会扩容，为什么是9.75？基于空间与时间的考虑，如果太满了可能会有很多的hash碰撞，hash碰撞越多，链表就会越长，查询效率就会太低，加载因子如果太小了就会导致扩容频繁，通过牛顿二项式推导得出，0.693是最为合适的值，java选择了0.75</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span></code></pre><h2 id="jdk1-7和jdk1-8对比"><a href="#jdk1-7和jdk1-8对比" class="headerlink" title="jdk1.7和jdk1.8对比"></a>jdk1.7和jdk1.8对比</h2><h3 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><p>数据结构：数组+链表</p><p>扩容：1.7的扩容会先把当前数组长度乘2生成一个新数组，然后对原来的Map里面的值进行reHash.重新落入到新数组中。</p><p>链表插入方式：尾插法</p><h3 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p>数据结构：数组+链表+红黑树</p><p>扩容：1.8的扩容有个高低位的概念，它将原来的key Hash过后&amp;map长度,这时候会生成2种值要么是0，要么是数组长度，这时候是0的我们算作低位，数组长度的算作高位，这时候我们有2个链表一个低位链表一个高位链表，低位链表还是在原来的位置，高位链表移到原来位置加上数组长度的位置。</p><p>链表插入方式：尾插法</p><p>链表转红黑树判定：链表长度<strong>大于8,也就是第9个元素</strong>，还有一个条件是容量大于64</p><p>​    为什么要把阈值设为8呢？</p><p>​    下面是HashMap源码里面的注释。大致意思就是数组中链表长度达到相应的数字概率是多少（这里是通过泊松分布计算得出），前提是随机hash码和加载因子是0.75.可以看出来到8的时候概率是很低了。从这一方面可以看出HashMap正常情况下转红黑树的几率是极其小的。也可以侧面的反映出HashMap在1.7到1.8性能上的提升其实并不大，数据量极大的情况下是有提升的。</p><pre class=" language-java"><code class="language-java"><span class="token operator">*</span> Because TreeNodes are about twice the size of regular nodes<span class="token punctuation">,</span> we<span class="token operator">*</span> use them only when bins contain enough nodes to warrant use<span class="token operator">*</span> <span class="token punctuation">(</span>see TREEIFY_THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">.</span> And when they become too <span class="token function">small</span> <span class="token punctuation">(</span>due to<span class="token operator">*</span> removal or resizing<span class="token punctuation">)</span> they are converted back to plain bins<span class="token punctuation">.</span>  In<span class="token operator">*</span> usages with well<span class="token operator">-</span>distributed user hashCodes<span class="token punctuation">,</span> tree bins are<span class="token operator">*</span> rarely used<span class="token punctuation">.</span>  Ideally<span class="token punctuation">,</span> under random hashCodes<span class="token punctuation">,</span> the frequency of<span class="token operator">*</span> nodes in bins follows a Poisson distribution<span class="token operator">*</span> <span class="token punctuation">(</span>http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>en<span class="token punctuation">.</span>wikipedia<span class="token punctuation">.</span>org<span class="token operator">/</span>wiki<span class="token operator">/</span>Poisson_distribution<span class="token punctuation">)</span> with a<span class="token operator">*</span> parameter of about <span class="token number">0.5</span> on average <span class="token keyword">for</span> the <span class="token keyword">default</span> resizing<span class="token operator">*</span> threshold of <span class="token number">0.75</span><span class="token punctuation">,</span> although with a large variance because of<span class="token operator">*</span> resizing granularity<span class="token punctuation">.</span> Ignoring variance<span class="token punctuation">,</span> the expected<span class="token operator">*</span> occurrences of list size k <span class="token function">are</span> <span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span> The first values are<span class="token operator">:</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">0</span><span class="token operator">:</span>    <span class="token number">0.60653066</span><span class="token operator">*</span> <span class="token number">1</span><span class="token operator">:</span>    <span class="token number">0.30326533</span><span class="token operator">*</span> <span class="token number">2</span><span class="token operator">:</span>    <span class="token number">0.07581633</span><span class="token operator">*</span> <span class="token number">3</span><span class="token operator">:</span>    <span class="token number">0.01263606</span><span class="token operator">*</span> <span class="token number">4</span><span class="token operator">:</span>    <span class="token number">0.00157952</span><span class="token operator">*</span> <span class="token number">5</span><span class="token operator">:</span>    <span class="token number">0.00015795</span><span class="token operator">*</span> <span class="token number">6</span><span class="token operator">:</span>    <span class="token number">0.00001316</span><span class="token operator">*</span> <span class="token number">7</span><span class="token operator">:</span>    <span class="token number">0.00000094</span><span class="token operator">*</span> <span class="token number">8</span><span class="token operator">:</span>    <span class="token number">0.00000006</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 链表转红黑树阈值</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 红黑树转链表阈值</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 链表转红黑树，map最小容量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span></code></pre><h2 id="HashMap-jdk1-7源码解析"><a href="#HashMap-jdk1-7源码解析" class="headerlink" title="HashMap jdk1.7源码解析"></a>HashMap jdk1.7源码解析</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 第一次开始put值的时候，hash表是空的</span>    <span class="token comment" spellcheck="true">// threshold是传进来的长度</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这里证明了HashMap的key可以为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 空就往第一个数组位置里面插</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里判断传进来的key是不是已经写过了，写过了就把value修改掉</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 下文有介绍modeCount存在的意义。这里不影响put主体流程，所以暂时可以不关心</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// put进去</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inflateTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> toSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Find a power of 2 >= toSize</span>    <span class="token comment" spellcheck="true">// 这里就是空间修正代码，找到当前传的值，大于值且是2的指数次幂</span>    <span class="token keyword">int</span> capacity <span class="token operator">=</span> <span class="token function">roundUpToPowerOf2</span><span class="token punctuation">(</span>toSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里是扩容指标</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>capacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里判断是判断是否需要扩容</span>    <span class="token comment" spellcheck="true">// 判断条件是map长度大于扩容阈值，而且当前数组下标必须放了值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 扩容大小 -> map长度的2倍 </span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里就是keu为null的时候会往数组第一个位置放</span>        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// indexFor就是&amp;数组长度-1</span>        bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 元素放进去了</span>    <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ========================================扩容方法===============================</span><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 容错不管它</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>        threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// new 一个新的hash表</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 核心方法</span>    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把新的table,扩容阈值重新写入</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 新的数组容量</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历原来的table表</span>    <span class="token comment" spellcheck="true">// 这里使用双重循环是因为我们的hashmap数据结构是数组加链表，第一重遍历数组第二重遍历链表找到元素开始reHash</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// next为当前链表的下一个元素，为了后面的循环</span>            <span class="token comment" spellcheck="true">// 1</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// rehash当前节点</span>                e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>               <span class="token comment" spellcheck="true">// 用扩容后的hashmap长度计算出当前节点应该落到哪个节点上面去。</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 当前节点与别的节点指针断开指向新的节点位置</span>            <span class="token comment" spellcheck="true">// 2</span>            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 把值赋给新的节点位置，从这可以看出它是使用的是头插法</span>            <span class="token comment" spellcheck="true">// 3</span>            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 为了新一轮的遍历</span>            e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="HashMap并发场景下的死锁问题"><a href="#HashMap并发场景下的死锁问题" class="headerlink" title="HashMap并发场景下的死锁问题"></a>HashMap并发场景下的死锁问题</h3><p>（吐槽：在并发场景使用HashMap，想什么呢，HashMap本身是线程不安全的还敢在并发下用？）。</p><p>我们想一下现在有2个线程thread1,thread2,这2个线程都在进行扩容，都走到了transfer方法的2重循环内，这完全是可能的吧，因为它全程没有锁，因为它是线程不安全的。现在thread1走到了transfer代码段1（上面源码解析标注）的位置，已经把next节点定下来了时间片轮转到thread2了。thread2执行到代码段3，这时候thread1在继续往下走，最后会发现2个节点会出现循环链表。说不清，画个图来说吧。</p><p>​    <img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20200909112458.png" alt="原hashMap"></p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20200909115304.png"></p><h3 id="HashMap多线程丢数据情况分析"><a href="#HashMap多线程丢数据情况分析" class="headerlink" title="HashMap多线程丢数据情况分析"></a>HashMap多线程丢数据情况分析</h3><p>代码定位到addEntry()-&gt;createEntry()方法中</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果有多个线程同时拿的e,e应该是当前table[i]链表的第一个元素，然后你这时候拿到多个元素就会出现元素覆盖的请况，thread1头插法排到了第一个元素，而thread2拿到的e是第二个元素，用头插法，一插好家伙，吧我thread1插入的数据给顶掉了，最后thread1写的数据就丢失了，在jdk1.8这种情况也在发生，因为他是线程不安全的。<strong>注意，多线程不要用HashMap，请用ConcurrentHashMap</strong>            </p><h2 id="HashMap-jdk1-8源码解析"><a href="#HashMap-jdk1-8源码解析" class="headerlink" title="HashMap jdk1.8源码解析"></a>HashMap jdk1.8源码解析</h2><p>hashMap jdk1.8跟1.7大体逻辑是差不多的，我们就看下改动比较大的几个点</p><h3 id="树化"><a href="#树化" class="headerlink" title="树化"></a>树化</h3><p>上面说了jdk1.8的HashMap有了红黑树的数据结构，那么他怎么才会变为红黑树呢？TREEIFY_THRESHOLD = 8</p><p>下面这段是put中的关键代码从这段代码可以看出，binCount&gt;=7,所以循环肯定是8次也就是这个时候链表长度是8了。但在这个时候它先执行的是p.next = newNode(hash, key, value, null);然后在判断链表长度，所以链表长度是9的时候它才会满足树化的第一个条件走treeifyBin；不信可以测试一下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>​    树化还有一个条件就是hashmap容量大于64，这个条件就在上面的treeifyBin方法内，第一个判断就是如果容量没有达到MIN_TREEIFY_CAPACITY=64就先走扩容策略，不走树化，反之直接树化（在else逻辑内）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hd <span class="token operator">=</span> null<span class="token punctuation">,</span> tl <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> <span class="token function">replacementTreeNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> null<span class="token punctuation">)</span>                hd <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">;</span>                tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            tl <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hd<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>            hd<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h3><p>上面说到了它的扩容策略和jdk1.7是有了极大的区别，现在我们来看一下源码是怎么实现的。源码太长就不细看了，主要逻辑就是它里面分了2组链表</p><p>Node&lt;K,V&gt; loHead = null, loTail = null;<br>Node&lt;K,V&gt; hiHead = null, hiTail = null;</p><p>这2组就是高位链表和低位链表，怎么往这2个链表里面放呢？if ((e.hash &amp; oldCap) == 0) 满足这个条件就是低位链表，简单来说就是&amp;上老的容量算出来只有可能为0或hashmap的长度，为0算低位，不为0算高位。newTab[j] = loHead; newTab[j + oldCap] = hiHead;这2段代码就表明了它们应该落得位置。</p><p>（1.8的HashMap源码太复杂了，全是位运算和判断逻辑看的心累，对于1.8的源码就不详细写了。）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>                 oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// zero initial threshold signifies using defaults</span>        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// preserve order</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="modCount字段是干嘛的"><a href="#modCount字段是干嘛的" class="headerlink" title="modCount字段是干嘛的"></a>modCount字段是干嘛的</h2><p>在很多集合类都有modCount的身影，那么它到底是干嘛的呢？我们发现它存在的地方都是对集合进行了修改操作比如增加元素，删除元素。而且看过ConcurrentHashMap源码发现没有这个参数了，那么很明显它可能跟线程安全有关。还记得我们在hashMap遍历的时候如果对其进行元素的操作会发生ConcurrentModificationException异常。其实他就跟modCount有关，在迭代过程中，它会判断 modCount 跟 expectedModCount 是否相等，不等说明有其他线程在修改元素，就抛出了异常。这是<strong>Fail-Fast 机制</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程介绍与线程池底层实现原理</title>
      <link href="2020/08/27/duo-xian-cheng-jie-shao-yu-xian-cheng-chi-di-ceng-shi-xian-yuan-li/"/>
      <url>2020/08/27/duo-xian-cheng-jie-shao-yu-xian-cheng-chi-di-ceng-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="Java线程跟操作系统的关系"><a href="#Java线程跟操作系统的关系" class="headerlink" title="Java线程跟操作系统的关系"></a>Java线程跟操作系统的关系</h2><p>CPU一般有4个安全等级ring0,ring1,ring2,ring3,操作系统的内部程序指令一般运行在ring0级别，而我们的应用程序会运行在ring3上面，比如JVM进程。为什么说JVM线程的创建是一个比较重的操作。下面是一个线程创建的过程：</p><ol><li>ring3级别切换到ring0去创建线程</li><li>从ring0切回ring3,然后线程去执行程序</li><li>执行完毕就会销毁线程，这时候又会切换到ring0去销毁线程</li></ol><p>正因为线程创建销毁很重，所以才有了线程池，让一个线程多干点活，不让它活一干完就死了。这一点后面再说。</p><p>操作系统在内存上面分为用户空间，和内核空间</p><ul><li>用户空间放的是我们应用程序执行的代码</li><li>内核空间放的是内核代码</li></ul><p>因为操作系统这样的划分，所以我们有2种线程模型，KLT(内核线程模型)，ULT(用户线程模型)</p><p>内核线程模型是由内核去创建线程，用户线程模型是由用户去创建的线程。JVM就是一种内核线程模型所以便会有大量的用户态内核态之间的切换，用户线程模型就不会有这样的问题。</p><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>假设现在有2个线程thread1,thread2</p><ol><li>CPU会给这2个线程分配一个时间周期，这里假设为50ns</li><li>thread1执行了50ns就要切换回thread2执行，此时thread1的执行状态保存到TSS(程序任务状态段)上面去，方便下次找到我执行的时刻。</li></ol><p>正因为线程的时间片轮转机制所以给人的感知就是多个线程在同时执行，也就是并发。</p><p>那么现在有个问题就是多线程运行程序一定比单线程快吗？</p><p>其实不一定，多线程运行程序必然会存在着大量的线程上下文切换还有线程的创建和销毁，这些操作也是会耗时间的，而单线程不会有这样过的问题，所以是有可能多线程没有单线程要快的。</p><h3 id="如何减少线程的上下文切换"><a href="#如何减少线程的上下文切换" class="headerlink" title="如何减少线程的上下文切换"></a>如何减少线程的上下文切换</h3><ul><li>无锁并发编程：线程竞争锁的时候是会引起上下文切换的，用多线程处理数据可以分段处理，将数据拆分处理比如thread1处理0到100，thread2处理101到200，减少线程间资源的竞争</li><li>CAS算法：用CAS来对数据进行更新不需要加锁，Doug lea的AQS框架大量的运用到了这种算法。</li><li>尽量不要创建不必要的线程，用多少创建多少。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么要线程池"><a href="#为什么要线程池" class="headerlink" title="为什么要线程池"></a>为什么要线程池</h3><p>线程随用即用不好吗，为什么还要引入一个线程池的概念。首先线程资源很珍贵，不能让你想用我就new Thread()就行了，这样不仅浪费了了CPU的资源还可能拖慢运行程序。打个比方，我执行100个任务，每个任务执行时间是1ns,而我线程创建和销毁时间大概是5ns,那么我对线程的操作比执行任务的时间还长，这样降低了整个系统的运行效率。那么如何让我们创建的线程放在那不动（不会销毁），来一个活，我就接一个。这样不是会减少大量的线程创建和销毁吗。这种运用线程的方法就是线程池。简单来说就是对线程的重用。</p><h3 id="线程池的参数配置"><a href="#线程池的参数配置" class="headerlink" title="线程池的参数配置"></a>线程池的参数配置</h3><p>关于线程池的使用不介绍了，主要谈谈线程池的参数配置。先看下创建一个线程池对象的静态方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span>                              BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                              ThreadFactory threadFactory<span class="token punctuation">,</span>                              RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在一个简单的例子中介绍这7个参数</p><p>首先来一个任务，我们会判断已经创建的线程数是否小于等于 corePoolSize（核心线程数），如果小于就会创建一个线程（线程会带着任务），如果大于就会往workQueue（阻塞队列）里面去放，如果阻塞队列里面也放满了，如果此时线程数（核心线程数+非核心线程数）小于maximumPoolSize（线程总数）就会去创建一个非核心线程，大于就会走handler（拒绝策略）</p><p><strong>注意：核心线程只有创建的时候是直接拿到的任务，后续的任务全部都是去阻塞队列里面去拿的。</strong></p><p>拒绝策略分为4种当然你也可以实现RejectedExecutionHandler接口去重写rejectedExecution拒绝策略</p><p>默认4种，比较重要的就是CallerRunsPolicy，DiscardOldestPolicy：</p><ul><li>AbortPolicy: 抛异常</li><li>CallerRunsPolicy：主线程自己去执行任务</li><li>DiscardOldestPolicy：从阻塞队列里面踢掉最先进的那个元素，然后自己入队</li><li>DiscardPolicy：不作任何处理</li></ul><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span></code></pre><ul><li>RUNNING：线程池在RUNNING状态，可以接受新任务，和处理所有任务，线程刚创建就是RUNNING状态</li><li>SHUTDOWN：不接受新任务，但处理已经有的任务，<strong>shutdown方法</strong>将RUNNING-&gt;SHUTDOWN</li><li>STOP：不接受新任务，不处理已有任务，并且中断正在执行的任务，<strong>shutdownNow方法</strong>切换到STOP状态</li><li>TIDYING：所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态，而且还会执行<strong>terminated方法</strong>钩子函数，执行逻辑可以自己实现。阻塞队列为空并且线程池中执行的任务也为空时会转变为TIDYING</li><li>TERMINATED：线程池彻底终止。线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</li></ul><h3 id="excute方法源码分析"><a href="#excute方法源码分析" class="headerlink" title="excute方法源码分析"></a>excute方法源码分析</h3><p>这里有个重要参数ctl，ctl存储的是线程状态位和活跃线程数，他是一个ArtomicInteger,利用了int类型32位的特性，就32位中的前3位用来存储线程的状态后28位存储活跃线程数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ctl这里存储的是线程池状态位和活跃线程数</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从ctl里面取得活跃线程数看活跃是否小于核心线程池数量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 小于核心线程池数量就创建一个核心线程，注意这里传的值是true,标识了核心线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 活跃状态就往阻塞队列里面放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这里为什么又要拿一次状态，主要就是防止入队前后线程池状态的变化</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 再次检查线程池状态是否运行状态，不是就移除刚刚放进来的任务，并且走拒绝策略</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里为什么要判有效线程数为什么是0，主要是创建线程池时核心线程数量可以为0</span>        <span class="token comment" spellcheck="true">// 如果核心线程数是0，那么执行到这里队列中有1个任务，但没有一个可以干活的线程，这时候要创建</span>        <span class="token comment" spellcheck="true">// 一个线程去干活了，为什么是false，因为你设置的核心线程数为0这里只能创建一个非核心线程</span>        <span class="token comment" spellcheck="true">// 为什么是null,是因为这时候任务在队列里面了，我不能创建线程的时候在带着任务，只能让线程去</span>        <span class="token comment" spellcheck="true">// 队列里面去取了。</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 到这一步说明了干活线程大于核心线程池数，而且阻塞队列也满了，此时会创建一个非核心线程</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 创建非核心线程失败了，就直接走拒绝策略</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="addWorker方法源码分析"><a href="#addWorker方法源码分析" class="headerlink" title="addWorker方法源码分析"></a>addWorker方法源码分析</h3><p>addWorder方法主要工作是创建一个新的线程</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * firstTask：是线程创建时的第一个任务 * core： true就是与corePoolSize比较，false就是与maximumPoolSize比较 **/</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>    retry<span class="token operator">:</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 拿运行状态</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Check if queue empty only if necessary.</span>        <span class="token comment" spellcheck="true">// 运行状态大于shutdown状态就不接活了，</span>        <span class="token comment" spellcheck="true">// 如果状态是shutdown，虽然不接活，但也要处理之前遗留的队列里面的任务，</span>        <span class="token comment" spellcheck="true">// 但前提你不能给我任务firstTask</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>               firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>               <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// wc>=CAPACITY:工作不能大于等于所设的最大值就是int位的低29位</span>            <span class="token comment" spellcheck="true">// private static final int COUNT_BITS = Integer.SIZE - 3;</span>            <span class="token comment" spellcheck="true">// private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span>            <span class="token comment" spellcheck="true">//  wc >= (core ? corePoolSize : maximumPoolSize)就是按core传值判断是否不和规范</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span>                wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// CAS增加workcount,成功则跳出第一个循环，失败继续自旋</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 重新拿一下状态看状态是否修改，修改了就去第一个循环重新判断</span>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Re-read ctl</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建worker对象</span>        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// worker对象里面都有一个线程</span>        <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Recheck while holding lock.</span>                <span class="token comment" spellcheck="true">// Back out on ThreadFactory failure or if</span>                <span class="token comment" spellcheck="true">// shut down before lock acquired.</span>                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 这里主要是判断的是线程可不可以运行</span>                <span class="token comment" spellcheck="true">// 2个条件满足其一</span>                <span class="token comment" spellcheck="true">// 1: 运行状态</span>                <span class="token comment" spellcheck="true">// 2: shutdown状态，但新任务为空，可以执行wordQueue里面的任务</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                    <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// workers是一个HashSet</span>                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 记录出现过的线程最大数量</span>                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 启动 worker里面的线程，这时候应该去看Worker对象里面的run方法</span>                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>            <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Worker对象的run方法"><a href="#Worker对象的run方法" class="headerlink" title="Worker对象的run方法"></a>Worker对象的run方法</h3><p>Worker是一个ThreadPoolExecutor内部类，此时才是真正干活的线程</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 他这里继承了AQS和实现了Runable</span><span class="token comment" spellcheck="true">// 实现Runable是为了让自己成为一个线程</span><span class="token comment" spellcheck="true">// 继承AQS是为了实现独占锁，在addWorker里面会用到，为什么不用ReentrantLock呢？</span><span class="token comment" spellcheck="true">// TODO</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>        <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>        <span class="token keyword">implements</span> <span class="token class-name">Runnable</span>    <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6138294804551838833L<span class="token punctuation">;</span>        <span class="token keyword">final</span> Thread thread<span class="token punctuation">;</span>        Runnable firstTask<span class="token punctuation">;</span>        <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>        <span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 初始化把state设值为-1，是为了使还没执行任务的线程不会被中断，执行任务时会把它设为0</span>            <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>            <span class="token comment" spellcheck="true">// 这里吧firstTask保存，并带到线程去</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 调用外部类runWorker方法</span>            <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Lock methods</span>        <span class="token comment" spellcheck="true">//</span>        <span class="token comment" spellcheck="true">// The value 0 represents the unlocked state.</span>        <span class="token comment" spellcheck="true">// The value 1 represents the locked state.</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 尝试CAS更新state状态值为1失败，返回false，从这一点可以看出Worker是想做一把不可重入的锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">interruptIfStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Thread t<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> thread<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化的时候state是-1，这里调用unlock是吧它置为0，可以中断</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果task为空，则通过getTask来获取任务</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 执行任务，如果任务发生了异常，会往外抛执行processWorkerExit方法，</span>                    <span class="token comment" spellcheck="true">// 从这个方法可以看出线程池不会因为某个任务发生异常就不执行了，发生异常线程池会创建一个没有任务的线程</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// timeOut：上次从队列拿任务时是否超时</span>    <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Did the last poll() time out?</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 线程池不在runing看线程池是否在stop或者阻塞队列是否为空</span>        <span class="token comment" spellcheck="true">// 如果是true。那线程池是不能执行新任务</span>        <span class="token comment" spellcheck="true">// 就应该吧之前放进来的任务去掉，也就是要把wordcount-1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Are workers subject to culling?</span>        <span class="token comment" spellcheck="true">// 判断是否需要进行超时控制</span>        <span class="token comment" spellcheck="true">// allowCoreThreadTimeOut默认false,这一点可以看得出来核心线程数不会进行超时控制</span>        <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">></span> corePoolSize<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里做的事情主要是如果有超时控制且确实超时了，而且阻塞队列是空的</span>        <span class="token comment" spellcheck="true">// 也就说明我们工作线程太多了，这时候就应该要减少工作线程，减一失败则重试</span>        <span class="token comment" spellcheck="true">// 但这里有timed控制也说明了它不会减核心线程</span>        <span class="token comment" spellcheck="true">// 线程如何销毁呢？</span>        <span class="token comment" spellcheck="true">// 这里CAS成功则返回null,返回null则表示runWorker 的while循环要跳出去了，也就是线程结束了，JVM回收即可。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果有超时控制就用阻塞队列的poll方法可以控制时间，</span>            <span class="token comment" spellcheck="true">// workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)表示在keepAliveTime时间下如果取不出来值会阻塞，超过时间就返回null</span>            Runnable r <span class="token operator">=</span> timed <span class="token operator">?</span>                workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span>            workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> r<span class="token punctuation">;</span>            timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span>            timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="processWorkerExit方法"><a href="#processWorkerExit方法" class="headerlink" title="processWorkerExit方法"></a>processWorkerExit方法</h3><p>processWorkerExit方法在于runWorker的finally代码块里面的，执行任务发生异常或正常结束任务会走的方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">,</span> <span class="token keyword">boolean</span> completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// completedAbruptly这个参数在runWorker里面传入的，</span>    <span class="token comment" spellcheck="true">// true说明发生了异常,我们要将workcount减一；所以走了decrementWorkerCount方法</span>    <span class="token comment" spellcheck="true">// false说明正常结束任务，怎么结束？getTask方法为null.说明我们已经将wordcount已经减一了。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>completedAbruptly<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// If abrupt, then workerCount wasn't adjusted</span>        <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 统计完成的任务数</span>        completedTaskCount <span class="token operator">+=</span> w<span class="token punctuation">.</span>completedTasks<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从workers中移除，说明从线程池移除了一个工作线程</span>        workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 根据线程池状态判断是否要终止线程池</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果当前线程池状态是RUNNING,或SHUTDOWN状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果不是异常终止</span>        <span class="token comment" spellcheck="true">// allowCoreThreadTimeOut = true 而且阻塞队列为空时，一个线程不留</span>        <span class="token comment" spellcheck="true">// allowCoreThreadTimeOut = true 而且阻塞队列不为空时，就保留最少一个线程</span>        <span class="token comment" spellcheck="true">// allowCoreThreadTimeOut = false 就保留最少线程小于核心线程数</span>        <span class="token comment" spellcheck="true">// min值有0,1，corePoolSize三种</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> corePoolSize<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">>=</span> min<span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// replacement not needed</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果是异常终止的会 addWorker(null, false)加一个null任务的线程</span>        <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="延迟类线程池"><a href="#延迟类线程池" class="headerlink" title="延迟类线程池"></a>延迟类线程池</h2><p>线程池家族里面有一类特殊的线程池，叫做延迟类线程池ScheduledThreadPoolExecutor，先看一下它的继承关系</p><p><img src="https://blog-dm.oss-cn-shanghai.aliyuncs.com/articleimage/20200907114109.png"></p><p>很明显它继承了ThreadPoolExcutor,所以他也是一个线程池，只是在线程池上对他进行了增强，在看一下它的构造方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                                       ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                                       RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                                       ThreadFactory threadFactory<span class="token punctuation">,</span>                                       RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> threadFactory<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从中可以看出它不需要很多的参数，在线程池中的大部分参数它不要设置，比如最大线程数和超时时间和超时时间单位，在延迟类线程池中只需要传入一个核心线程数就可以创建一个延迟线程池了。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>它和线程池的处理不一样，来了一个任务它不会直接创建工作线程，而是直接丢到队列里面去。线程去队列里面去拿任务执行。</p><p>他这里的队列有点特别，它是DelayQueue，它会根据时间排序。因为他要保证延迟线程池里面不同的线程所延迟时间不同，他需要根据延迟时间吧他们排好序，先执行的应该在最前面。</p><p>下面先介绍下ThreadPoolExcutor的三种提交任务的方式.</p><ol><li><p>schedule方法，延迟执行，scheduler第二个参数和第三个参数规定了延迟时间。</p><pre class=" language-java"><code class="language-java">ScheduledThreadPoolExecutor scheduledThreadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>scheduledThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>scheduleWithFixedDelay方法，延迟执行，周期执行，等待之前的任务执行完成才开始计算周期时间。第一个参数：任务，第二个参数：初始化延时时间，第三个参数是周期时间，第四个参数时间单位</p><p>下面这段代码执行会是执行完第一个任务睡5秒，5秒睡完才开始计算时间计算到周期时间才会执行第二个任务</p><pre class=" language-java"><code class="language-java">scheduledThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是scheduleWithFixedDelay调度1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>scheduledThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是scheduleWithFixedDelay调度2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>scheduleAtFixedRate方法，延迟执行，周期执行，不等待前一个任务执行完，就开始计算周期时间；第一个参数：任务，第二个参数：初始化延时时间，第三个参数是周期时间，第四个参数时间单位</p><p>下面这段代码就是先执行第一个任务，任务已执行不管你执行完没完我就计算周期时间</p><pre class=" language-java"><code class="language-java">scheduledThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是scheduleAtFixedRate调度1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>scheduledThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是scheduleAtFixedRate调度2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><p>下面看下源码是怎么实现的这几种提交方式</p><h3 id="对比三种提交方式"><a href="#对比三种提交方式" class="headerlink" title="对比三种提交方式"></a>对比三种提交方式</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 提交方式</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>V<span class="token operator">></span> ScheduledFuture<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token function">schedule</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">,</span>                                           <span class="token keyword">long</span> delay<span class="token punctuation">,</span>                                           TimeUnit unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>callable <span class="token operator">==</span> null <span class="token operator">||</span> unit <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里decorateTask点进去一看就发现是一个空方法，不管它只是一个封装任务而已</span>    <span class="token comment" spellcheck="true">// triggerTime算出初始化执行时间now()+initDeley &lt; 0 ? 0 : initDelay</span>    RunnableScheduledFuture<span class="token operator">&lt;</span>V<span class="token operator">></span> t <span class="token operator">=</span> <span class="token function">decorateTask</span><span class="token punctuation">(</span>callable<span class="token punctuation">,</span>                                                <span class="token keyword">new</span> <span class="token class-name">ScheduledFutureTask</span><span class="token operator">&lt;</span>V<span class="token operator">></span><span class="token punctuation">(</span>callable<span class="token punctuation">,</span>                                                                           <span class="token function">triggerTime</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里是提交任务的方法</span>    <span class="token function">delayedExecute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// scheduleAtFixedRate提交方法</span><span class="token keyword">public</span> ScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">,</span>                                                  <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span>                                                  <span class="token keyword">long</span> period<span class="token punctuation">,</span>                                                  TimeUnit unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null <span class="token operator">||</span> unit <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>period <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 封装任务</span>    ScheduledFutureTask<span class="token operator">&lt;</span>Void<span class="token operator">></span> sft <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">ScheduledFutureTask</span><span class="token operator">&lt;</span>Void<span class="token operator">></span><span class="token punctuation">(</span>command<span class="token punctuation">,</span>                                      null<span class="token punctuation">,</span>                                      <span class="token function">triggerTime</span><span class="token punctuation">(</span>initialDelay<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">,</span>                                      unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>period<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RunnableScheduledFuture<span class="token operator">&lt;</span>Void<span class="token operator">></span> t <span class="token operator">=</span> <span class="token function">decorateTask</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> sft<span class="token punctuation">)</span><span class="token punctuation">;</span>    sft<span class="token punctuation">.</span>outerTask <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里是提交任务的方法</span>    <span class="token function">delayedExecute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// scheduleWithFixedDelay提交方法</span><span class="token keyword">public</span> ScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">,</span>                                                     <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span>                                                     <span class="token keyword">long</span> delay<span class="token punctuation">,</span>                                                     TimeUnit unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null <span class="token operator">||</span> unit <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 封装任务</span>    ScheduledFutureTask<span class="token operator">&lt;</span>Void<span class="token operator">></span> sft <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">ScheduledFutureTask</span><span class="token operator">&lt;</span>Void<span class="token operator">></span><span class="token punctuation">(</span>command<span class="token punctuation">,</span>                                      null<span class="token punctuation">,</span>                                      <span class="token function">triggerTime</span><span class="token punctuation">(</span>initialDelay<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">,</span>                                      unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span><span class="token operator">-</span>delay<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RunnableScheduledFuture<span class="token operator">&lt;</span>Void<span class="token operator">></span> t <span class="token operator">=</span> <span class="token function">decorateTask</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> sft<span class="token punctuation">)</span><span class="token punctuation">;</span>    sft<span class="token punctuation">.</span>outerTask <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里是提交任务的方法</span>    <span class="token function">delayedExecute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们对比一下scheduleAtFixedRate和scheduleWithFixedDelay这2个方法基本没什么区别。仔细对比发现他们之间除了参数名字不一致以外，还有一个很关键的区别在封装ScheduledFutureTask任务时，scheduleAtFixedRate传的是unit.toNanos(period)，而scheduleWithFixedDelay传的是unit.toNanos(-delay)，一个是正数一个是负数，其余就没区别了。这里的具体原因在后面修改周期时间那里会有介绍。</p><h3 id="delayedExecute方法"><a href="#delayedExecute方法" class="headerlink" title="delayedExecute方法"></a>delayedExecute方法</h3><p>delayedExecute是提交任务的方法，任务封装成ScheduledFutureTask，就要把这个任务放进任务队列里面去了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">delayedExecute</span><span class="token punctuation">(</span>RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断是否是shutdown状态，是的话不在处理新任务走拒绝策略</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 是运行状态将任务放进队列里面去</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// task.isPeriodic()从构造方法可以看出周期任务period != 0,延迟任务是=0</span>        <span class="token comment" spellcheck="true">// isPeriodic方法只是通过period != 0 是true否则是false</span>        <span class="token comment" spellcheck="true">// canRunInCurrentRunState 获取了当前是周期任务还是延迟任务。</span>        <span class="token comment" spellcheck="true">// 分析出continueExistingPeriodicTasksAfterShutdown是周期任务</span>        <span class="token comment" spellcheck="true">// 分析出executeExistingDelayedTasksAfterShutdown是延迟任务</span>        <span class="token comment" spellcheck="true">// 判断线程池的状态，和当前任务是否能运行。如果不能继续执行，将任务移出队列并取消任务。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span><span class="token function">canRunInCurrentRunState</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">isPeriodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>            task<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment" spellcheck="true">// 这里就是增加线程去处理任务，从这也可以看出它和线程池的区别，</span>            <span class="token comment" spellcheck="true">// 刚创建任务的时候不会创建把线程和任务绑定</span>            <span class="token function">ensurePrestart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">ensurePrestart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取当前活跃线程数</span>    <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果活跃线程数小于核心线程数就创建线程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span>        <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取当前活跃线程数是0而且也不小于核心线程数，说明你此时设定的核心线程数是0，小于0会报错</span>    <span class="token comment" spellcheck="true">// 主要就是为了兼容线程池可以创建核心线程数为0</span>    <span class="token comment" spellcheck="true">// 这里是为了避免有任务但没线程执行的尴尬</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="SchduledFutureTask的run方法"><a href="#SchduledFutureTask的run方法" class="headerlink" title="SchduledFutureTask的run方法"></a>SchduledFutureTask的run方法</h3><p>真正执行任务的方法</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// task.isPeriodic()从构造方法可以看出周期任务period != 0,延迟任务是=0</span>     <span class="token comment" spellcheck="true">// isPeriodic方法只是通过period != 0 是true否则是false</span>     <span class="token comment" spellcheck="true">// true代表是周期任务 false代表是延迟任务</span>     <span class="token keyword">boolean</span> periodic <span class="token operator">=</span> <span class="token function">isPeriodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 判断是否可以运行，不可以cancel掉任务</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">canRunInCurrentRunState</span><span class="token punctuation">(</span>periodic<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 延迟任务</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>periodic<span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">// 直接调用一次</span>         ScheduledFutureTask<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 此时它一定是周期任务runAndReset运行不返回结果</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ScheduledFutureTask<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">runAndReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 设值下一次执行时间</span>         <span class="token function">setNextRunTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 重新入队</span>         <span class="token function">reExecutePeriodic</span><span class="token punctuation">(</span>outerTask<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setNextRunTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> p <span class="token operator">=</span> period<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 此时就是前面2种周期任务提交方式的区别所导致的，还记得前面如果是</span>    <span class="token comment" spellcheck="true">// scheduleAtFixedRate提交方式period是正数；scheduleWithFixedDelay提交方式period是负数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 执行线程时间加周期时间</span>        time <span class="token operator">+=</span> p<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment" spellcheck="true">// 现在时间加周期时间</span>        time <span class="token operator">=</span> <span class="token function">triggerTime</span><span class="token punctuation">(</span><span class="token operator">-</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h3><p>DelayedWorkQueue是优先级队列，ScheduledThreadPoolExecutor它所使用的队列就是DelayedWorkQueue。之所以使用DelayedWorkQueue，是因为定时任务执行，总要取出最近要执行的任务，所以一定要取队列中最靠前的任务。</p><p>他是一个堆结构，底层是数组；它不能保证所有的元素一定是顺序的，但能保证你从堆顶拿到的元素一定是所有里面最大或最小的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务系统解析</title>
      <link href="2020/08/25/mysql-shi-wu-xi-tong-jie-xi/"/>
      <url>2020/08/25/mysql-shi-wu-xi-tong-jie-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近啃MySQL相关的知识，了解到事务以及事务隔离机制，想要深入了解下事务是如何实现的下面是此次主要探讨的几点方向。这里先推荐几篇文章</p><p><a href="http://mysql.taobao.org/monthly/2017/12">数据库内核月报 － 2017 / 12</a></p><p><a href="http://mysql.taobao.org/monthly/2017/10">数据库内核月报 － 2017 / 10</a></p><p><a href="http://mysql.taobao.org/monthly/2015/04">数据库内核月报 － 2015 / 04</a></p><ol><li>事务及其ACID特性</li><li>并发事务带来的问题</li><li>事务隔离机制以及解决并发事务问题</li><li>事务隔离机制如何实现（MVCC多版本并发控制机制）</li></ol><h2 id="事务及其ACID特性"><a href="#事务及其ACID特性" class="headerlink" title="事务及其ACID特性"></a>事务及其ACID特性</h2><p>事务一般具有4个特性，这4个特性一般简称ACID特性</p><ul><li>A（原子性）：事务要么全部成功，要么全部失败</li><li>C（一致性）：不管什么时候，数据都是一致的，不会读到中间状态的数据</li><li>I（隔离性）：多个事务之间相互不影响</li><li>D（持久性）：在事务执行过程中，不管怎么样数据都不能丢，MySQL是使用了redo log实现的。</li></ul><h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p>并发事务带来了更新丢失，脏读，不可重读，幻读4种问题</p><ul><li>更新丢失：当多个事务同时执行一行数据时，第一个事务已经对行做了修改但第二个事务不知道就把第一个事务更新的数据给修改了，出现了更新丢失的情况。<strong>当前事务的更新覆盖了其他事务的更新</strong>。</li><li>脏读：第一个事务已经做了写操作，但此时并没有提交事务，然后第二个事务读取到了这条数据，也就是第二条数据读取到了脏数据，这就是所谓的脏读。<strong>当前事务读取了其他事务的已经修改但未提交的数据</strong>。</li><li>不可重读：一个事务开始查询了某个语句，第二次执行同样的语句发现查询的东西不一样了。<strong>当前事务在不同时刻执行同样的查询语句，查询出的结果不一样</strong></li><li>幻读：一个事务按相同的查询条件查询读取已经检索过的数据，却发现其他事务插入了满足条件的数据。<strong>当前事务读取到了其他事务插入的数据</strong></li></ul><h2 id="事务隔离机制"><a href="#事务隔离机制" class="headerlink" title="事务隔离机制"></a>事务隔离机制</h2><p>事务隔离机制有4种，读未提交，读已提交，可重读，串行化</p><ul><li>RU(Read uncommitted)：读未提交</li><li>RC(Read committed)：读已提交</li><li>RR(Repeatable read)：重复读</li><li>SERIALIZABLE(Serializable)：串行化</li></ul><h3 id="隔离级别对并发事务的解决"><a href="#隔离级别对并发事务的解决" class="headerlink" title="隔离级别对并发事务的解决"></a>隔离级别对并发事务的解决</h3><table><thead><tr><th align="center"></th><th align="center">脏读</th><th align="center">不可重读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读未提交</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">读已提交</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">重复读</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">串行化</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><p>读已提交，重复读是通过MVCC机制解决的并发问题。串行化是通过对数据库加锁控制其他事务对数据的操作解决并发问题。<strong>事务隔离级别越高对并发的问题越小，但相应的付出的代价也会越大</strong>；串行化肯定是并发影响最小的，当你访问某个数据时串行化直接来个行锁或表锁，其他的数据只能阻塞在后面等这边的数据处理完成后才可以进行访问。串行化对数据库性能影响太大所以<strong>MySQL综合考虑默认使用的是重复读隔离级别</strong>。</p><h2 id="MVCC多版本并发控制机制"><a href="#MVCC多版本并发控制机制" class="headerlink" title="MVCC多版本并发控制机制"></a>MVCC多版本并发控制机制</h2><p>MVCC（Multi-Version Concurrency Control）：多版本并发控制机制，对一行数据的读写操作不通过加锁来保证隔离性，提高性能。MVCC不是MySQL所特有的在Oracle,PostgreSQL都有关于MVCC的实现，实现可能是不一样的。还有MVCC只在读已提交和重复度2个隔离级别下才干活。读未提交只读最新的数据（不管你事务提不提交）它不需要任何锁，串行化直接搞把锁，所以也不需要MVCC来控制。</p><p>在介绍MVCC机制前先介绍2个概念，undo log和read view</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log是日志版本链，当我们对记录做了变更操作就会产生一条undo记录，undo记录主要在每条数据后面加2个隐藏字段DATA_TRX_ID，DATA_ROLL_PTR其实应该是3个，如果表没有主键还会生成一个DB_ROW_ID。<a href="http://www.searchdoc.cn/rdbms/mysql/dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.com.coder114.cn.html">InnoDB多版本控制</a></p><ul><li>DATA_TRX_ID：事务编号，6字节，记录更新这条行记录的事务编号</li><li>DATA_ROLL_PTR：回滚指针，7字节，记录</li><li>DB_ROW_ID：主键编号，6字节，没有主键会自动生成</li></ul><p>事务id的生成是在对innodb进行了写操作而生成的。在InnoDB看来所有的事务在启动时候都是只读状态是只读事务此时不会生成事务编号。<a href="http://mysql.taobao.org/monthly/2017/12">数据库内核月报 － 2017 / 12</a></p><p>undo log记录过程：首先表里有一个数据，伴随着隐藏字段DATA_TRX_ID，DATA_ROLL_PTR，然后有一个事务100对其进行了修改，这时候我们会把原先的数据copy一份到undo log中去，然后把修改后的数据也放进undo log,但这条数据的DATA_TRX_ID = 100，DATA_ROLL_PTR指向原来的数据。如果这时候又来了一个事务200，此时事务100还没提交，事务200又进行了一次更新会把新数据写进undo log并且DATA_TRX_ID = 200，DATA_ROLL_PTR指向事务100的那条数据。</p><p><img src="https://i.loli.net/2020/09/03/k1JtNnVGyXmRc2I.png" alt="日志版本链生成过程"></p><p>最后在undo log中的日志版本链就是</p><p><img src="https://i.loli.net/2020/09/03/rExVXKv4Gp5olIH.png" alt="日志版本链"></p><h3 id="read-view（快照）"><a href="#read-view（快照）" class="headerlink" title="read view（快照）"></a>read view（快照）</h3><p>read view在MVCC里面主要做的就是可见性判断，read view 的生成时机就是RR,RC两种隔离级别的主要区别</p><ul><li>RR隔离级别，只要是开启事务后的第一次select查询操作便会生成一次read view,后面便不再维护read view了</li><li>RC隔离级别，开启事务后，只要进行了查询语句便会生成一次read view</li></ul><h3 id="read-view创建过程"><a href="#read-view创建过程" class="headerlink" title="read view创建过程"></a>read view创建过程</h3><ol><li>首先看当前所有未提交的事务，存储在数组中<strong>trx_ids</strong></li><li>选取未提交事务的最小的事务编号为<strong>up_limit_id</strong>,</li><li>选取已提交事务的最大的事务编号加1为<strong>low_limit_id</strong></li></ol><p>1）trx_id&lt;up_limit_id；小于最小未提交事务肯定是已提交事务，可见<br>2）trx_id&gt;low_limit_id；大于最大已提交事务肯定是后面创建的事务，不可见<br>3）up_limit_id&lt;=trx_id&lt;=low_limit_id；分2种情况</p><ul><li>trx_id在trx_ids中说明是未提交事务，不可见</li><li>trx_id不在trx_ids中说明是已提交事务，可见</li></ul><p>MVCC如何利用日志版本链来进行查询的？</p><p>根据图第二次查询结果还是hello,但此时undo log日志版本链最新的是hello2，这里主要走的过程是，看undolog日志版本链从最新往下看，最新是事务1，发现事务1在已提交事务和未提交事务区间内而且是在trx_ids中，说明是不可见的，所以继续undolog日志版本链往下看。发现是事务3，发现事务3在已提交事务&amp;未提交事务区间而且不再trx_id中所以是可见的。</p><p>​    <img src="https://i.loli.net/2020/09/03/YuX6dImOpJKa4zW.png" alt="MVCC"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
